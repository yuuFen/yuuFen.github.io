<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yuufen.com/blog</id>
    <title>YuuFen</title>
    <updated>2020-03-09T18:28:19.200Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yuufen.com/blog"/>
    <link rel="self" href="https://yuufen.com/blog/atom.xml"/>
    <subtitle>希望你可以记住我</subtitle>
    <logo>https://yuufen.com/blog/images/avatar.png</logo>
    <icon>https://yuufen.com/blog/favicon.ico</icon>
    <rights>All rights reserved 2020, YuuFen</rights>
    <entry>
        <title type="html"><![CDATA[你好呀，陌生人]]></title>
        <id>https://yuufen.com/blog/post/about/</id>
        <link href="https://yuufen.com/blog/post/about/">
        </link>
        <updated>2024-02-28T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>因为笔记太多太杂，决定定期写写博客整理整理笔记。</p>
<p><s>然后因为各种原因失去了动力</s></p>
<p><s>因此搞丢了好多笔记啊啊啊啊啊啊啊😭😭😭</s></p>
<p><s>看了看一年前的博文发现自己真的变化了蛮多的（加油💪）</s></p>
<p>总之现在又开始了</p>
<h2 id="关于我">🐟 关于我</h2>
<p>我目前大二在读，我的职业规划是前端工程师，我的专业是电子信息，所以我还了解一些嵌入式开发（当然只是一些些），对Python和TensorFlow也有一定的涉猎。我正在努力寻找暑期实习！</p>
<p>在以下位置找到有关我的更多信息：</p>
<p><a href="https://yuufen.com/" target="_blank" class="text-button">主页</a><a href="https://yuufen.com/blog" target="_blank" class="text-button">博客</a><a href="https://github.com/yuuFen" target="_blank" class="text-button">项目</a><a href="mailto:me@yuufen.com" class="text-button">给我发邮件</a></p>
<h2 id="兴趣爱好">🎨 兴趣爱好</h2>
<p><strong>摄影</strong>、羽毛球、轮滑，and playing!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[虚拟 DOM 深入与简单实现]]></title>
        <id>https://yuufen.com/blog/post/M0Xa7RsWm/</id>
        <link href="https://yuufen.com/blog/post/M0Xa7RsWm/">
        </link>
        <updated>2020-03-07T20:24:31.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 源码解析]]></title>
        <id>https://yuufen.com/blog/post/jD_rI1NpH/</id>
        <link href="https://yuufen.com/blog/post/jD_rI1NpH/">
        </link>
        <updated>2020-03-04T18:22:09.000Z</updated>
        <content type="html"><![CDATA[<center>
        <a href="https://yuufen.com/blog/post/28tbvr2E1/">启动项目与入口文件分析</a>
</center>
<center>
        <a href="https://yuufen.com/blog/post/sW2ztpxVO/">从 Vue 声明发散</a>
</center>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端性能优化总结]]></title>
        <id>https://yuufen.com/blog/post/xYd9Z_Vfp/</id>
        <link href="https://yuufen.com/blog/post/xYd9Z_Vfp/">
        </link>
        <updated>2020-03-02T06:21:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h2 id="新玩意prepack">新玩意：Prepack</h2>
<p>在编译阶段做预计算<br>
<a href="prepack.io">prepack.io</a></p>
</blockquote>
<h2 id="从输入-url-到显示页面发生了什么">从输入 url 到显示页面，发生了什么？</h2>
<p><strong>从输入 url 到显示页面，发生了什么？</strong></p>
<ol>
<li>用户输入 yuufen.com</li>
<li>浏览器通过 DNS，把 url 解析为 IP</li>
<li>和 IP 地址建立 TCP 连接，发送 HTTP 请求</li>
<li>服务器接收请求，查库，读文件等，拼接好返回的 HTTP 响应</li>
<li>浏览器收到首屏 html，开始渲染</li>
<li>解析 html 为 dom（同时加载额外的 css 和 js）</li>
<li>解析 css 为 css-tree（CSS 选择器从<strong>右</strong>向左过滤查找）</li>
<li>dom + css 生成 render-tree，绘图</li>
</ol>
<p>这是一个万能的面试题，这个题的答案包含着整个互联网运行的过程，我们性能优化的策略就是基于它的答案，针对每一步依次解析，让整体的时间变短。所以有两个大方向：</p>
<ol>
<li>少加载文件</li>
<li>少执行代码</li>
</ol>
<h2 id="雅虎军规">雅虎军规</h2>
<blockquote>
<p>虽然随着 Vue、React、Angular 这些框架的流行，雅虎军规当中一些优化的方法已不在适用，但是，更多的时候，我们是学习这些方法背后的思想，而不是去死记硬背某个方法，技术总是在更迭，只有握方法背后的思想，才能够立于不败之地。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1583615829278.jpg" alt="" loading="lazy"></figure>
<p>https://developer.yahoo.com/performance/rules.html</p>
<p>https://juejin.im/post/5b73ef38f265da281e048e51</p>
<h2 id="性能指标">性能指标</h2>
<blockquote>
<p>抛开场景谈性能优化，都是耍流氓</p>
</blockquote>
<h3 id="performance-api">Performance API</h3>
<p>提到性能优化指标就不得不说 Performance API，首先来看 MDN 上关于这个 API 的 介绍：Performance 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API。该类型的对象可以通过调⽤用只读属性 Window.performance 来获得。</p>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1583740522448.png" alt="" loading="lazy"></figure>
<pre><code class="language-js">const timingInfo = window.performance.timing
console.log({
  TCP连接耗时: timingInfo.connectEnd - timingInfo.connectStart,
  DNS查询耗时: timingInfo.domainLookupEnd - timingInfo.domainLookupStart,
  '获得首字节耗费时间，也叫TTFB': timingInfo.responseStart - timingInfo.navigationStart,
  domReady时间: timingInfo.domContentLoadedEventStart - timingInfo.navigationStart,
  DOM资源下载: timingInfo.responseEnd - timingInfo.responseStart,
})
</code></pre>
<ol>
<li>First Paint(简称 FP)：表示文档中任一元素首次渲染时间。</li>
<li>First Contentful Paint(简称 FCP)：当浏览器首次渲染任何文本，图像（包括背景图像），非白色画布或 SVG 时。这个指标就是我们日常说的白屏时间。</li>
<li>First Meaningful Paint(简称 FMP)：首次有意义的绘制，这个指标反映的是主要内容出现在页面上所需要的时间，如果 FMP 时间过长的话，这里就要考虑是不是静态文件阻塞了主线程。</li>
<li>Time To Interactive(TTI)：可交互时间，等到服务器通过 HTTP 协议将响应全部返回之后，便开始 DOM Tree 的构建，完成之后，网页变成可交互状态，到此为止便是网页的可交互时间。用户可以进行正常的事件输入交互操作，这个指标是最重要的用户体验指标，用户最关心的就是什么时候可以进行交互，所以通常这个指标是我们优化的重点。</li>
</ol>
<h3 id="浏览器-performance-工具">浏览器 Performance 工具</h3>
<h3 id="lighthouse">Lighthouse</h3>
<ul>
<li>安装 chrome 插件 （或者）</li>
<li><code>npm install -g lighthouse</code></li>
</ul>
<pre><code>lighthouse https://yuufen.com/
</code></pre>
<h2 id="网络">网络</h2>
<h3 id="dns">DNS</h3>
<p>prefetch</p>
<figure data-type="image" tabindex="3"><img src="https://yuufen.com/blog/post-images/1583617452917.png" alt="" loading="lazy"></figure>
<h3 id="tcp">TCP</h3>
<h4 id="ip-tcp-http-的关系">IP、TCP、HTTP 的关系</h4>
<ol>
<li>
<p>IP-门牌号，通过 IP 协议找到对应机器</p>
</li>
<li>
<p>TCP 负责数据完整性和有序性，通过三次握手、粘包、滑动窗口等非常庞大的网络协议机制</p>
</li>
<li>
<p>HTTP 负责应用层数据，文件编码、cookie、缓存、数据终止时机等</p>
</li>
</ol>
<h4 id="优化tcp策略">优化（TCP）策略</h4>
<ol>
<li>长连接</li>
<li>减少文件体积
<ol>
<li>js 打包压缩</li>
<li>图片压缩</li>
<li>gzip</li>
</ol>
</li>
<li>减少文件请求次数
<ol>
<li>雪碧图</li>
<li>js、css 打包</li>
<li>缓存控制</li>
<li>懒加载</li>
</ol>
</li>
<li>减少用户和服务器的举例
<ol>
<li>cdn</li>
</ol>
</li>
<li>本地储存</li>
</ol>
<h2 id="图片">图片</h2>
<h3 id="选择合适格式">选择合适格式</h3>
<ol>
<li>PNG</li>
</ol>
<p>png-8 png-24 png-32</p>
<p>logo，颜色简单但对图片质量要求高、精灵图</p>
<ol start="2">
<li>
<p>JPG/JPEG</p>
</li>
<li>
<p>GIF</p>
</li>
<li>
<p>SVG</p>
</li>
</ol>
<p>SVG 图像中的文本时可选取可搜索的。</p>
<p>常用来绘制地图、股票 k 线图</p>
<p>会损耗性能</p>
<ol start="5">
<li>WebP</li>
</ol>
<p>全能的解决方案，但是兼容性不好，需要根据浏览器判断加载格式</p>
<ol start="6">
<li>Base64</li>
</ol>
<p>图片 base64 之后会变大，适合小的矢量图标</p>
<h3 id="其他">其他</h3>
<ol>
<li>图片渐进显示</li>
<li>懒加载</li>
<li>骨架图</li>
</ol>
<h2 id="缓存">缓存</h2>
<p>可以少加载文件</p>
<ol>
<li>cdn 缓存</li>
<li>本地缓存
<ol>
<li>localstorage</li>
<li>indexdb</li>
<li>cookie</li>
</ol>
</li>
<li>浏览器缓存</li>
</ol>
<h3 id="cdn">CDN</h3>
<p>缓存+回源</p>
<p>地理位置更近，新的域名规避 cookie</p>
<h3 id="浏览器缓存">浏览器缓存</h3>
<figure data-type="image" tabindex="4"><img src="https://yuufen.com/blog/post-images/1583741167549.png" alt="" loading="lazy"></figure>
<h4 id="流程">流程</h4>
<ol>
<li>获取文件</li>
<li>文件返回 express 或者 cache-control 设置过期时间，并且带上 etag 或者 lastModfied 字段</li>
<li>再次请求，浏览器先查询 expres 或者 cache-control 是否过期，若没过期，强缓存生效，不发出网络请求，直接使用缓存</li>
<li>若强缓存失效，浏览器会带上 etag 或者 lastModfied 数据，使用 if-none-match 或者 if-Modified-Since 字段，咨询后端是否过期</li>
<li>若没过期，返回 304 状态码，直接用缓存</li>
<li>若过期，状态码 200，返回新资源</li>
</ol>
<h4 id="强缓存">强缓存</h4>
<h5 id="expires">expires</h5>
<p>http 1.0 中</p>
<h5 id="cache-control">Cache-Control</h5>
<p>http 1.1 中</p>
<h4 id="协商缓存">协商缓存</h4>
<h5 id="last-modified-if-modified-since">Last-Modified / If-Modified-Since</h5>
<p>标注时间（只能精确到秒）</p>
<h5 id="etag-if-none-match">Etag / If-None-Match</h5>
<p>根据文件内容计算 hash</p>
<h3 id="webpack-打包和缓存的关系">webpack 打包和缓存的关系</h3>
<p>通过 hash 来判断是否有更新：</p>
<ol>
<li>hash：整个项目相关的 hash</li>
<li>chunkhash：入口文件依赖的 chunkhash</li>
<li>contenthash：文件内容的 hash</li>
</ol>
<h3 id="其他-2">其他</h3>
<ol>
<li>memory cache 内存缓存，比如储存在变量里，关闭 tab 就没了</li>
<li>Disk cache 硬盘上的缓存</li>
<li>Push cache 推送缓存 http2</li>
<li>service worker 浏览器背后的独立进程</li>
</ol>
<h2 id="渲染">渲染</h2>
<h3 id="浏览器渲染原理">浏览器渲染原理</h3>
<p>经典文章 how browser works</p>
<p>https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</p>
<figure data-type="image" tabindex="5"><img src="https://yuufen.com/blog/post-images/1583741367851.png" alt="" loading="lazy"></figure>
<p>首先是解析 HTML。这个过程主要是把 HTML 文档解析为 DOM 树的过程，如果遇到&lt;script&gt;标签，则会停止解析，先执行标签当中的 JavaScript；如果是外联方式，也需要等待下载并执行完对应的 JavaScript 代码，然后才能继续执行解析 HTML 的工作。HTML 解析完成后触发 DOMContentLoaded 事件，这里我们就可以操作 DOM 了。</p>
<p>生成对应的 DOM 树结构：</p>
<figure data-type="image" tabindex="6"><img src="https://yuufen.com/blog/post-images/1583741376936.png" alt="" loading="lazy"></figure>
<p>同时会解析 CSS。解析 HTML 和解析 CSS 是并行处理的，不然会造成渲染的内容没有对应的样式。解析 CSS 遇到&lt;script&gt;标签和上面解析 HTML 的处理方式是一样的。CSS 解析器将 CSS 解析成 CSSStyleSheet（也被叫做 CSSOM 树），和 DOM 树结构类似。</p>
<p>CSSOM 树：</p>
<figure data-type="image" tabindex="7"><img src="https://yuufen.com/blog/post-images/1583741498395.png" alt="" loading="lazy"></figure>
<p>DOM 树和 CSSOM 树一起附着合成渲染树（Render Tree）：</p>
<figure data-type="image" tabindex="8"><img src="https://yuufen.com/blog/post-images/1583741581016.png" alt="" loading="lazy"></figure>
<p>图中左侧为 DOM 树，右侧是 Render 树，可以看到 Render 树结构与 DOM 树是非常相似的，但不是一一对应的。每一个节点是一个 Render Object，包含了我们在样式表中设置的样式，样式的宽高和具体位置是通过 Layout (重排)计算得出。</p>
<blockquote>
<h4 id="tips">Tips</h4>
<p>元素如果被设置为 <code>display:none</code>，在 DOM 树中依然会显示，但是在 Render 树中不会显示；元素如果被设置为 <code>visibility:none</code>，那么 DOM 树和 Render 树中都会显示；我们经常说的脱离⽂文档流，其实就是脱离 Render Tree。</p>
</blockquote>
<h3 id="白屏应对">白屏应对</h3>
<h4 id="骨架屏">骨架屏</h4>
<h5 id="自动化方案">自动化方案</h5>
<ul>
<li>page-skeleton-webpack-plugin</li>
<li>antd 的 skeleton 组件</li>
</ul>
<h3 id="dom-性能优化">DOM 性能优化</h3>
<p>少操作 dom，使用 fragment, 虚拟 dom</p>
<h3 id="回流重绘">回流重绘</h3>
<figure data-type="image" tabindex="9"><img src="https://yuufen.com/blog/post-images/1583741388259.png" alt="" loading="lazy"></figure>
<h3 id="event-loop">event-loop</h3>
<h4 id="流程-2">流程</h4>
<figure data-type="image" tabindex="10"><img src="https://yuufen.com/blog/post-images/1583742431195.png" alt="" loading="lazy"></figure>
<h4 id="macrotask宏任务-microtask微任务">Macrotask（宏任务） / Microtask（微任务）</h4>
<p>上面我们提到了任务队列，那么任务队列有两种，一种是 Macrotask，另外一种是 Microtask。从最开始我给出的 Event Loop 总的流程图，大家可以看出 Microtask 优先级是高于 Macrotask 的。Microtask 当中的任务也是在执行栈当中的任务执行完成后再进行执行，执行的时候和 Macrotask 有一些区别，Microtask 当中任务不会一个⼀一个压入执⾏行行栈，而是所有任务直接压入栈中， 当 Microtask 当中的任务执行完毕后，然后我们再从 Macrotask 中取栈顶的第一个任务进行执行。</p>
<p>那么哪些任务属于 Microtask，哪些任务属于 Macrotask 呢，这里有一个大概的总结：</p>
<ul>
<li><strong>Macrotask</strong>：</li>
</ul>
<p>setTimeout、setInterval、I/O、UI Rendering、script 当中的所有代码、 setImmediate(Node)</p>
<ul>
<li><strong>Microtask</strong>：</li>
</ul>
<p>process.nextTick(node) 、Promise 、MutationObserver</p>
<blockquote>
<p>Microtask 当中各种任务的优先级如下： process.nextTick &gt; Promise &gt; MutationOberse</p>
</blockquote>
<blockquote>
<p>批量更新，可以利用 event-loop，在当前数据修改之后，汇总数据，统一修改，如 React 的<code>setState</code></p>
</blockquote>
<h2 id="防抖节流">防抖节流</h2>
<h3 id="节流">节流</h3>
<pre><code class="language-js">function throttle(fn, wait = 500) {
  let lastTime = 0
  return function(...args) {
    let now = new Date()
    if (now - lastTime &gt; wait) {
      lastTime = now
      fn(...args)
    }
  }
}
window.onscroll = throttle(function() {
  console.log('懒加载判定、显示回到顶部判定……')
})
</code></pre>
<h3 id="防抖">防抖</h3>
<pre><code class="language-js">function debounce(fn, wait = 500) {
  let timer = 0
  return function(...arg) {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() =&gt; {
      fn(...arg)
    }, wait)
  }
}

window.onscroll = debounce(function() {
  console.log('懒加载判定、显示回到顶部判定……')
})
</code></pre>
<h2 id="懒加载">懒加载</h2>
<h3 id="图片懒加载">图片懒加载</h3>
<pre><code class="language-html">&lt;body&gt;
  &lt;div id=&quot;container&quot;&gt;
    &lt;div class=&quot;img-container&quot;&gt;
      &lt;img
        data-src=&quot;https://i0.hdslb.com/bfs/album/8e10328d8a35d3acb957bb521170711d02fdece8.jpg@518w_1e_1c.jpg&quot;
        alt=&quot;&quot;
      /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;img-container&quot;&gt;
      &lt;img data-src=&quot;https://i0.hdslb.com/bfs/album/3f9b4b9f8a91806c1daf2ab187f2faec8174d7ae.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;img-container&quot;&gt;
      &lt;img
        data-src=&quot;https://i0.hdslb.com/bfs/album/f14aec7ef14f0c95d359914e0927f9e1f1c3625b.png@518w_1e_1c.png&quot;
        alt=&quot;&quot;
      /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script&gt;
    const imgs = document.querySelectorAll('img')
    // 获取可视区域高度
    const viewHeight = window.innerHeight || window.documentElement.clientHeight
    console.log(viewHeight, imgs)
    num = 0
    function loadImg() {
      for (let i = 0; i &lt; imgs.length; i++) {
        console.log(imgs[i].getBoundingClientRect().top)
        let dis = viewHeight - imgs[i].getBoundingClientRect().top
        if (dis &gt; 0) {
          imgs[i].src = imgs[i].getAttribute('data-src')
          num = i + 1
        }
      }
    }
    loadImg()
    // 节流
    window.addEventListener(
      'scroll',
      (function(fn, wait = 500) {
        let lastTime = 0
        return function(...args) {
          let now = new Date()
          if (now - lastTime &gt; wait) {
            lastTime = now
            fn(...args)
          }
        }
      })(loadImg),
    )
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="组件路由懒加载">组件（路由）懒加载</h3>
<p>webpack</p>
<h2 id="服务端渲染-同构">服务端渲染 &amp;&amp; 同构</h2>
<ol>
<li>服务端渲染，就是在服务端解析首屏的组件，产出 HTML，直接返回</li>
<li>如果用户跳转页面，同构。整个应用有两个入口：
<ol>
<li>server-entry 首次进入的入口，使用 ssr</li>
<li>用户点击跳转，如果是单页应用，点击不刷新，走 js 单页入口，或者客户端渲染入口</li>
</ol>
</li>
</ol>
<h2 id="移动端优化">移动端优化</h2>
<p>svg、虚拟列表、300ms 延迟（禁用缩放解决）</p>
<p>https://bvaughn.github.io/react-virtualized/#/components/List</p>
<h3 id="vue">Vue</h3>
<p>async-component、v-if / v-show</p>
<h3 id="react">React</h3>
<p>purecomponent、suspense</p>
<h2 id="webpack">webpack</h2>
<ul>
<li>可视化优化</li>
</ul>
<pre><code class="language-js">const BundleAnalyzerPlugin = require('webpack-bundleanalyzer').BundleAnalyzerPlugin

module.exports = {
  plugins: [new BundleAnalyzerPlugin()],
}
</code></pre>
<ul>
<li>tree-shaking 删除冗余代码</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[仿照 Vue 实现简单的 MVVM 模式]]></title>
        <id>https://yuufen.com/blog/post/_IR3q9jGE/</id>
        <link href="https://yuufen.com/blog/post/_IR3q9jGE/">
        </link>
        <updated>2020-02-27T17:13:55.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/yuuFen/vue-reimplement">https://github.com/yuuFen/vue-reimplement</a></p>
<h2 id="vue-工作机制">Vue 工作机制</h2>
<p>在 <code>new Vue()</code> 时会调用 _init() 进行初始化，会初始化生命周期、事件、props、methods、data、computed 和 watch 等。其中最重要的是 <code>Object.defineProperty</code> 设置 <code>setter</code> 与 <code>getter</code> ，用来实现<strong>响应式</strong>以及<strong>依赖收集</strong>。</p>
<p>初始化后调用 <code>$mount</code> 挂载组件：</p>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1583512098725.png" alt="" loading="lazy"></figure>
<p>化简版：</p>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1583502362745.png" alt="" loading="lazy"></figure>
<h2 id="响应式">响应式</h2>
<h3 id="实现">实现</h3>
<pre><code class="language-js">class Vue {
  constructor(options) {
    this.$options = options

    this.$data = options.data

    // 响应化处理
    this.observe(this.$data)

    Object.keys(this.$data).forEach((key) =&gt; {
      // 只需要给 data 的第一层设置代理
      // 不然 set 多余的键时会给 data 添加属性
      this.proxyData(key)
    })
  }

  observe(value) {
    if (!value || typeof value !== 'object') {
      return
    }

    Object.keys(value).forEach((key) =&gt; {
      // setter 和 getter 使用中介 val，防止无限循环
      // 需要新建一个作用域（闭包）来保存 val,
      // Object.defineProperty(obj, key, { // val })
      this.defineReactive(value, key, value[key])
    })
  }

  defineReactive(obj, key, val) {
    // 递归，处理对象
    this.observe(val)

    // 会在 obj 上添加新属性，或者修改现有属性
    // 所以是个引用变量
    Object.defineProperty(obj, key, {
      get() {
        return val
      },
      set(newVal) {
        if (newVal !== val) {
          val = newVal
        }
      },
    })
  }

  // 在 Vue 实例根上定义属性转发至 data 中的数据
  proxyData(key) {
    // this 指 Vue 实例
    Object.defineProperty(this, key, {
      get() {
        return this.$data[key]
      },
      set(newVal) {
        this.$data[key] = newVal
      },
    })
  }
}
</code></pre>
<h3 id="测试">测试</h3>
<pre><code class="language-html">&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  const app = new Vue({
    data: {
      foo: 'foooooo',
      bar: {
        doo: 'dooooooo',
      },
    },
  })

  console.log(app.bar)
  app.bar = 'baaaar'
  console.log(app.bar)
&lt;/script&gt;
</code></pre>
<h2 id="依赖收集与追踪">依赖收集与追踪</h2>
<p>流程：</p>
<figure data-type="image" tabindex="3"><img src="https://yuufen.com/blog/post-images/1583577271564.png" alt="" loading="lazy"></figure>
<p>关系：</p>
<figure data-type="image" tabindex="4"><img src="https://yuufen.com/blog/post-images/1583579033936.png" alt="" loading="lazy"></figure>
<h3 id="案例">案例</h3>
<pre><code class="language-js">new Vue({
  template: `
    &lt;div&gt;
      &lt;span&gt;{{name1}}&lt;/span&gt;  
      &lt;span&gt;{{name2}}&lt;/span&gt;  
      &lt;span&gt;{{name1}}&lt;/span&gt;  
    &lt;/div&gt;
  `,
  data: {
    name1: 'name1',
    name2: 'name2',
    name3: 'name3',
  },
})
</code></pre>
<blockquote>
<p>修改 name1，视图更新，且要更新两处；</p>
<p>修改 name2，视图更新；</p>
<p>修改 name3，没有使用，视图不更新。</p>
<p>需要扫描视图收集依赖，知道视图中到底那些地方对数据有依赖。</p>
</blockquote>
<h3 id="实现-2">实现</h3>
<pre><code class="language-js">class Vue {
  constructor(options) {
    this.$options = options

    this.$data = options.data

    // 响应化处理
    this.observe(this.$data)

    Object.keys(this.$data).forEach((key) =&gt; {
      // 只需要给 data 的第一层设置代理
      // 不然 set 多余的键时会给 data 添加属性
      this.proxyData(key)
    })

    // 测试
    new Watcher(this, 'foo')
    new Watcher(this, 'bar.doo')
  }

  observe(value) {
    if (!value || typeof value !== 'object') {
      return
    }

    Object.keys(value).forEach((key) =&gt; {
      // setter 和 getter 使用中介 val，防止无限循环
      // 需要新建一个作用域（闭包）来保存 val,
      // Object.defineProperty(obj, key, { // val })
      this.defineReactive(value, key, value[key])
    })
  }

  defineReactive(obj, key, val) {
    // 递归，处理对象
    this.observe(val)

    const dep = new Dep()

    // 会在 obj 上添加新属性，或者修改现有属性，是个引用变量
    // 这里导致形成闭包
    Object.defineProperty(obj, key, {
      get() {
        // 若存在 targetWatcher（watcher的构造阶段），则添加
        Dep.targetWatcher &amp;&amp; dep.addWatcher(Dep.targetWatcher)
        return val
      },
      set(newVal) {
        if (newVal !== val) {
          val = newVal
          // 通知更新
          dep.notify()
        }
      },
    })
  }

  // 在 Vue 实例根上定义属性转发至 data 中的数据
  proxyData(key) {
    // this 指 Vue 实例
    Object.defineProperty(this, key, {
      get() {
        return this.$data[key]
      },
      set(newVal) {
        this.$data[key] = newVal
      },
    })
  }
}

// 创建 Dep: 管理所有的 Watcher
class Dep {
  constructor() {
    this.watchers = []
  }
  addWatcher(watcher) {
    this.watchers.push(watcher)
  }
  notify() {
    this.watchers.forEach((watcher) =&gt; {
      watcher.update()
    })
  }
}

// 创建 Watcher：与视图中的变量对应(出现一次就创建一个 Watcher 实例)
class Watcher {
  constructor(vm, key) {
    this.vm = vm
    this.key = key

    Dep.targetWatcher = this
    this.vm[this.key] // key解析出来之后为字符串， 但是若如 'bar.doo'，需要额外操作
    Dep.targetWatcher = null
  }
  update() {
    console.log(this.key, '更新——来自 watcher')
    // do something
  }
}
</code></pre>
<h2 id="编译-compile">编译 compile</h2>
<figure data-type="image" tabindex="5"><img src="https://yuufen.com/blog/post-images/1583580639945.png" alt="" loading="lazy"></figure>
<ol>
<li>获取并遍历 DOM 树</li>
<li>文本节点：获取 <code>{{}}</code> 格式的内容并解析</li>
<li>元素节点：访问节点特性，截获 <code>v-</code> 开头和 <code>@</code> 开头内容并解析</li>
</ol>
<h3 id="使用场景">使用场景</h3>
<pre><code>new Vue {
  el: '#app',
}
</code></pre>
<pre><code class="language-js">class Vue {
  constructor(options) {
    // ...
    new Compile(this, options.el)
  }
  // ...
}
</code></pre>
<h3 id="遍历节点">遍历节点</h3>
<pre><code class="language-js">class Compile {
  constructor(vm, el) {
    // new Watcher 需要 vm
    this.$vm = vm
    this.$el = document.querySelector(el)

    if (this.$el) {
      // 提取宿主中模板内容到 fragment 标签（结束后 $el 中没有子元素）
      // 不会引起页面回流（对元素位置和几何上的计算），性能更好
      this.$fragment = this.node2Fragment(this.$el)
      // 编译，并进行依赖收集
      this.compile(this.$fragment)
      // 编译结束后把 fragment 再添加到 el 中
      this.$el.appendChild(this.$fragment)
    }
  }

  node2Fragment(el) {
    const fragment = document.createDocumentFragment()
    let child
    while ((child = el.firstChild)) {
      fragment.appendChild(child)
    }
    return fragment
  }

  compile(el) {
    const childNodes = el.childNodes

    Array.from(childNodes).forEach((node) =&gt; {
      // 判断节点类型
      if (node.nodeType === 1) {
        // Element 节点
        console.log('遍历到节点', node.nodeName)
      } else if (this.isInterpolation(node)) {
        // 插值表达式
        console.log('遍历到插值表达式', node.textContent)
      }
      // 如果有子节点
      if (node.children &amp;&amp; node.childNodes.length &gt; 0) {
        this.compile(node)
      }
    })
  }

  isInterpolation(node) {
    // 是文本且符合{{...}}
    return node.nodeType === 3 &amp;&amp; /\{\{(.*)\}\}/.test(node.textContent)
  }
}
</code></pre>
<h3 id="插值表达式的响应式更新">插值表达式的响应式更新</h3>
<p>Compile：</p>
<pre><code class="language-js">  // ...
  // 遍历到插值表达式时
  compileText(node) {
    // console.log(RegExp.$1)
    const exp = RegExp.$1
    this.update(node, exp, 'text')
  }

  update(node, exp, dir) {
    const updater = this[dir + 'Updater']
    updater &amp;&amp; updater(node, exp)
    // 注意 this
    const get = this.getContent
    // 形成闭包，和一个 Watcher 实例对应
    new Watcher(
      this.$vm,
      // exp, // 在闭包中处理
      function() {
        get(exp)
      },
      function() {
        updater &amp;&amp; updater(node, exp)
      },
    )
  }

  // 注意 this
  textUpdater = (node, exp) =&gt; {
    node.textContent = this.getContent(exp)
  }

  // 注意 this
  getContent = (exp) =&gt; {
    // 解决嵌套，get 嵌套属性的值
    const p = exp.split('.')
    let content = this.$vm[p[0]]
    for (let i = 1; i &lt; p.length; i++) {
      content = content[p[i]]
    }
    return content
  }
}
</code></pre>
<p>Watcher：</p>
<pre><code class="language-js">// 初始化时再接受 get 和 updater，不再需要 key 和 vm
// 对应的 update(node, keys, dir) {...} 形成闭包

class Watcher {
  constructor(get, cb) {
    // this.vm = vm
    // this.key = key
    this.cb = cb

    this.get = get // 获取嵌套属性的方法

    Dep.targetWatcher = this
    // key解析出来之后为字符串， 但是若如 'bar.doo'，需要额外操作
    // 访问 bar.doo，会将它同时挂载到 bar 和 doo 的 Dep 实例（也是有必要的）
    // 这里直接在闭包中处理
    this.get()
    Dep.targetWatcher = null
  }
  update() {
    // 更新视图
    this.cb()
  }
}
</code></pre>
<blockquote>
<p>Watcher 实例对应的 update 形成闭包，存有 get、updater、node、exp。</p>
<p>也可以把 update 的相关内容直接放在 watcher 里面，更直观一点，但是 Watcher 太臃肿。</p>
</blockquote>
<pre><code class="language-js">class Watcher {
  constructor(vm, node, exp, dir) {
    this.vm = vm
    this.node = node
    this.exp = exp
    this.dir = dir

    this.updater = this[dir + 'Updater']

    Dep.targetWatcher = this
    this.getContent()
    Dep.targetWatcher = null

    this.updater()
  }
  update() {
    this.updater()
  }

  textUpdater() {
    this.node.textContent = this.getContent(this.exp)
  }

  // ...

  getContent() {
    // 解决嵌套，get 嵌套属性的值
    const p = this.exp.split('.')
    let content = this.vm[p[0]]
    for (let i = 1; i &lt; p.length; i++) {
      content = content[p[i]]
    }
    return content
  }
}
</code></pre>
<h3 id="元素属性的响应式">元素属性的响应式</h3>
<h4 id="v-text">v-text</h4>
<pre><code class="language-js">  compileElement(node) {
    const nodeAttrs = node.attributes
    Array.from(nodeAttrs).forEach((attr) =&gt; {
      const attrName = attr.name
      const exp = attr.value
      if (attrName.indexOf('v-') === 0) {
        const dir = attrName.substring(2)
        this[dir] &amp;&amp; this[dir](node, exp)
      }
    })
  }

  text(node, exp) {
    this.update(node, exp, 'text')
  }
</code></pre>
<h4 id="v-html">v-html</h4>
<p>和 text 一样，把 node.textContent 改为 node.innerHTML</p>
<h4 id="v-model">v-model</h4>
<p>修改 node.value，监听 node 的 input 事件</p>
<p>新建 set 方法，解决嵌套属性的 set 问题</p>
<pre><code class="language-js">setContent = (exp, value) =&gt; {
  const p = exp.split('.')
  if (p.length === 1) {
    this.$vm[p] = value
  } else if (p.length &gt; 1) {
    let content = this.$vm[p[0]]
    for (let i = 1; i &lt; p.length - 1; i++) {
      content = content[p[i]]
    }
    content[p[p.length - 1]] = value
  }
}
</code></pre>
<h4 id="事件绑定">@ 事件绑定</h4>
<pre><code>@click=&quot;handleClick&quot;
</code></pre>
<p>获取到 click、handleClick，绑定到 node 上，注意 this。</p>
<h2 id="汇总">汇总</h2>
<h3 id="compilejs">compile.js</h3>
<pre><code class="language-js">class Compile {
  constructor(vm) {
    // new Watcher 需要 vm
    this.$vm = vm
    this.$el = document.querySelector(this.$vm.$options.el)

    if (this.$el) {
      // 提取宿主中模板内容到 fragment 标签（结束后 $el 中没有子元素）
      // 不会引起页面回流（对元素位置和几何上的计算），性能更好
      this.$fragment = this.node2Fragment(this.$el)
      // 编译，并进行依赖收集
      this.compile(this.$fragment)
      // 编译结束后把 fragment 再添加到 el 中
      this.$el.appendChild(this.$fragment)
    }
  }

  node2Fragment(el) {
    const fragment = document.createDocumentFragment()
    let child
    while ((child = el.firstChild)) {
      fragment.appendChild(child)
    }
    return fragment
  }

  compile(el) {
    const childNodes = el.childNodes

    Array.from(childNodes).forEach((node) =&gt; {
      // 判断节点类型
      if (node.nodeType === 1) {
        // Element 节点
        console.log('遍历到节点', node.nodeName)
        this.compileElement(node)
      } else if (this.isInterpolation(node)) {
        // 插值表达式
        console.log('遍历到插值表达式', node.textContent)
        this.compileText(node)
      }
      // 如果有子节点
      if (node.children &amp;&amp; node.childNodes.length &gt; 0) {
        this.compile(node)
      }
    })
  }

  isInterpolation(node) {
    // 是文本且符合{{...}}
    return node.nodeType === 3 &amp;&amp; /\{\{(.*)\}\}/.test(node.textContent)
  }

  compileText(node) {
    // console.log(RegExp.$1)
    const exp = RegExp.$1
    this.update(this.$vm, node, exp, 'text')
  }

  update(vm, node, exp, dir) {
    const updater = this[dir + 'Updater']
    // 也可以把 updater 的实现直接放在 watcher 里面
    // 就不用形成闭包，但是这样 watcher 就太臃肿了。
    updater &amp;&amp; updater(node, exp)
    // 注意 this
    const get = this.getContent
    // 形成闭包，和一个 Watcher 实例对应
    new Watcher(
      // vm, // 在这里处理
      // exp, // 在这里处理
      function() {
        get(exp)
      },
      function() {
        updater &amp;&amp; updater(node, exp)
      },
    )
  }

  // 注意 this
  textUpdater = (node, exp) =&gt; {
    node.textContent = this.getContent(exp)
  }
  htmlUpdater = (node, exp) =&gt; {
    node.innerHTML = this.getContent(exp)
  }
  modelUpdater = (node, exp) =&gt; {
    node.value = this.getContent(exp)
  }

  // 注意 this
  getContent = (exp) =&gt; {
    // 解决嵌套，get 嵌套属性的值
    const p = exp.split('.')
    let content = this.$vm[p[0]]
    for (let i = 1; i &lt; p.length; i++) {
      content = content[p[i]]
    }
    return content
  }
  setContent = (exp, value) =&gt; {
    const p = exp.split('.')
    if (p.length === 1) {
      this.$vm[p] = value
    } else if (p.length &gt; 1) {
      let content = this.$vm[p[0]]
      for (let i = 1; i &lt; p.length - 1; i++) {
        content = content[p[i]]
      }
      content[p[p.length - 1]] = value
    }
  }

  compileElement(node) {
    const nodeAttrs = node.attributes
    Array.from(nodeAttrs).forEach((attr) =&gt; {
      const attrName = attr.name
      const exp = attr.value
      if (attrName.indexOf('v-') === 0) {
        const dir = attrName.substring(2)
        this[dir] &amp;&amp; this[dir](this.$vm, node, exp)
      } else if (attrName.indexOf('@') === 0) {
        // @click=&quot;handleClick&quot;
        const dir = attrName.substring(1)
        this.eventHandler(this.$vm, node, exp, dir)
      }
    })
  }

  text(vm, node, exp) {
    this.update(vm, node, exp, 'text')
  }

  html(vm, node, exp) {
    this.update(vm, node, exp, 'html')
  }

  model(vm, node, exp) {
    this.update(vm, node, exp, 'model')
    node.addEventListener('input', (e) =&gt; {
      this.setContent(exp, e.target.value)
    })
  }

  eventHandler(vm, node, exp, dir) {
    const fn = vm.$options.methods &amp;&amp; vm.$options.methods[exp]
    // console.log(node, exp, dir, fn)
    if (dir &amp;&amp; fn) {
      // 注意 this
      node.addEventListener(dir, fn.bind(vm))
    }
  }
}
</code></pre>
<h3 id="vuejs">vue.js</h3>
<pre><code class="language-js">class Vue {
  constructor(options) {
    this.$options = options

    this.$data = options.data

    // 响应化处理
    this.observe(this.$data)

    Object.keys(this.$data).forEach((key) =&gt; {
      // 只需要给 data 的第一层设置代理
      // 不然 set 多余的键时会给 data 添加属性
      this.proxyData(key)
    })

    // new Watcher(this, 'foo')
    // new Watcher(this, 'bar.doo')

    new Compile(this)
  }

  observe(value) {
    if (!value || typeof value !== 'object') {
      return
    }

    Object.keys(value).forEach((key) =&gt; {
      // setter 和 getter 使用中介 val，防止无限循环
      // 需要新建一个作用域（闭包）来保存 val,
      // Object.defineProperty(obj, key, { // val })
      this.defineReactive(value, key, value[key])
    })
  }

  defineReactive(obj, key, val) {
    // 递归，处理对象
    this.observe(val)

    const dep = new Dep()

    // 会在 obj 上添加新属性，或者修改现有属性，是个引用变量
    // 这里导致形成闭包
    Object.defineProperty(obj, key, {
      get() {
        // 若存在 targetWatcher（watcher的构造阶段），则添加
        Dep.targetWatcher &amp;&amp; dep.addWatcher(Dep.targetWatcher)
        // console.log('get');
        return val
      },
      set(newVal) {
        if (newVal !== val) {
          // console.log('set');
          val = newVal
          // 通知更新
          dep.notify()
        }
      },
    })
  }

  // 在 Vue 实例根上定义属性转发至 data 中的数据
  proxyData(key) {
    // this 指 Vue 实例
    Object.defineProperty(this, key, {
      get() {
        return this.$data[key]
      },
      set(newVal) {
        this.$data[key] = newVal
      },
    })
  }
}

// 创建 Dep: 管理所有的 Watcher
class Dep {
  constructor() {
    this.watchers = []
  }
  addWatcher(watcher) {
    this.watchers.push(watcher)
  }
  notify() {
    this.watchers.forEach((watcher) =&gt; {
      watcher.update()
    })
  }
}

// 创建 Watcher：与视图中的变量对应(出现一次就创建一个 Watcher 实例)
class Watcher {
  constructor(get, cb) {
    // this.vm = vm
    // this.key = key
    this.cb = cb

    this.get = get // 获取嵌套属性的方法

    Dep.targetWatcher = this
    // key解析出来之后为字符串， 但是若如 'bar.doo'，需要额外操作
    // 访问 bar.doo，会将它同时挂载到 bar 和 doo 的 Dep 实例（也是有必要的）
    // 这里直接在闭包中处理
    this.get()
    Dep.targetWatcher = null
  }
  update() {
    // 更新视图
    this.cb()
  }
}
</code></pre>
<h3 id="indexhtml">index.html</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
      &lt;p&gt;{{name}}&lt;/p&gt;
      &lt;p v-text=&quot;name&quot;&gt;&lt;/p&gt;
      &lt;p&gt;{{age}}&lt;/p&gt;
      &lt;p&gt;{{doubleAge}}&lt;/p&gt;
      &lt;p&gt;{{bar}}&lt;/p&gt;
      &lt;p&gt;{{bar.doo}}&lt;/p&gt;
      &lt;div&gt;{{}}&lt;/div&gt;
      &lt;input type=&quot;text&quot; v-model=&quot;name&quot; /&gt; &lt;button @click=&quot;changeName&quot;&gt;修改name&lt;/button&gt;
      &lt;input type=&quot;text&quot; v-model=&quot;bar.doo&quot; /&gt; &lt;button @click=&quot;changeDoo&quot;&gt;修改doo&lt;/button&gt;
      &lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;

    &lt;script src=&quot;compile.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      const app = new Vue({
        el: '#app',
        data: {
          name: 'I am test.',
          age: 12,
          html: '&lt;button&gt;html测试&lt;/button&gt;',
          foo: 'foooooo',
          bar: {
            doo: '嵌套属性',
          },
        },
        methods: {
          changeName() {
            // console.log('执行了吗')
            // 注意 this
            this.name = '调用了methods'
          },
          changeDoo() {
            this.bar.doo = '调用了methods'
          },
        },
      })

      setTimeout(() =&gt; {
        app.name = '666666666666'
        app.bar.doo = 'oooo'
        // console.log(app.bar.doo)
        // app.bar = 'oooo'
      }, 1000)

      // console.log(app['bar.doo'])
      // app.foo = 'ffff'
      // console.log(app.bar)
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见设计模式总结]]></title>
        <id>https://yuufen.com/blog/post/_lKjmwEdd/</id>
        <link href="https://yuufen.com/blog/post/_lKjmwEdd/">
        </link>
        <updated>2020-02-27T06:51:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="从输入-url-到显示页面发生了什么">从输入 url 到显示页面，发生了什么？</h2>
<p><strong>从输入 url 到显示页面，发生了什么？</strong></p>
<ol>
<li>用户输入 yuufen.com</li>
<li>浏览器通过 DNS，把 url 解析为 IP</li>
<li>和 IP 地址建立 TCP 连接，发送 HTTP 请求</li>
<li>服务器接收请求，查库，读文件等，拼接好返回的 HTTP 响应</li>
<li>浏览器收到首屏 html，开始渲染</li>
<li>解析 html 为 dom（同时加载额外的 css 和 js）</li>
<li>解析 css 为 css-tree（CSS 选择器从<strong>右</strong>向左过滤查找）</li>
<li>dom + css 生成 render-tree，绘图</li>
</ol>
<p>这是一个万能的面试题，这个题的答案包含着整个互联网运行的过程，我们性能优化的策略就是基于它的答案，针对每一步依次解析，让整体的时间变短。所以有两个大方向：</p>
<ol>
<li>少加载文件</li>
<li>少执行代码</li>
</ol>
<h2 id="雅虎军规">雅虎军规</h2>
<blockquote>
<p>虽然随着 Vue、React、Angular 这些框架的流行，雅虎军规当中一些优化的方法已不在适用，但是，更多的时候，我们是学习这些方法背后的思想，而不是去死记硬背某个方法，技术总是在更迭，只有握方法背后的思想，才能够立于不败之地。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1583615829278.jpg" alt="" loading="lazy"></figure>
<p>https://developer.yahoo.com/performance/rules.html</p>
<p>https://juejin.im/post/5b73ef38f265da281e048e51</p>
<h2 id="性能指标">性能指标</h2>
<blockquote>
<p>抛开场景谈性能优化，都是耍流氓</p>
</blockquote>
<h3 id="performance-api">Performance API</h3>
<p>提到性能优化指标就不得不说 Performance API，首先来看 MDN 上关于这个 API 的 介绍：Performance 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API。该类型的对象可以通过调⽤用只读属性 Window.performance 来获得。</p>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1583740522448.png" alt="" loading="lazy"></figure>
<pre><code class="language-js">const timingInfo = window.performance.timing
console.log({
  TCP连接耗时: timingInfo.connectEnd - timingInfo.connectStart,
  DNS查询耗时: timingInfo.domainLookupEnd - timingInfo.domainLookupStart,
  '获得首字节耗费时间，也叫TTFB': timingInfo.responseStart - timingInfo.navigationStart,
  domReady时间: timingInfo.domContentLoadedEventStart - timingInfo.navigationStart,
  DOM资源下载: timingInfo.responseEnd - timingInfo.responseStart,
})
</code></pre>
<ol>
<li>First Paint(简称 FP)：表示文档中任一元素首次渲染时间。</li>
<li>First Contentful Paint(简称 FCP)：当浏览器首次渲染任何文本，图像（包括背景图像），非白色画布或 SVG 时。这个指标就是我们日常说的白屏时间。</li>
<li>First Meaningful Paint(简称 FMP)：首次有意义的绘制，这个指标反映的是主要内容出现在页面上所需要的时间，如果 FMP 时间过长的话，这里就要考虑是不是静态文件阻塞了主线程。</li>
<li>Time To Interactive(TTI)：可交互时间，等到服务器通过 HTTP 协议将响应全部返回之后，便开始 DOM Tree 的构建，完成之后，网页变成可交互状态，到此为止便是网页的可交互时间。用户可以进行正常的事件输入交互操作，这个指标是最重要的用户体验指标，用户最关心的就是什么时候可以进行交互，所以通常这个指标是我们优化的重点。</li>
</ol>
<h3 id="浏览器-performance-工具">浏览器 Performance 工具</h3>
<h3 id="lighthouse">Lighthouse</h3>
<ul>
<li>安装 chrome 插件 （或者）</li>
<li><code>npm install -g lighthouse</code></li>
</ul>
<pre><code>lighthouse https://yuufen.com/
</code></pre>
<h2 id="网络">网络</h2>
<h3 id="dns">DNS</h3>
<p>prefetch</p>
<figure data-type="image" tabindex="3"><img src="https://yuufen.com/blog/post-images/1583617452917.png" alt="" loading="lazy"></figure>
<h3 id="tcp">TCP</h3>
<h4 id="ip-tcp-http-的关系">IP、TCP、HTTP 的关系</h4>
<ol>
<li>
<p>IP-门牌号，通过 IP 协议找到对应机器</p>
</li>
<li>
<p>TCP 负责数据完整性和有序性，通过三次握手、粘包、滑动窗口等非常庞大的网络协议机制</p>
</li>
<li>
<p>HTTP 负责应用层数据，文件编码、cookie、缓存、数据终止时机等</p>
</li>
</ol>
<h4 id="优化tcp策略">优化（TCP）策略</h4>
<ol>
<li>长连接</li>
<li>减少文件体积
<ol>
<li>js 打包压缩</li>
<li>图片压缩</li>
<li>gzip</li>
</ol>
</li>
<li>减少文件请求次数
<ol>
<li>雪碧图</li>
<li>js、css 打包</li>
<li>缓存控制</li>
<li>懒加载</li>
</ol>
</li>
<li>减少用户和服务器的举例
<ol>
<li>cdn</li>
</ol>
</li>
<li>本地储存</li>
</ol>
<h2 id="图片">图片</h2>
<h3 id="选择合适格式">选择合适格式</h3>
<ol>
<li>PNG</li>
</ol>
<p>png-8 png-24 png-32</p>
<p>logo，颜色简单但对图片质量要求高、精灵图</p>
<ol start="2">
<li>
<p>JPG/JPEG</p>
</li>
<li>
<p>GIF</p>
</li>
<li>
<p>SVG</p>
</li>
</ol>
<p>SVG 图像中的文本时可选取可搜索的。</p>
<p>常用来绘制地图、股票 k 线图</p>
<p>会损耗性能</p>
<ol start="5">
<li>WebP</li>
</ol>
<p>全能的解决方案，但是兼容性不好，需要根据浏览器判断加载格式</p>
<ol start="6">
<li>Base64</li>
</ol>
<p>图片 base64 之后会变大，适合小的矢量图标</p>
<h3 id="其他">其他</h3>
<ol>
<li>图片渐进显示</li>
<li>懒加载</li>
<li>骨架图</li>
</ol>
<h2 id="缓存">缓存</h2>
<p>可以少加载文件</p>
<ol>
<li>cdn 缓存</li>
<li>本地缓存
<ol>
<li>localstorage</li>
<li>indexdb</li>
<li>cookie</li>
</ol>
</li>
<li>浏览器缓存</li>
</ol>
<h3 id="cdn">CDN</h3>
<p>缓存+回源</p>
<p>地理位置更近，新的域名规避 cookie</p>
<h3 id="浏览器缓存">浏览器缓存</h3>
<figure data-type="image" tabindex="4"><img src="https://yuufen.com/blog/post-images/1583741167549.png" alt="" loading="lazy"></figure>
<h4 id="流程">流程</h4>
<ol>
<li>获取文件</li>
<li>文件返回 express 或者 cache-control 设置过期时间，并且带上 etag 或者 lastModfied 字段</li>
<li>再次请求，浏览器先查询 expres 或者 cache-control 是否过期，若没过期，强缓存生效，不发出网络请求，直接使用缓存</li>
<li>若强缓存失效，浏览器会带上 etag 或者 lastModfied 数据，使用 if-none-match 或者 if-Modified-Since 字段，咨询后端是否过期</li>
<li>若没过期，返回 304 状态码，直接用缓存</li>
<li>若过期，状态码 200，返回新资源</li>
</ol>
<h4 id="强缓存">强缓存</h4>
<h5 id="expires">expires</h5>
<p>http 1.0 中</p>
<h5 id="cache-control">Cache-Control</h5>
<p>http 1.1 中</p>
<h4 id="协商缓存">协商缓存</h4>
<h5 id="last-modified-if-modified-since">Last-Modified / If-Modified-Since</h5>
<p>标注时间（只能精确到秒）</p>
<h5 id="etag-if-none-match">Etag / If-None-Match</h5>
<p>根据文件内容计算 hash</p>
<h3 id="webpack-打包和缓存的关系">webpack 打包和缓存的关系</h3>
<p>通过 hash 来判断是否有更新：</p>
<ol>
<li>hash：整个项目相关的 hash</li>
<li>chunkhash：入口文件依赖的 chunkhash</li>
<li>contenthash：文件内容的 hash</li>
</ol>
<h3 id="其他-2">其他</h3>
<ol>
<li>memory cache 内存缓存，比如储存在变量里，关闭 tab 就没了</li>
<li>Disk cache 硬盘上的缓存</li>
<li>Push cache 推送缓存 http2</li>
<li>service worker 浏览器背后的独立进程</li>
</ol>
<h2 id="渲染">渲染</h2>
<h3 id="浏览器渲染原理">浏览器渲染原理</h3>
<p>经典文章 how browser works</p>
<p>https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</p>
<figure data-type="image" tabindex="5"><img src="https://yuufen.com/blog/post-images/1583741367851.png" alt="" loading="lazy"></figure>
<p>首先是解析 HTML。这个过程主要是把 HTML 文档解析为 DOM 树的过程，如果遇到&lt;script&gt;标签，则会停止解析，先执行标签当中的 JavaScript；如果是外联方式，也需要等待下载并执行完对应的 JavaScript 代码，然后才能继续执行解析 HTML 的工作。HTML 解析完成后触发 DOMContentLoaded 事件，这里我们就可以操作 DOM 了。</p>
<p>生成对应的 DOM 树结构：</p>
<figure data-type="image" tabindex="6"><img src="https://yuufen.com/blog/post-images/1583741376936.png" alt="" loading="lazy"></figure>
<p>同时会解析 CSS。解析 HTML 和解析 CSS 是并行处理的，不然会造成渲染的内容没有对应的样式。解析 CSS 遇到&lt;script&gt;标签和上面解析 HTML 的处理方式是一样的。CSS 解析器将 CSS 解析成 CSSStyleSheet（也被叫做 CSSOM 树），和 DOM 树结构类似。</p>
<p>CSSOM 树：</p>
<figure data-type="image" tabindex="7"><img src="https://yuufen.com/blog/post-images/1583741498395.png" alt="" loading="lazy"></figure>
<p>DOM 树和 CSSOM 树一起附着合成渲染树（Render Tree）：</p>
<figure data-type="image" tabindex="8"><img src="https://yuufen.com/blog/post-images/1583741581016.png" alt="" loading="lazy"></figure>
<p>图中左侧为 DOM 树，右侧是 Render 树，可以看到 Render 树结构与 DOM 树是非常相似的，但不是一一对应的。每一个节点是一个 Render Object，包含了我们在样式表中设置的样式，样式的宽高和具体位置是通过 Layout (重排)计算得出。</p>
<blockquote>
<h4 id="tips">Tips</h4>
<p>元素如果被设置为 <code>display:none</code>，在 DOM 树中依然会显示，但是在 Render 树中不会显示；元素如果被设置为 <code>visibility:none</code>，那么 DOM 树和 Render 树中都会显示；我们经常说的脱离⽂文档流，其实就是脱离 Render Tree。</p>
</blockquote>
<h3 id="白屏应对">白屏应对</h3>
<h4 id="骨架屏">骨架屏</h4>
<h5 id="自动化方案">自动化方案</h5>
<ul>
<li>page-skeleton-webpack-plugin</li>
<li>antd 的 skeleton 组件</li>
</ul>
<h3 id="dom-性能优化">DOM 性能优化</h3>
<p>少操作 dom，使用 fragment, 虚拟 dom</p>
<h3 id="回流重绘">回流重绘</h3>
<figure data-type="image" tabindex="9"><img src="https://yuufen.com/blog/post-images/1583741388259.png" alt="" loading="lazy"></figure>
<h3 id="event-loop">event-loop</h3>
<h4 id="流程-2">流程</h4>
<figure data-type="image" tabindex="10"><img src="https://yuufen.com/blog/post-images/1583742431195.png" alt="" loading="lazy"></figure>
<h4 id="macrotask宏任务-microtask微任务">Macrotask（宏任务） / Microtask（微任务）</h4>
<p>上面我们提到了任务队列，那么任务队列有两种，一种是 Macrotask，另外一种是 Microtask。从最开始我给出的 Event Loop 总的流程图，大家可以看出 Microtask 优先级是高于 Macrotask 的。Microtask 当中的任务也是在执行栈当中的任务执行完成后再进行执行，执行的时候和 Macrotask 有一些区别，Microtask 当中任务不会一个⼀一个压入执⾏行行栈，而是所有任务直接压入栈中， 当 Microtask 当中的任务执行完毕后，然后我们再从 Macrotask 中取栈顶的第一个任务进行执行。</p>
<p>那么哪些任务属于 Microtask，哪些任务属于 Macrotask 呢，这里有一个大概的总结：</p>
<ul>
<li><strong>Macrotask</strong>：</li>
</ul>
<p>setTimeout、setInterval、I/O、UI Rendering、script 当中的所有代码、 setImmediate(Node)</p>
<ul>
<li><strong>Microtask</strong>：</li>
</ul>
<p>process.nextTick(node) 、Promise 、MutationObserver</p>
<blockquote>
<p>Microtask 当中各种任务的优先级如下： process.nextTick &gt; Promise &gt; MutationOberse</p>
</blockquote>
<blockquote>
<p>批量更新，可以利用 event-loop，在当前数据修改之后，汇总数据，统一修改，如 React 的<code>setState</code></p>
</blockquote>
<h2 id="防抖节流">防抖节流</h2>
<h3 id="节流">节流</h3>
<pre><code class="language-js">function throttle(fn, wait = 500) {
  let lastTime = 0
  return function(...args) {
    let now = new Date()
    if (now - lastTime &gt; wait) {
      lastTime = now
      fn(...args)
    }
  }
}
window.onscroll = throttle(function() {
  console.log('懒加载判定、显示回到顶部判定……')
})
</code></pre>
<h3 id="防抖">防抖</h3>
<pre><code class="language-js">function debounce(fn, wait = 500) {
  let timer = 0
  return function(...arg) {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() =&gt; {
      fn(...arg)
    }, wait)
  }
}

window.onscroll = debounce(function() {
  console.log('懒加载判定、显示回到顶部判定……')
})
</code></pre>
<h2 id="懒加载">懒加载</h2>
<h3 id="图片懒加载">图片懒加载</h3>
<pre><code class="language-html">&lt;body&gt;
  &lt;div id=&quot;container&quot;&gt;
    &lt;div class=&quot;img-container&quot;&gt;
      &lt;img
        data-src=&quot;https://i0.hdslb.com/bfs/album/8e10328d8a35d3acb957bb521170711d02fdece8.jpg@518w_1e_1c.jpg&quot;
        alt=&quot;&quot;
      /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;img-container&quot;&gt;
      &lt;img data-src=&quot;https://i0.hdslb.com/bfs/album/3f9b4b9f8a91806c1daf2ab187f2faec8174d7ae.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;img-container&quot;&gt;
      &lt;img
        data-src=&quot;https://i0.hdslb.com/bfs/album/f14aec7ef14f0c95d359914e0927f9e1f1c3625b.png@518w_1e_1c.png&quot;
        alt=&quot;&quot;
      /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script&gt;
    const imgs = document.querySelectorAll('img')
    // 获取可视区域高度
    const viewHeight = window.innerHeight || window.documentElement.clientHeight
    console.log(viewHeight, imgs)
    num = 0
    function loadImg() {
      for (let i = 0; i &lt; imgs.length; i++) {
        console.log(imgs[i].getBoundingClientRect().top)
        let dis = viewHeight - imgs[i].getBoundingClientRect().top
        if (dis &gt; 0) {
          imgs[i].src = imgs[i].getAttribute('data-src')
          num = i + 1
        }
      }
    }
    loadImg()
    // 节流
    window.addEventListener(
      'scroll',
      (function(fn, wait = 500) {
        let lastTime = 0
        return function(...args) {
          let now = new Date()
          if (now - lastTime &gt; wait) {
            lastTime = now
            fn(...args)
          }
        }
      })(loadImg),
    )
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="组件路由懒加载">组件（路由）懒加载</h3>
<p>webpack</p>
<h2 id="服务端渲染-同构">服务端渲染 &amp;&amp; 同构</h2>
<ol>
<li>服务端渲染，就是在服务端解析首屏的组件，产出 HTML，直接返回</li>
<li>如果用户跳转页面，同构。整个应用有两个入口：
<ol>
<li>server-entry 首次进入的入口，使用 ssr</li>
<li>用户点击跳转，如果是单页应用，点击不刷新，走 js 单页入口，或者客户端渲染入口</li>
</ol>
</li>
</ol>
<h2 id="移动端优化">移动端优化</h2>
<p>svg、虚拟列表、300ms 延迟（禁用缩放解决）</p>
<p>https://bvaughn.github.io/react-virtualized/#/components/List</p>
<h3 id="vue">Vue</h3>
<p>async-component、v-if / v-show</p>
<h3 id="react">React</h3>
<p>purecomponent、suspense</p>
<h2 id="webpack">webpack</h2>
<ul>
<li>可视化优化</li>
</ul>
<pre><code class="language-js">const BundleAnalyzerPlugin = require('webpack-bundleanalyzer').BundleAnalyzerPlugin

module.exports = {
  plugins: [new BundleAnalyzerPlugin()],
}
</code></pre>
<ul>
<li>tree-shaking 删除冗余代码</li>
</ul>
<h2 id="prepack">Prepack</h2>
<p>在编译阶段做预计算</p>
<p><a href="prepack.io">prepack.io</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vuex 总结与简单实现]]></title>
        <id>https://yuufen.com/blog/post/pgLxFgJc5/</id>
        <link href="https://yuufen.com/blog/post/pgLxFgJc5/">
        </link>
        <updated>2020-02-26T06:28:50.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1583426923830.png" alt="" loading="lazy"></figure>
<p><a href="https://github.com/yuuFen/vuex-reimplement">https://github.com/yuuFen/vuex-reimplement</a></p>
<h2 id="基础总结">基础总结</h2>
<h3 id="是什么">是什么</h3>
<p>Vuex 是一个专为 Vue.js 应用开发的<strong>状态管理模式</strong>，集中式存储管理应⽤所有组件的状态。</p>
<p>Vuex遵循“单向数据流”理念，易于问题追踪以及提高代码可维护性。</p>
<p>Vue中多个视图依赖于同一状态时，视图间传参和状态同步比较困难，Vuex能够很好解决该问题。</p>
<h3 id="核心概念">核心概念</h3>
<ul>
<li>state 状态、数据</li>
<li>getters 派生状态 ，从state派生出新状态，类似计算属性</li>
<li>mutations 更改状态的函数</li>
<li>actions 异步操作 ，复杂业务逻辑，类似于controller</li>
<li>store 包含以上概念的容器</li>
</ul>
<h3 id="使用">使用</h3>
<h4 id="普通使用">普通使用</h4>
<pre><code class="language-js">// store
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    count: 0,
  },
  mutations: {
    add(state, num = 1) {
      state.count += num
    },
  },
  getters: {
    // 类似于 computer
    score(state) {
      return 'score: ' + state.count * 2
    },
  },
  actions: {
    // 复杂业务逻辑，类似于 controller
    // 如 ajax 请求、同时调用多次 commit
    asyncAdd({ commit }, num) {
      return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
          commit('add', num)
          resolve({ ok: 1 })
        }, 1000)
      })
    },
  },
  modules: {},
})
</code></pre>
<pre><code class="language-js">// vue
  &lt;h3&gt;{{ $store.state.count }}&lt;/h3&gt;
  &lt;h3&gt;{{ $store.getters.score }}&lt;/h3&gt;

  methods: {
    add() {
      this.$store.commit('add')
    },
    asyncAdd() {
      this.$store.dispatch('asyncAdd').then((res) =&gt; {
        if (res.ok === 1) {
          alert('ok')
        }
      })
    },
</code></pre>
<h4 id="模块化">模块化</h4>
<p>/store/count.js</p>
<pre><code class="language-js">export default {
  namespaced: true, // 单独的命名空间
  state: {
    count: 0,
  },
  mutations: {
    add(state, num = 1) {
      state.count += num
    },
  },
  getters: {
    score(state) {
      return 'score: ' + state.count * 2
    },
  },
  actions: {
    asyncAdd({ commit }, num) {
      return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
          commit('add', num)
          resolve({ ok: 1 })
        }, 1000)
      })
    },
  },
}
</code></pre>
<p>/store/index.js</p>
<pre><code class="language-js">import Vue from 'vue'
import Vuex from 'vuex'
import count from './count'

Vue.use(Vuex)

export default new Vuex.Store({
  modules: {
    c: count,
  },
})
</code></pre>
<p>vue</p>
<pre><code class="language-js">    &lt;h3&gt;{{ $store.state.c.count }}&lt;/h3&gt;
    &lt;h3&gt;{{ $store.getters['c/score'] }}&lt;/h3&gt;
    
  methods: {
    add() {
      this.$store.commit('c/add')
    },
    asyncAdd() {
      this.$store.dispatch('c/asyncAdd').then((res) =&gt; {
        if (res.ok === 1) {
          alert('ok')
        }
      })
    },
  },
</code></pre>
<h2 id="浅析源码">浅析源码</h2>
<h3 id="目标">目标</h3>
<ol>
<li>维护状态 state （响应式）</li>
<li>修改状态 commit</li>
<li>业务逻辑控制 dispatch</li>
<li>状态派发 getter（响应式）</li>
<li>混入</li>
</ol>
<h3 id="实现">实现</h3>
<pre><code class="language-js">let Vue

function install(_Vue) {
  Vue = _Vue

  Vue.mixin({
    beforeCreate() {
      if (this.$options.store) {
        Vue.prototype.$store = this.$options.store
      }
    },
  })
}

class Store {
  constructor(options) {
    this.state = new Vue({
      data: options.state,
    })

    this.mutations = options.mutations || {}
    this.actions = options.actions || {}

    options.getters &amp;&amp; this.handleGetters(options.getters)
  }

  commit = (type, arg) =&gt; {
    // 如果不使用箭头函数，dispatch 中调用时 this 会改变
    // console.log(this)
    const fn = this.mutations[type]
    fn(this.state, arg)
  }

  dispatch(type, arg) {
    const fn = this.actions[type]
    return fn({ commit: this.commit, state: this.state }, arg)
  }

  // {foo(state){},doo(state){}}
  handleGetters(getters) {
    this.getters = {}

    // 定义只读属性和响应式
    Object.keys(getters).forEach((key) =&gt; {
      Object.defineProperty(this.getters, key, {
        get: () =&gt; {
          return getters[key](this.state)
        },
      })
    })
  }
}

export default { Store, install }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-router 扩展 API 与简单实现]]></title>
        <id>https://yuufen.com/blog/post/8pW7fVIsz/</id>
        <link href="https://yuufen.com/blog/post/8pW7fVIsz/">
        </link>
        <updated>2020-02-24T08:30:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>原版实现更更更更值得学习</p>
<p><a href="https://github.com/vuejs/vue-router">vue-router</a></p>
<p><a href="https://github.com/vuejs/vue-router/blob/dev/src/components/view.js">router-view</a></p>
</blockquote>
<h2 id="扩展">扩展</h2>
<h3 id="懒加载">懒加载</h3>
<pre><code class="language-js">      // 路由层级代码分割，生成分片(about.[hash].js)      
      // 当路由访问时会懒加载.      
      component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ './views/About.vue')
</code></pre>
<h3 id="路由守卫">路由守卫</h3>
<p>全局守卫</p>
<p>路由独享守卫</p>
<p>组件内守卫</p>
<h3 id="动态路由">动态路由</h3>
<p>利用$router.addRoutes()可以实现动态路由添加，常用于用户权限控制。</p>
<pre><code class="language-js">// router.js
// 接口返回数据可能是这样的
// [{
//   path: &quot;/&quot;,
//   name: &quot;home&quot;,
//   component: &quot;Home&quot;, //Home
// }]

// 异步获取路路由
api.getRoutes().then((routes) =&gt; {
  const routeConfig = routes.map((route) =&gt; mapComponent(route))
  router.addRoutes(routeConfig)
})

// 映射关系
const compMap = {
  Home: () =&gt; import('./view/Home.vue'),
}

// 递归替换
function mapComponent(route) {
  route.component = compMap[route.component]
  if (route.children) {
    route.children = route.children.map((child) =&gt; mapComponent(child))
  }
  return route
}
</code></pre>
<h3 id="面包屑">面包屑</h3>
<p>利用$route.matched可得到路由匹配数组，按顺序解析可得路由层次关系。</p>
<pre><code class="language-js">// Breadcrumb.vue
watch: {
  $route: {
    handler(route) {
      // [{name:'home',path:'/'},{name:'list',path:'/list'}]
      console.log(this.$route.matched);
      // ['home','list']
      this.crumbData = this.$route.matched.map(m =&gt; m.name || m.redirect)
    },
    immediate: true // 让它 create 的时候执行一次
  }
}
</code></pre>
<h2 id="简单重现">简单重现</h2>
<p>https://github.com/yuuFen/vue-router-reimplement</p>
<h3 id="通常用法与目标分析">通常用法与目标分析</h3>
<pre><code class="language-js">import Vue from 'vue'
import VueRouter from 'vue-router'

import Home from &quot;./views/Home&quot;
import About from &quot;./views/About&quot;

Vue.use(VueRouter)

export default new VueRouter({
    routes: [
        { path: '/', component: Home },
        { path: '/about', component: About },
    ]
})
</code></pre>
<pre><code class="language-js">import router from './router'

new View({
    router,
    // ...
})
</code></pre>
<p>目标：</p>
<ol>
<li>解析routes，变成一个key为path，value为component的map</li>
<li>监听url变化事件，把最新的hash值保存到current路由</li>
<li>定义两个全局组件：router-view用于显示匹配组件的内容，router-link用于修改hash</li>
<li>current应该是响应式的，这样可以触发router-view的重新渲染</li>
</ol>
<h3 id="实现">实现</h3>
<blockquote>
<p>没有考虑嵌套</p>
</blockquote>
<pre><code class="language-js">// install 时获取
let Vue

// hash 改变 =&gt; current (响应式)改变 =&gt; router-view 的 render 改变
export default class VueRouter {
  constructor(options) {
    this.$options = options

    // 用来保存 path 和 route 的映射
    this.routeMap = {}

    // 利用 Vue 让 current 实现响应式
    this.app = new Vue({
      data: {
        current: '/',
      },
    })
  }

  init() {
    // 绑定浏览器事件
    this.bindEvents()

    // 解析路由配置
    this.createRouteMap(this.$options)

    // 创建 router-link 和 router-view
    this.initComponent()
  }

  bindEvents() {
    window.addEventListener('hashchange', this.onHashChange.bind(this))
    window.addEventListener('load', this.onHashChange.bind(this))
  }
  onHashChange() {
    this.app.current = window.location.hash.slice(1) || '/'
  }
  createRouteMap(options) {
    options.routes.forEach((item) =&gt; {
      this.routeMap[item.path] = item
    })
  }
  initComponent() {
    Vue.component('router-link', {
      props: {
        to: String,
      },
      render(h) {
        // 目标：&lt;a :href=&quot;to&quot;&gt;doooo&lt;/a&gt;
        // 这里 this 指向 router-link 组件实例
        return h('a', { attrs: { href: '#' + this.to } }, this.$slots.default)
        // return &lt;a href={this.to}&gt;{this.$slots.default}&lt;/a&gt;  // 需要 babel-loader
      },
    })
    Vue.component('router-view', {
      // 箭头函数可以保留 this 指向，所以这里指向 VueRouter 实例
      render: (h) =&gt; {
        // console.log(this.app.current)
        // console.log(this.routeMap)
        // console.log(this.routeMap[this.app.current])
        const Comp = this.routeMap[this.app.current].component
        return h(Comp)
      },
    })
  }
}

VueRouter.install = function(_Vue) {
  Vue = _Vue

  Vue.mixin({
    beforeCreate() {
      // 每个组件 beforeCreate 的时候都会执行
      // 但是这里只希望在根组件上执行一次
      // this 指向 Vue 组件实例
      // this.$options.router 就是在 router.js 中 new 的 VueRouter 实例
      if (this.$options.router) {
        Vue.prototype.$router = this.$options.router
        this.$options.router.init()
      }
    },
  })
}
</code></pre>
<h3 id="使用同原版">使用同原版</h3>
<pre><code class="language-js">import Vue from 'vue'
import VueRouter from '../utils/router'

import Home from '../views/Home.vue'
import About from '../views/About.vue'
import Main from '../views/Main.vue'

Vue.use(VueRouter)

export default new VueRouter({
  routes: [
    { path: '/', component: Home },
    { path: '/main', component: Main },
    { path: '/about', component: About },
  ],
})
</code></pre>
<pre><code class="language-js">// ...

import router from './router'

new Vue({
  router,
  render: (h) =&gt; h(App),
}).$mount('#app')
</code></pre>
<pre><code class="language-html">    &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;
    &lt;router-link to=&quot;/main&quot;&gt;Main&lt;/router-link&gt;
    &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 组件化]]></title>
        <id>https://yuufen.com/blog/post/Bpq2VQQen/</id>
        <link href="https://yuufen.com/blog/post/Bpq2VQQen/">
        </link>
        <updated>2020-02-22T09:56:41.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1583424020660.png" alt="" loading="lazy"></figure>
<h2 id="组件间通信">组件间通信</h2>
<h3 id="父组件-子组件">父组件 =&gt; 子组件</h3>
<ul>
<li>属性 props</li>
</ul>
<pre><code class="language-vue">// child 
props: { msg: String } 
// parent 
&lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot; /&gt;
</code></pre>
<ul>
<li>$attrs / $listeners</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>r</mi><mi>s</mi><mi mathvariant="normal">储</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">域</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">被</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">识</mi><mi mathvariant="normal">别</mi><mo>(</mo><mi mathvariant="normal">且</mi><mi mathvariant="normal">获</mi><mi mathvariant="normal">取</mi><mo>)</mo><mi mathvariant="normal">的</mi><mi mathvariant="normal">特</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">绑</mi><mi mathvariant="normal">定</mi><mo>(</mo><mi>c</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mi mathvariant="normal">和</mi><mi>s</mi><mi>t</mi><mi>y</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">除</mi><mi mathvariant="normal">外</mi><mo>)</mo><mi mathvariant="normal">，</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi>v</mi><mo>−</mo><mi>b</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">attrs储存的是父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外) ，使用v-bind=&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">储</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">域</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">被</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">识</span><span class="mord cjk_fallback">别</span><span class="mopen">(</span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">获</span><span class="mord cjk_fallback">取</span><span class="mclose">)</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">绑</span><span class="mord cjk_fallback">定</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">和</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">除</span><span class="mord cjk_fallback">外</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">&quot;</span></span></span></span>attrs&quot;可以实现自动挂载。</p>
<p>默认组件根元素上会自动挂载没有在props声明的属性，配置 inheritAttrs: false 可以关闭。</p>
<ul>
<li>引用 $refs</li>
</ul>
<pre><code class="language-vue">// parent
&lt;HelloWorld ref=&quot;hw&quot; /&gt;

this.$refs.hw.xx = 'xxx'
</code></pre>
<ul>
<li>$children</li>
</ul>
<pre><code>// parent
this.$children[0].xx = 'xxx'
</code></pre>
<blockquote>
<p>不保证顺序</p>
</blockquote>
<h3 id="子组件-父组件">子组件 =&gt; 父组件</h3>
<p>自定义事件：</p>
<pre><code class="language-vue">// child 
this.$emit('add', good) 
// parent 
&lt;Cart @add=&quot;cartAdd($event)&quot;&gt;&lt;/Cart&gt;
</code></pre>
<p>观察者模式，因为是作用域是 this 所以<strong>谁派发谁监听</strong>。</p>
<h3 id="v-model-双向绑定-与-sync-的区别">v-model 双向绑定 / 与 .sync 的区别</h3>
<ul>
<li>
<p>v-model=&quot;bar&quot;是 :value=&quot;bar&quot; @input=&quot;bar=$event&quot; 的语法糖</p>
<p>但是可以在<strong>组件中</strong>设置model选项修改v-model的默认行为</p>
</li>
</ul>
<pre><code class="language-js">// Checkbox.vue
{
  {
    model: {
      prop: 'checked'
      event: 'change'
    }
  }
}
</code></pre>
<ul>
<li>
<p>value.sync=”bar“ 是 :value=&quot;bar&quot; @update:value=&quot;bar=$event&quot; 的语法糖</p>
<p>要更改绑定的属性名称，需要在<strong>父组件</strong>中更改，如：</p>
<pre><code class="language-html">&lt;m-input foo.sync=&quot;bar&quot;&gt;
等效于
&lt;m-input :foo=&quot;bar&quot; @update:foo=&quot;bar=$event&quot;&gt; 
</code></pre>
</li>
</ul>
<h3 id="兄弟组件">兄弟组件</h3>
<p>通过共同的祖辈组件搭桥，$parent 或 $root：</p>
<pre><code class="language-js">// brother1
this.$parent.$on('foo', handle)

// brother2
this.$parent.$emit('foo')
</code></pre>
<h3 id="祖先与后代">祖先与后代</h3>
<ul>
<li>provide / inject 可以实现祖先给后代传值，可以传对象：</li>
</ul>
<pre><code class="language-js">// ancestor
provide() {    
  return {foo: 'foo'}
}

// descendant
inject: ['foo']
</code></pre>
<blockquote>
<p>provide 和 inject 主要为高阶插件/组件库提供用例，并不推荐直接用于应用程序代码中，多会在开源组件库中见到。<br>
后代想给祖先传值这种方案行不通</p>
</blockquote>
<ul>
<li>广播，自上而下</li>
</ul>
<p>https://github.com/ElemeFE/element/blob/dev/src/mixins/emitter.js</p>
<pre><code class="language-js">function broadcast(componentName, eventName, params) {
  this.$children.forEach(child =&gt; {
    var name = child.$options.componentName;

    if (name === componentName) {
      child.$emit.apply(child, [eventName].concat(params));
    } else {
      broadcast.apply(child, [componentName, eventName].concat([params]));
    }
  });
}
</code></pre>
<ul>
<li>自下而上</li>
</ul>
<pre><code class="language-js">dispatch(componentName, eventName, params) {
  var parent = this.$parent || this.$root;
  var name = parent.$options.componentName;

  while (parent &amp;&amp; (!name || name !== componentName)) {
    parent = parent.$parent;

    if (parent) {
      name = parent.$options.componentName;
    }
  }
  if (parent) {
    parent.$emit.apply(parent, [eventName].concat(params));
  }
},
</code></pre>
<h3 id="任意两个组件之间事件总线-vuex">任意两个组件之间：事件总线 / Vuex</h3>
<ul>
<li>事件总线</li>
</ul>
<pre><code class="language-js">// 创建一个Bus类负责事件派发、监听和回调管理
class Bus {
  constructor() {
    this.callbacks = {}
  }
  $on(name, fn) {
    ;(this.callbacks[name] || this.callbacks[name] = []).push(fn)
  }
  $emit(name, ...args) {
    const cbs = this.callback[name]
    if (cbs) {
      cbs.forEach((cb) =&gt; {
        cb.call(this, ...args)
      })
    }
  }
}

// main.js
Vue.prototype.$bus = new Bus()

// child1
this.$bus.$on('foo', handle)
// child2
this.$bus.$emit('foo')
</code></pre>
<pre><code class="language-js">// 或者 main.js 直接
Vue.prototype.$bus = new Vue()
</code></pre>
<ul>
<li>Vuex</li>
</ul>
<p>创建唯一的全局数据管理者 store，通过它管理数据并通知组件状态变更</p>
<h2 id="组件复合-内容分发插槽">组件复合 / 内容分发：插槽</h2>
<p>模板方法模式。匿名插槽、具名插槽、作用域插槽。</p>
<blockquote>
<p>Vue 2.6.0之后采用全新的v-slot语法取代之前的slot、slot-scope</p>
</blockquote>
<pre><code class="language-vue">// comp2 
&lt;div&gt;
  &lt;slot&gt;&lt;/slot&gt;
  &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;
  &lt;slot name=&quot;bar&quot; foo=&quot;foooooooo&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;

// parent 
&lt;Comp2&gt;
  &lt;!-- 匿名插槽用default做参数 --&gt;
  &lt;template v-slot:default&gt;具名插槽&lt;/template&gt;
  &lt;!-- 具名插槽用插槽名做参数 --&gt;
  &lt;template v-slot:content&gt;内容...&lt;/template&gt;
  &lt;!-- 作用域插槽获取子组件传来的数据 --&gt;
  &lt;template v-slot:content=&quot;ctx&quot;&gt;来自子组件数据：{{ctx.foo}}&lt;/template&gt;
&lt;/Comp2&gt;
</code></pre>
<h2 id="弹窗组件">弹窗组件</h2>
<p>弹窗这类组件的特点是它们在当前vue实例例之外独⽴立存在，通常挂载于body（所以需要 new 一个 Vue 实例）；它们是通过JS动态创建 的，不需要在任何组件中声明。</p>
<p>create.js</p>
<pre><code class="language-js">import Vue from 'vue'
export default function create(Component, props) {
  const vm = new Vue({
    render(h) {
      // render 方法提供 h 函数，用来渲染 VNode
      return h(Component, { props })
    },
  }).$mount() // 做好挂载准备(生成DOM)但暂不挂载（因为不支持直接挂载到body），为下面 $el 做准备

  // 1. vm 创建组件实例
  // 2. 通过 $children 获取创建好的传入组件的实例
  const comp = vm.$children[0]

  // 3. 追加至body
  document.body.appendChild(vm.$el)

  // 4. 给组件直接挂载上清理函数
  comp.remove = function(){
    document.body.removeChild(vm.$el)
    vm.$destroy()
  }

  // 5. 返回组件实例
  return comp
}
</code></pre>
<p>notice.vue</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div v-if=&quot;iShow&quot;&gt;
    &lt;h3&gt;title&lt;/h3&gt;
    &lt;div&gt;message&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: {
    title: { type: String, default: '' },
    message: { type: String, default: '' },
    duration: { type: Number, default: 1000 },
  },
  data() {
    return {
      isShow: false,
    }
  },
  methods: {
    show() {
      this.isShow = true
      setTimeout(() =&gt; {
        this.hide()
      }, this.duration)
    },
    hide() {
      this.isShow = false
      this.remove() // 来自 create.js
    },
  },
}
&lt;/script&gt;
</code></pre>
<p>Father.vue</p>
<pre><code class="language-js">import create from '...' // 或者直接挂在 Vue.prototype 上，能在任何地方 Create
import Notice from '...'

  const notice = create(Notice, {
    title: 'Title',
    message: 'Message',
    duration: 2000
  })
  notice.show()

</code></pre>
<h2 id="递归组件">递归组件</h2>
<pre><code class="language-vue">// Node.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;{{ data.title }}&lt;/h3&gt;
    &lt;!-- 必须有结束条件 --&gt;
    &lt;Node v-for=&quot;d in data.children&quot; :key=&quot;d.id&quot; :data=&quot;d&quot;&gt;&lt;/Node&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: 'Node', // name对递归组件是必要的
  props: {
    data: {
      type: Object,
      require: true,
    },
  },
}
&lt;/script&gt;

// 使用 
&lt;Node :data=&quot;{id:'1',title:'递归组件',children:[{...}]}&quot;&gt;&lt;/Node&gt;
</code></pre>
<h3 id="tree-组件">Tree 组件</h3>
<p>Father.vue</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;ul&gt;
      &lt;item :model=&quot;treeData&quot;&gt;&lt;/item&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>item.vue</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;li&gt;
    &lt;div @click=&quot;toggle&quot;&gt;
        {{model.title}}
        &lt;span v-if=&quot;haveChild&quot;&gt;{{open ? '-' : '+'}}&lt;/span&gt;
    &lt;/div&gt;
    &lt;ul&gt;
        &lt;item v-for=&quot;model in model.children&quot; :model=&quot;model&quot; :key=&quot;model.title&quot;&gt;&lt;/item&gt;  
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/template&gt;

// 懒加载：传入标识符 =&gt; 判断标识符 true =&gt; show loading、请求数据
</code></pre>
<h2 id="plugins">plugins</h2>
<pre><code class="language-js">// 插件定义 
MyPlugin.install = function (Vue, options) {  
  // 1. 添加全局方法或属性  
  Vue.myGlobalMethod = function () {    
    // 逻辑...  
  }
  // 2. 添加全局资源  
  Vue.directive('my-directive', {    
    bind (el, binding, vnode, oldVnode) {     
      // 逻辑...    
    }  
    ...  
  })
  // 3. 注⼊组件选项
  Vue.mixin({  
    created: function () {   
      // 逻辑...  
    } 
    ... 
  })
  // 4. 添加实例方法 
  Vue.prototype.$myMethod = function (methodOptions) {
    // 逻辑... 
  }
}

// 插件使用
Vue.use(MyPlugin)
</code></pre>
<h2 id="mixins">mixins</h2>
<pre><code class="language-js">// 定义一个混入对象
var myMixin = {
  created: function() {
    this.hello()
  },
  methods: {
    hello: function() {
      console.log('hello from mixin!')
    },
  },
}
// 定义一个使用混入对象的组件
var Component = Vue.extend({
  mixins: [myMixin],
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数柯里化]]></title>
        <id>https://yuufen.com/blog/post/gxNr15aBN/</id>
        <link href="https://yuufen.com/blog/post/gxNr15aBN/">
        </link>
        <updated>2020-02-20T04:16:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="柯里化从何而来">柯里化从何而来</h2>
<p>柯里化, 即 Currying 的音译。Currying 是编译原理层面实现多参函数的一个技术。</p>
<p>在编码过程中，身为码农的我们本质上所进行的工作就是——将复杂问题分解为多个可编程的小问题。</p>
<p>Currying 为实现多参函数提供了一个递归降解的实现思路——把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数，在某些编程语言中（如 Haskell），是通过 Currying 技术支持多参函数这一语言特性的。</p>
<p>所以 Currying 原本是一门编译原理层面的技术，用途是实现多参函数。</p>
<h2 id="实现原理">实现原理</h2>
<pre><code class="language-js">let _fn = curry(function(a, b, c, d, e) {
  console.log(a + b + c + d + e)
})

// 目标：
_fn(1, 2, 3, 4, 5) // 15
_fn(1)(2, 3)(4)(5) // 15
_fn(1)(2)(3)(4)(5) // 15

// 实现，可以把 _curry() 提取出来
function curry(fn, len = fn.length) {
  return function _curry(...args) {
    if (args.length &gt;= len) {
      return fn.apply(this, args)
    }
    return function(...params) {
      _args = [...args, ...params]

      if (_args.length &gt;= len) {
        return fn.apply(this, _args)
      } else {
        return _curry.call(this, ..._args)
      }
    }
  }
}
</code></pre>
<h2 id="currying-使用场景">Currying 使用场景</h2>
<h3 id="参数复用">参数复用</h3>
<p>固定不变的参数，实现参数复用是 Currying 的主要用途之一。<br>
上文中的 increment, addTen 是一个参数复用的实例。对 add 方法固定第一个参数为 10 后，改方法就变成了一个将接受的变量值加 10 的方法。</p>
<h3 id="延迟执行">延迟执行</h3>
<p>延迟执行也是 Currying 的一个重要使用场景，同样 bind 和箭头函数也能实现同样的功能。<br>
在前端开发中，一个常见的场景就是为标签绑定 onClick 事件，同时考虑为绑定的方法传递参数。</p>
<h2 id="为什么需要-currying">为什么需要 Currying</h2>
<h3 id="为了多参函数复用性">为了多参函数复用性</h3>
<p>Currying 让人眼前一亮的地方在于，让人觉得函数还能这样子复用。</p>
<p>通过一行代码，将 add 函数转换为 increment，addTen 等。</p>
<p>对于 Currying 的复杂实现中，以 Lodash 为列，提供了 placeholder 的神奇操作。对多参函数的复用玩出花样。</p>
<pre><code class="language-js">import _ from 'loadsh'

function abc(a, b, c) {
  return [a, b, c]
}

var curried = _.curry(abc)

// Curried with placeholders.
curried(1)(_, 3)(2)
// =&gt; [1, 2, 3]
</code></pre>
<h3 id="为函数式编程而生">为函数式编程而生</h3>
<p>Currying 是为函数式而生的东西。应运着有一整套函数式编程的东西，纯函数、compose、container 等等事物。（可阅读《mostly-adequate-guide》 ）<br>
假如要写 Pointfree Javascript 风格的代码，那么 Currying 是不可或缺的。<br>
要使用 compose，要使用 container 等事物，我们也需要 Currying。</p>
<h2 id="为什么不需要-currying">为什么不需要 Currying</h2>
<h3 id="currying-的一些特性有其他解决方案">Currying 的一些特性有其他解决方案</h3>
<p>如果我们只是想提前绑定参数，那么我们有很多好几个现成的选择，bind，箭头函数等，而且性能比 Curring 更好。</p>
<h3 id="currying-陷于函数式编程">Currying 陷于函数式编程</h3>
<p>在本文中，提供了一个 trueCurrying 的实现，这个实现也是最符合 Currying 定义的，也提供 了 bind，箭头函数等不具备的“新奇”特性——可持续的 Currying（这个词是本人临时造的）。<br>
但是这个“新奇”特性的应用并非想象得那么广泛。<br>
其原因在于，Currying 是函数式编程的产物，它生于函数式编程，也服务于函数式编程。<br>
而 JavaScript 并非真正的函数式编程语言，相比 Haskell 等函数式编程语言，JavaScript 使用 Currying 等函数式特性有额外的性能开销，也缺乏类型推导。<br>
从而把 JavaScript 代码写得符合函数式编程思想和规范的项目都较少，从而也限制了 Currying 等技术在 JavaScript 代码中的普遍使用。<br>
假如我们还没有准备好去写函数式编程规范的代码，仅需要在 JSX 代码中提前绑定一次参数，那么 bind 或箭头函数就足够了。</p>
<h2 id="结论">结论</h2>
<ol>
<li>Currying 在 JavaScript 中是“低性能”的，但是这些性能在绝大多数场景，是可以忽略的。</li>
<li>Currying 的思想极大地助于提升函数的复用性。</li>
<li>Currying 生于函数式编程，也陷于函数式编程。假如没有准备好写纯正的函数式代码，那么 Currying 有更好的替代品。</li>
<li>函数式编程及其思想，是值得关注、学习和应用的事物。所以在文末再次安利 JavaScript 程序员阅读此书 —— 《mostly-adequate-guide》</li>
</ol>
<p>部分转载于 https://juejin.im/post/5af13664f265da0ba266efcf</p>
]]></content>
    </entry>
</feed>