<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yuufen.com/blog</id>
    <title>YuuFen</title>
    <updated>2020-03-02T20:03:48.510Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yuufen.com/blog"/>
    <link rel="self" href="https://yuufen.com/blog/atom.xml"/>
    <subtitle>希望你可以记住我</subtitle>
    <logo>https://yuufen.com/blog/images/avatar.png</logo>
    <icon>https://yuufen.com/blog/favicon.ico</icon>
    <rights>All rights reserved 2020, YuuFen</rights>
    <entry>
        <title type="html"><![CDATA[你好呀，陌生人]]></title>
        <id>https://yuufen.com/blog/post/about/</id>
        <link href="https://yuufen.com/blog/post/about/">
        </link>
        <updated>2024-02-28T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>因为笔记太多太杂，决定定期写写博客整理整理笔记。</p>
<p><s>然后因为各种原因失去了动力</s></p>
<p><s>因此搞丢了好多笔记啊啊啊啊啊啊啊😭😭😭</s></p>
<p><s>看了看一年前的博文发现自己真的变化了蛮多的（加油💪）</s></p>
<p>总之现在又开始了</p>
<h2 id="关于我">🐟 关于我</h2>
<p>我目前大二在读，我的职业规划是前端工程师，拥有一年以上的前端项目开发经验，当然基础也没有落下！我的专业是电子信息，所以我还了解一些嵌入式开发（当然只是一些些），对Python和TensorFlow也有一定的涉猎。我正在努力寻找暑期实习！</p>
<p>在以下位置找到有关我的更多信息：</p>
<p><a href="https://yuufen.com/" target="_blank" class="text-button">主页</a><a href="https://yuufen.com/blog" target="_blank" class="text-button">博客</a><a href="https://yuufen.com/" target="_blank" class="text-button">项目</a><a href="mailto:me@yuufen.com" class="text-button">给我发邮件</a></p>
<h2 id="兴趣爱好">🎨 兴趣爱好</h2>
<p><strong>摄影</strong>、羽毛球、轮滑，and playing!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器渲染架构]]></title>
        <id>https://yuufen.com/blog/post/tWNxkYDGN/</id>
        <link href="https://yuufen.com/blog/post/tWNxkYDGN/">
        </link>
        <updated>2020-03-02T13:34:56.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1583166954595.png" alt="" loading="lazy"></figure>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1583166954595.png" alt="" loading="lazy"></figure>
<!-- more -->
<p>js 动画 / CSS 动画</p>
<p>查表：https://csstriggers.com/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式总结（都在码里）]]></title>
        <id>https://yuufen.com/blog/post/_lKjmwEdd/</id>
        <link href="https://yuufen.com/blog/post/_lKjmwEdd/">
        </link>
        <updated>2020-03-01T06:51:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pub-sub订阅-发布模式观察者模式">pub / sub（订阅 / 发布模式，观察者模式）</h2>
<h3 id="优点">优点</h3>
<p>解耦，降低代码入侵性</p>
<pre><code class="language-js">原始：
ModuleA
  import B
  B.action()
ModuleB
  action() {
    import C
    C.action()
  }
ModuleC
  action() {
    doSomething()
  }

观察者：
Event
ModuleA
  event.$emit()
ModuleB
  event.$on()
  event.$emit()
ModuleC
  event.$on()
</code></pre>
<h3 id="目标-实现">目标 &amp; 实现</h3>
<p>参考 vue</p>
<pre><code class="language-js">// 实现：
class Event {
  constructor() {
    this.callback = {}
  }

  $on(name, fn) {
    ;(this.callback[name] || (this.callback[name] = [])).push(fn)
  }

  $emit(name, ...args) {
    const cbs = this.callback[name]
    if (cbs) {
      cbs.forEach((cb) =&gt; {
        cb.call(this, ...args)
      })
    }
  }

  $off(name) {
    this.callback[name] = null
  }
}

// 目标：
let event = new Event()
// 监听
event.$on('event1', (...args) =&gt; {
  console.log('event1', ...args)
})
event.$on('event1', (...args) =&gt; {
  console.log('event1 again', ...args)
})
// 触发
event.$emit('event1', 1, 2, 3)
// 解绑
console.log('-'.repeat(20))
event.$off('event1')
event.$emit('event1', 1, 2, 3) // 测试
</code></pre>
<h2 id="单例模式">单例模式</h2>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h3 id="适用场景">适用场景</h3>
<p>如：</p>
<ol>
<li>弹窗，无论点击多少次都只被创建一次。</li>
<li>redux 的 store，全局唯一</li>
</ol>
<h3 id="简单实例">简单实例</h3>
<pre><code class="language-js">// 新建弹窗，期望弹窗全局唯一
// 伪代码:
// function createModalLayer() {
//   // 闭包储存单例实例
//   let result
//   return function() {
//     return result || (result = 新建弹窗)
//   }
// }
// 提取：
// 高阶函数：
function getSingle(fn) {
  let result
  return function() {
    return result || (result = fn.apply(this, arguments))
  }
}
function createModalLayer() {
  console.log('新建弹窗')
  const div = document.createElement('div')
  div.innerHTML = new Date()
  div.className = 'modal'
  div.style.display = 'none'
  document.body.appendChild(div)
  div.addEventListener(
    'click',
    function() {
      div.style.display = 'none'
    },
    false,
  )
  return div
}

createModalLayer = getSingle(createModalLayer)

document.getElementById('modal-btn').addEventListener('click', function() {
  // 新建弹窗
  const modalLayer = createModalLayer()
  modalLayer.style.display = 'block'
})
</code></pre>
<h2 id="策略模式">策略模式</h2>
<h3 id="分析">分析</h3>
<p>KISS 原则 keep it simple and stupid</p>
<p>策略模式指定义一系列算法，把他们一个个封装起来，并使他们可以相互替换。</p>
<p>目的是将算法的使用和实现分离。</p>
<p>一个基于策略模式的程序至少由两部分组成。第一部分是一组策略类（可变），封装了具体的算法，负责具体的计算过程；第二部分是环境类 Context（不变），Context 接收客户的请求，随后将请求委托给某一个策略类。要做到这一点，说明 Context 中要维持对某个策略对象的引用。</p>
<h3 id="实例">实例</h3>
<p>原始（面条式代码）：</p>
<pre><code class="language-js">let form = 获取表单
form.onSubmit = function() {
  if (form.name.value === '') {
    弹出错误消息
  }
  if (form.password.value === '') {
    弹出错误消息
  }
  if (form.password.value.length &lt; 5) {
    弹出错误消息
  }
  正则等等
}
</code></pre>
<p>策略模式（具体看 element 的表单验证 https://github.com/ElemeFE/element/blob/dev/packages/form/src/form.vue ），其他例子：</p>
<pre><code class="language-js">// 1. 策略
// 可以使用配置
const policy = {
  S: function(salary) {
    return salary * 4
  },
  A: function(salary) {
    return salary * 3
  },
  B: function(salary) {
    return salary * 2
  },
  C: function(salary) {
    return salary
  },
}
// 2. 使用
function calculate(level, salary) {
  return policy[level] ? policy[level](salary) : 0
}
</code></pre>
<h2 id="代理模式">代理模式</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[制作个人主页的技术总结]]></title>
        <id>https://yuufen.com/blog/post/gsBr49oPO/</id>
        <link href="https://yuufen.com/blog/post/gsBr49oPO/">
        </link>
        <updated>2020-02-28T10:27:58.000Z</updated>
        <content type="html"><![CDATA[<p>一直都想搭个个人主页，但是因为没有什么特别的 Idea，而自己的设计着实体现出标准的工科直男气息，所以也就一直拖着没开始。直到在知乎看到了 zhangwenli 小姐姐的作品，着实被惊艳到。因为小姐姐是基于旧版本的 vue cli 实现的，并且当时我的技能点基本都点在了 React 上，所以本着顺便学习 Vue 的目的，我使用 vue cli3(4) 重新实现了一遍这个项目。做完之后也学到了很多东西。</p>
<h2 id="架构">架构</h2>
<p>这里应该有图，但我画在草稿纸上了(oh shift)。</p>
<h2 id="目录结构">目录结构</h2>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1582896479729.png" alt="" loading="lazy"></figure>
<p>这是我的博客最后的目录结构。说实话第一眼看到她的目录结构我是有点懵逼的，最明显的就是 SCSS 和组件分离，并且 SCSS 和组件都统一全局声明，看着有点像 React，和我接触到的其他 vue 项目相差很大，可能是因为在 vue cli3 之后比较少见，但确实非常方便，样式和组件之间的关系更加清晰明了，也可以更方便的统一配置管理。</p>
<h2 id="提取配置和工具类-工具函数">提取配置和工具类 / 工具函数</h2>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1582896974166.png" alt="" loading="lazy"></figure>
<p>将可配置的尽量提出来变成可配置的，是降低工程复杂度的最佳方式之一，无论这个配置看起来和程序主题耦合的多么深。博客的可配置项从各个应用的图标标题，到 app 分组，以及相册，需要从一开始就定下来。</p>
<p>而工具类 / 工具函数的提取是我所欠缺的，因为我平时做些小工程，初期分析架构时很少会细致到这一步，导致会出现重复代码，或者某个组件具体代码可读性比较差，可能中期或者结束了还要花费时间去重构。这也是吸取了一个教训，初期架构的时候就要在意可复用的工具类，编码时发现又可能可复用一些东西就及时提出来，不要觉得可能以后用不到就直接放着了。</p>
<h2 id="一些细节">一些细节</h2>
<p>举一些在原版中没有找到解决方法的问题</p>
<h3 id="resize-的监听">resize 的监听</h3>
<p>因为背景是通过 canvas 画的，所以当 resize 后需要计算各元素的宽高度，再重新调用绘图函数画出背景。子元素需要等待父元素 resize 后才能获取到正确的宽高度。张姐采用的解决方案是先监听 resize 事件计算出宽高度再 new 根组件，在 vue cli3 中并不适用。于是我在子组件中监听父组件的 resize。</p>
<h3 id="左右滑动的动画">左右滑动的动画</h3>
<p>张姐的版本并没有做滑动的动画（我看到她给 scroll 加了一个 transition，但这并不会有效果…），我用定时器完成了这个。</p>
<h3 id="屏蔽了移动端浏览器左右滑手势的前进后退">屏蔽了移动端浏览器左右滑手势的前进后退</h3>
<p>原版 Slider 组件左右滑动时会触发浏览器的前进后退，很影响使用。我就直接 prevent 了 touchmove 事件的冒泡。</p>
<h3 id="实现在-app-界面时按返回键返回首页">实现在 app 界面时按返回键返回首页</h3>
<p>原版在 app 界面，习惯性的点击返回键的话会直接关闭 web 页面。我通过 history 和 popstate 事件解决了这一点，并模仿 app 实现了双击返回退出。</p>
<h3 id="代码风格">代码风格</h3>
<ol>
<li>之前写 SCSS 都是能套多少层就套多少层，看了她的代码才知道这样不行，可读性不好还影响性能；</li>
<li>写多了弹性布局都快忘记传统布局咋写的了，以后要多结合使用；</li>
<li>原来用伪元素可以画出叉叉……</li>
<li>多多提取工具类工具函数，降低工程复杂度</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数柯里化]]></title>
        <id>https://yuufen.com/blog/post/gxNr15aBN/</id>
        <link href="https://yuufen.com/blog/post/gxNr15aBN/">
        </link>
        <updated>2020-02-27T06:16:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="柯里化从何而来">柯里化从何而来</h2>
<p>柯里化, 即 Currying 的音译。Currying 是编译原理层面实现多参函数的一个技术。</p>
<p>在编码过程中，身为码农的我们本质上所进行的工作就是——将复杂问题分解为多个可编程的小问题。</p>
<p>Currying 为实现多参函数提供了一个递归降解的实现思路——把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数，在某些编程语言中（如 Haskell），是通过 Currying 技术支持多参函数这一语言特性的。</p>
<p>所以 Currying 原本是一门编译原理层面的技术，用途是实现多参函数。</p>
<h2 id="实现原理">实现原理</h2>
<pre><code class="language-js">let _fn = curry(function(a, b, c, d, e) {
  console.log(a + b + c + d + e)
})

// 目标：
_fn(1, 2, 3, 4, 5) // 15
_fn(1)(2, 3)(4)(5) // 15
_fn(1)(2)(3)(4)(5) // 15

// 实现，可以把 _curry() 提取出来
function curry(fn, len = fn.length) {
  return function _curry(...args) {
    if (args.length &gt;= len) {
      return fn.apply(this, args)
    }
    return function(...params) {
      _args = [...args, ...params]

      if (_args.length &gt;= len) {
        return fn.apply(this, _args)
      } else {
        return _curry.call(this, ..._args)
      }
    }
  }
}
</code></pre>
<h2 id="currying-使用场景">Currying 使用场景</h2>
<h3 id="参数复用">参数复用</h3>
<p>固定不变的参数，实现参数复用是 Currying 的主要用途之一。<br>
上文中的 increment, addTen 是一个参数复用的实例。对 add 方法固定第一个参数为 10 后，改方法就变成了一个将接受的变量值加 10 的方法。</p>
<h3 id="延迟执行">延迟执行</h3>
<p>延迟执行也是 Currying 的一个重要使用场景，同样 bind 和箭头函数也能实现同样的功能。<br>
在前端开发中，一个常见的场景就是为标签绑定 onClick 事件，同时考虑为绑定的方法传递参数。</p>
<h2 id="为什么需要-currying">为什么需要 Currying</h2>
<h3 id="为了多参函数复用性">为了多参函数复用性</h3>
<p>Currying 让人眼前一亮的地方在于，让人觉得函数还能这样子复用。</p>
<p>通过一行代码，将 add 函数转换为 increment，addTen 等。</p>
<p>对于 Currying 的复杂实现中，以 Lodash 为列，提供了 placeholder 的神奇操作。对多参函数的复用玩出花样。</p>
<pre><code class="language-js">import _ from 'loadsh'

function abc(a, b, c) {
  return [a, b, c]
}

var curried = _.curry(abc)

// Curried with placeholders.
curried(1)(_, 3)(2)
// =&gt; [1, 2, 3]
</code></pre>
<h3 id="为函数式编程而生">为函数式编程而生</h3>
<p>Currying 是为函数式而生的东西。应运着有一整套函数式编程的东西，纯函数、compose、container 等等事物。（可阅读《mostly-adequate-guide》 ）<br>
假如要写 Pointfree Javascript 风格的代码，那么 Currying 是不可或缺的。<br>
要使用 compose，要使用 container 等事物，我们也需要 Currying。</p>
<h2 id="为什么不需要-currying">为什么不需要 Currying</h2>
<h3 id="currying-的一些特性有其他解决方案">Currying 的一些特性有其他解决方案</h3>
<p>如果我们只是想提前绑定参数，那么我们有很多好几个现成的选择，bind，箭头函数等，而且性能比 Curring 更好。</p>
<h3 id="currying-陷于函数式编程">Currying 陷于函数式编程</h3>
<p>在本文中，提供了一个 trueCurrying 的实现，这个实现也是最符合 Currying 定义的，也提供 了 bind，箭头函数等不具备的“新奇”特性——可持续的 Currying（这个词是本人临时造的）。<br>
但是这个“新奇”特性的应用并非想象得那么广泛。<br>
其原因在于，Currying 是函数式编程的产物，它生于函数式编程，也服务于函数式编程。<br>
而 JavaScript 并非真正的函数式编程语言，相比 Haskell 等函数式编程语言，JavaScript 使用 Currying 等函数式特性有额外的性能开销，也缺乏类型推导。<br>
从而把 JavaScript 代码写得符合函数式编程思想和规范的项目都较少，从而也限制了 Currying 等技术在 JavaScript 代码中的普遍使用。<br>
假如我们还没有准备好去写函数式编程规范的代码，仅需要在 JSX 代码中提前绑定一次参数，那么 bind 或箭头函数就足够了。</p>
<h2 id="结论">结论</h2>
<ol>
<li>Currying 在 JavaScript 中是“低性能”的，但是这些性能在绝大多数场景，是可以忽略的。</li>
<li>Currying 的思想极大地助于提升函数的复用性。</li>
<li>Currying 生于函数式编程，也陷于函数式编程。假如没有准备好写纯正的函数式代码，那么 Currying 有更好的替代品。</li>
<li>函数式编程及其思想，是值得关注、学习和应用的事物。所以在文末再次安利 JavaScript 程序员阅读此书 —— 《mostly-adequate-guide》</li>
</ol>
<p>部分转载于 https://juejin.im/post/5af13664f265da0ba266efcf</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[做博客的目的与大致记录]]></title>
        <id>https://yuufen.com/blog/post/azDr69oSX/</id>
        <link href="https://yuufen.com/blog/post/azDr69oSX/">
        </link>
        <updated>2018-12-25T10:35:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>第一篇博文，留作纪念<br>
才发现那天是圣诞节，祝大家圣诞快乐🎉</p>
</blockquote>
<h2 id="目的与简介">目的与简介</h2>
<p>我一直都有记笔记的习惯，但是并不会去主动整理，于是图片也好，文本也好，都散落在各个文件夹或是抽屉里。于是就有了搭建一个博客整理笔记的念头。选择的是最简单的 hexo + github ，以后会考虑尝试 python + WAMP 。虽然最开始只想做个技术博客，但<s>或许以后反而会以日常生活为主</s>。</p>
<p>这篇博客简单记述了我在使用 hexo 搭载博客的过程中走过的路和跌过的坑。目的是总结这三天看了许多教程的成果以及尝试 markdown 的排版。</p>
<h2 id="配置环境">配置环境</h2>
<p>安装 Hexo 之前，需要安装环境 Node.js 和 Git 。最新版官网下载太慢，我选择的是老版本的国内镜像。安装过程都是下一步，这里就不累述了。<br>
安装完成后在 cmd 输入以下代码：</p>
<pre><code>node -v
npm -v
git --version
</code></pre>
<p>返回了版本号，安装成功。</p>
<h2 id="安装hexo">安装hexo</h2>
<p>安装好 node.js 和 git 后，可以通过 npm 来安装 Hexo 。</p>
<pre><code>npm install -g hexo-cli
</code></pre>
<h2 id="初始化hexo">初始化Hexo</h2>
<p>在博客根目录输入以下代码：</p>
<pre><code>hexo init
npm install
</code></pre>
<p>提示了两个 WARN ，WINDOWS 用户可以忽略。</p>
<h2 id="建站">建站</h2>
<p>hexo 的命令我就不细说了，有中文的帮助文档。</p>
<h2 id="部署到github">部署到github</h2>
<p>这里的花了我很长时间，有以下几个要点：</p>
<h3 id="创建仓库">创建仓库</h3>
<p>仓库名需要用<code>用户名.github.io</code>的形式。</p>
<h3 id="添加部署路径">添加部署路径</h3>
<ul>
<li>属性和内容之间有一个空格；</li>
<li>需要配置SSH等参数，这部分搜git就有很多相关教程。</li>
</ul>
<h3 id="安装插件">安装插件</h3>
<p>输入命令行<code>npm install hexo-deployer-git --save</code>安装插件的时候，报错提示<code>This package is no longer maintained</code>该插件不再维护。<br>
这里需要安装cnpm：</p>
<pre><code>npm install cnpm -g --tegistry=https://registry.npm.taobao.org
</code></pre>
<p>安装过程中报错：</p>
<pre><code>npm WARN deprecated socks@1.1.10: If using 2.x branch, please upgrade to at least 2.1.6 to avoid a serious bug with socket data flow and an import issue introduced in 2.1.0
</code></pre>
<p>是因为npm的一个包版本太低，因为是WARN，就忽略了。然后用淘宝NPM镜像的<code>hexo-deployer-git</code>试了一下：</p>
<pre><code>cnpm install hexo-deployer-git --save
</code></pre>
<p>安装成功了。</p>
<h3 id="发布">发布</h3>
<p>在根目录打开 git bash ，键入：</p>
<pre><code>hexo d -g
</code></pre>
<p>提示<code>git:done</code>，部署成功，至此我完成了一个可以即时访问的个人博客。</p>
<h2 id="域名申请">域名申请</h2>
<h3 id="购买域名">购买域名</h3>
<p>我在 <a href="https://my.freenom.com/clientarea.php">Freenom</a> 上获取了这个免费域名，freenom 提供了 tk、ml、ga、cf、gq 这几类后缀的免费域名。tk域名，意为 Talker（说话的人）。.tk 域名是南太平洋岛国托克劳的顶级域名, .ml 是非洲国家马里的后缀, .ga 域名为加蓬国家顶级域名后缀, .cf 是中非共和国的后缀, .gq 域名是赤道几内亚国家地区顶级域名。</p>
<h3 id="解析域名">解析域名</h3>
<p>虽然freenom自身也能进行DNS解析，但是毕竟不适合国内的朋友使用。所以我使用了国内的 <a href="https://www.cloudxns.net/">CloudXNS</a> ，需要实名认证。</p>
<h2 id="域名绑定page服务">域名绑定Page服务</h2>
<h3 id="添加纪录">添加纪录</h3>
<figure data-type="image" tabindex="1"><img src="https://dooyuu-1258391541.cos.ap-shanghai.myqcloud.com/%E7%AC%94%E8%AE%B0/QQ%E6%88%AA%E5%9B%BE20181227172233.png" alt="CloudXNS记录" loading="lazy"></figure>
<h3 id="配置page服务">配置Page服务</h3>
<p>在根目录下的sourse目录下新建文件CNAME，用Sublime打开填入刚获得的域名。<br>
然后用sublime打开站点配置文件，查找 skip_render ，改为</p>
<pre><code>skip_render:
  - README.md  
  - CNAME
</code></pre>
<p>这个指令可以防止每次hexo重新渲染把它们清除掉。这里的README.md可有可无，最好还是有，因为每个github项目都需要一个readme文件，添加位置和CNAME一样。</p>
<p>至此，这个个人博客就大致上完成了！</p>
<hr>
<h2 id="总结">总结</h2>
<p>摸索了一段时间才完成的，还是很有成就感的，比较遗憾的是并没有很好地记录下自己搭建这么一个网站的过程。以后会好好写博客的！</p>
]]></content>
    </entry>
</feed>