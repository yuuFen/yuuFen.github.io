<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yuufen.com/blog</id>
    <title>YuuFen</title>
    <updated>2020-04-26T18:30:21.529Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yuufen.com/blog"/>
    <link rel="self" href="https://yuufen.com/blog/atom.xml"/>
    <subtitle>希望你可以记住我</subtitle>
    <logo>https://yuufen.com/blog/images/avatar.png</logo>
    <icon>https://yuufen.com/blog/favicon.ico</icon>
    <rights>All rights reserved 2020, YuuFen</rights>
    <entry>
        <title type="html"><![CDATA[你好呀，陌生人]]></title>
        <id>https://yuufen.com/blog/post/about/</id>
        <link href="https://yuufen.com/blog/post/about/">
        </link>
        <updated>2024-02-28T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>因为笔记太多太杂，决定定期写写博客整理整理笔记。</p>
<p><s>然后因为各种原因失去了动力</s></p>
<p><s>因此搞丢了好多笔记啊啊啊啊啊啊啊😭😭😭</s></p>
<p><s>看了看一年前的博文发现自己真的变化了蛮多的（加油💪）</s></p>
<p>总之现在又开始了</p>
<h2 id="关于我">🐟 关于我</h2>
<p>我目前大二在读，我的职业规划是前端工程师，我的专业是电子信息，所以我还了解一些嵌入式开发（当然只是一些些），对Python和TensorFlow也有一定的涉猎。我正在努力寻找暑期实习！</p>
<p>在以下位置找到有关我的更多信息：</p>
<p><a href="https://yuufen.com/" target="_blank" class="text-button">主页</a><a href="https://yuufen.com/blog" target="_blank" class="text-button">博客</a><a href="https://github.com/yuuFen" target="_blank" class="text-button">项目</a><a href="mailto:me@yuufen.com" class="text-button">给我发邮件</a></p>
<h2 id="兴趣爱好">🎨 兴趣爱好</h2>
<p><strong>摄影</strong>、羽毛球、轮滑，and playing!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node 基础]]></title>
        <id>https://yuufen.com/blog/post/jAmCPqVpt/</id>
        <link href="https://yuufen.com/blog/post/jAmCPqVpt/">
        </link>
        <updated>2020-04-03T19:35:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="nodejs-是什么">NodeJS 是什么</h2>
<h3 id="nodejs-是一个异步的事件驱动的-javascript-运行时">node.js 是一个异步的事件驱动的 JavaScript 运行时。</h3>
<blockquote>
<ul>
<li>JRE 是 java 运行时环境</li>
<li>C Runtime</li>
<li>.NET Common Language Runtime</li>
</ul>
<p>运行时 runtime 就是程序运行过程中，</p>
<p>指的是指令加载到内存并由 CPU 执行的时候。</p>
<p>运行时库就是程序运行过程中所需要依赖的库。</p>
<p>C 代码编译成可执行文件的时候，指令没有被 CPU 执行，这个时候算是<strong>编译时</strong>。</p>
</blockquote>
<h3 id="nodejs-特性其实就是-js-特性">node.js 特性其实就是 JS 特性：</h3>
<ul>
<li>非阻塞 I/O</li>
<li>事件驱动</li>
</ul>
<h3 id="node-历史-为性能而生">node 历史 — 为性能而生</h3>
<blockquote>
<p>Ryan Dahl(Google Brain)，他的工作是用 C/C++ 写高性能 Web 服务。对于高性能，异步 IO、事件驱动是基本原则，但是用 C/C++ 来写就太痛苦了。于是他开始设想用高级语言开发 Web 服务。他评估了很多种高级原因，还想很多语言虽然同时提供了同步 IO 和异步 IO，但是开发人员一旦用了同步 IO，他们就再也懒得写异步 IO，所以最终 Ryan 瞄向了 JavaScript。</p>
<p>因为 JavaScript 是单线程执行，根本不能进行同步 IO 操作，所以 JavaScript 的这一&quot;缺陷&quot;导致了它只能使用异步IO。</p>
<p>选定了开发语言，还要有运行时环境，V8 就是开源的 JavaScript 引擎。于是在2009，Ryan 正式推出了基于 JavaScript 语言和 V8 引擎的开源 Web 服务器项目，命名为 Node.js。Node 第一次把 JavaScript 带入到后端服务器开发。</p>
</blockquote>
<h3 id="并发处理的更替">并发处理的更替</h3>
<ul>
<li>
<p>多进程 - Linux C / Apache</p>
<blockquote>
<p>进程的缺陷：</p>
<ul>
<li>创建和切换的时间和空间开销较大，且随着并发进程数量的提升，时间和空间的开销会逐渐增大，从而限制了系统的并发能力。</li>
<li>进程间的资源共享不方便</li>
</ul>
</blockquote>
</li>
<li>
<p>多线程 - Java</p>
</li>
<li>
<p>异步 I/O - JavaScript</p>
</li>
<li>
<p>协程 - Lua / OpenResty / Go / deno (go + TS)</p>
</li>
</ul>
<blockquote>
<p>deno</p>
<p><a href="https://studygolang.com/articles/13101"> https://studygolang.com/articles/13101 </a></p>
</blockquote>
<h3 id="与前端中-js-异同">与前端中 JS 异同</h3>
<ul>
<li>核心语法不变</li>
<li>前端：BOM / DOM</li>
<li>后端：fs / http / buffer / event / os</li>
</ul>
<h2 id="使用">使用</h2>
<h3 id="运行">运行</h3>
<p>每次修改 js 文件需重新执行才能生效，安装 nodemon 可以监视文件改动，自动重启：</p>
<pre><code>npm i -g nodemon
</code></pre>
<h3 id="调试">调试</h3>
<p>Debug - Start Debugging</p>
<blockquote>
<p>https://nodejs.org/en/</p>
</blockquote>
<h3 id="使用模块">使用模块</h3>
<ul>
<li>
<p>node 内建模块</p>
<pre><code class="language-js">// 内建模块直接引用
const os = require('os')
const mem = os.freemem() / os.totalmem() * 100
console.log(`内存占用率${mem.toFixed(2)}%`)
</code></pre>
</li>
<li>
<p>第三方模块</p>
<blockquote>
<p><a href="https://www.npmjs.com/">https://www.npmjs.com/</a></p>
</blockquote>
<pre><code class="language-js">// 同级 CPU 占用率，先安装
npm i download-git-repo -S
</code></pre>
<pre><code class="language-js">// 导入并使用
const download = require('download-git-repo')
const ora = require('ora')

const process = ora('下载中...')
process.start()

download('github:yuuFen/vue-template-for-cli-demo', '../test', (err) =&gt; {
  // console.log(err ? 'Error' : 'Success')
  if (err) {
    process.fail()
  } else {
    process.succeed()
  }
})
</code></pre>
</li>
<li>
<p>promisefy</p>
<blockquote>
<p>让异步任务串行化（要符合规范）</p>
</blockquote>
<pre><code class="language-js">const repo = 'github:yuuFen/vue-template-for-cli-demo'
const desc = '../test'
clone(repo, desc)

async function clone(repo, desc) {
  const { pormisify } = require('util')
  const download = promisify(require('download-git-repo'))
  const ora = require('ora')
  const process = ora('下载中...')
  process.start()
  try {
    await download(repo, desc)
  } catch (err) {
    process.fail()
  }
  process.succeed()
}
</code></pre>
</li>
<li>
<p>自定义模块</p>
<pre><code class="language-js">// download.js
// 可以作为导出对象的属性导出
module.exports.clone = async function clone(repo, desc) {
  const { pormisify } = require('util')
  const download = promisify(require('download-git-repo'))
  const ora = require('ora')
  const process = ora('下载中...')
  process.start()
  try {
    await download(repo, desc)
  } catch (err) {
    process.fail()
  }
  process.succeed()
}

// run
const { clone } = require('./download')
const repo = 'github:yuuFen/vue-template-for-cli-demo'
const desc = '../test'

clone(repo, desc)
</code></pre>
</li>
</ul>
<h2 id="api">API</h2>
<h3 id="fs">fs</h3>
<pre><code class="language-js">const fs = require('fs')

// 同步调用
const data = fs.readFileSync('./download.js')
// data 类型为 Buffer
console.log(data.toString())

// 异步
fs.readFile('./download.js', (err, data) =&gt; {
    if (err) throw err
    console.log(data.toString())
})

// fs 常搭配 path api 使用
const path = require('path')
fs.readFile(path.resolve(path.resolve(__dirname, './download.js')), (err, data) =&gt; {
    if (err) throw err
    console.log(data.toString())
})

// prromisify
const { promisify } = require('util')
const readFile = promisify(fs.readFile)
readFile('./download.js').then(data =&gt; console.log(data))

// fs Promises API node v10
const fsp = require('fs').promises
fsp
    .readFile('./download.js')
    .then(data =&gt; console.log(data))
	.catch(err =&gt; console.log(err))
</code></pre>
<h3 id="buffer">Buffer</h3>
<blockquote>
<p>用于在 TCP 流、文件系统操作、以及其他上下文中与八位字节流进行交互。 八位字节组成的数组，可以有效的在 JS 中存储二进制数据。</p>
</blockquote>
<pre><code class="language-js">// 创建一个长度为 10 字节以 0 填充的Buffer
const buf1 = Buffer.alloc(10)
console.log(buf1)

// 创建一个 Buffer 包含 ascii
const buf2 = Buffer.from('a')
console.log(buf2, buf2.toString())

// 创建 Buffer 包含 UTF-8 字节
// UFT-8：一种变长的编码方案，使用 1 ~ 6 个字节来存储
// UFT-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储
// UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变
const buf3 = Buffer.from('Buffer 创建方法')
console.log(buf3)

// 写入Buffer数据
buf1.write('hello')
console.log(buf1)

// 读取Buffer数据  
console.log(buf3.toString())  

// 合并Buffer  
const buf4 = Buffer.concat([buf1, buf3])
console.log(buf4.toString());
</code></pre>
<h3 id="http">http</h3>
<blockquote>
<p>用于创建 web 服务的模块</p>
</blockquote>
<ul>
<li>创建一个http服务器</li>
</ul>
<pre><code class="language-js">const http = require('http')
const server = http.createServer((request, response) =&gt; {
    // 打印一下 response 的原型链
    console.log(getPrototypeChain(response))
    // response 是一个 Steam
    response.end('a response from server')
})

server.listen(3000)


function getPrototypeChain(obj) {
    let prototypeChain = []
    while (obj = Object.getPrototypeOf(obj)) {
        prototypeChain.push(obj)
    }
    prototypeChain.push(null)
    return prototypeChain
}
</code></pre>
<p>显示首页 / 实现接口</p>
<pre><code class="language-js">const http = require('http')
const fs = require('fs')

const server = http.createServer((request, response) =&gt; {
  const { url, method } = request

  if (url === '/' &amp;&amp; method === 'GET') {
    fs.readFile('./index.html', (err, data) =&gt; {
      if (err) {
        response.writeHead(500, { 'Content-Type': 'text/plain;charset=utf-8' })
        response.end('500 服务端错误')
      }
      response.statusCode = 200
      response.setHeader('Content-Type', 'text/html')
      response.end(data)
    })
  } else if (url === '/users' &amp;&amp; method === 'GET') {
    response.setHeader('Content-Type', 'application/json')
    response.end(JSON.stringify({ name: 'name' }))
  } else {
    response.statusCode = 404
    response.setHeader('Content-Type', 'text/plain;charset=utf-8')
    response.end('404 页面不存在')
  }
})

server.listen(3000)
</code></pre>
<h3 id="stream">stream</h3>
<blockquote>
<p>用于与 node 中流数据交互的接口</p>
</blockquote>
<pre><code class="language-js">const fs = require('fs')

const rs = fs.createReadStream('./img1.png')
const ws = fs.createWriteStream('./img2.png')
// 在内存中以字节流动，防止传输大文件时内存占用过高
rs.pipe(ws)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1587322423228.png" alt="" loading="lazy"></figure>
<p>响应图片请求</p>
<pre><code class="language-js">const http = require('http')
const fs = require('fs')

const server = http.createServer((request, response) =&gt; {
  const { url, method, headers } = request

  if (url === '/' &amp;&amp; method === 'GET') {
    fs.readFile('./index.html', (err, data) =&gt; {
      if (err) {
        response.writeHead(500, { 'Content-Type': 'text/plain;charset=utf-8' })
        response.end('500 服务端错误')
      }
      response.statusCode = 200
      response.setHeader('Content-Type', 'text/html')
      response.end(data)
    })
  } else if (method === 'GET' &amp;&amp; headers.accept.indexOf('image/*') !== -1) {
    console.log(url) // '/img.png'
	// response 是 Stream
    fs.createReadStream('.' + url).pipe(response)
  }
})

server.listen(3000)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[虚拟 DOM 简单实现]]></title>
        <id>https://yuufen.com/blog/post/M0Xa7RsWm/</id>
        <link href="https://yuufen.com/blog/post/M0Xa7RsWm/">
        </link>
        <updated>2020-04-01T03:24:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="项目地址">项目地址</h2>
<p>https://github.com/yuuFen/Virtual-DOM</p>
<h2 id="为什么需要虚拟-dom">为什么需要虚拟 DOM</h2>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1586510765752.png" alt="" loading="lazy"></figure>
<p>真实 DOM 非常复杂，拥有许多属性，所以 DOM 的操作开销巨大，需要尽可能的少操作 DOM。</p>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1586523343141.png" alt="" loading="lazy"></figure>
<p>使用自定义的一个对象来描述 DOM，可以有效减少复杂度。</p>
<h2 id="创建虚拟-dom">创建虚拟 DOM</h2>
<pre><code class="language-js">let vnode = createElement('div', { id: 'test' }, [
    createElement('p', {}, ['节点1'])
])
console.log(JSON.stringify(vnode, null, 2))
</code></pre>
<pre><code class="language-js">function createElement(tag, data, children) {
  let flag
  if (typeof tag == 'string') {
    // 普通的 html 标签
    flag = vnodeType.HTML
  } else if (typeof tag == 'function') {
    flag = vnodeType.COMPONENT
  } else {
    flag = vnodeType.TEXT
  }

  let childrenFlag
  if (children == null) {
    childrenFlag = childrenType.EMPTY
  } else if (Array.isArray(children)) {
    let length = children.length
    if (length === 0) {
      childrenFlag = childrenType.SINGLE
    } else {
      childrenFlag = childrenType.MULTIPLE
    }
  } else {
    // 其他情况认为是文本
    childrenFlag = childrenType.SINGLE
    children = createTextVNode(children + '')
  }

  // 返回 vnode
  return {
    flag, // vnode 类型
    tag, // 标签类型 / 文本没有 tag / 组件的 tag 是函数
    data,
    children,
    childrenFlag,
  }
}

function createTextVNode(text) {
  return {
    flag: vnodeType.TEXT,
    tag: null,
    data: null,
    children: text,
    childrenFlag: childrenType.EMPTY,
  }
}
</code></pre>
<h2 id="渲染">渲染</h2>
<pre><code class="language-js">      let vnode = createElement('div', { id: 'test' }, [
        createElement('p', { key: 'a',style: { color: 'blue' } }, ['节点1']),
        createElement('p', { key: 'b', '@click': () =&gt; { alert('xx') } }, ['节点2']),
        createElement('p', { key: 'c', 'class': 'item-header' }, ['节点3']),
        createElement('p', { key: 'd' }, ['节点4']),
      ])

      render(vnode, document.getElementById('app'))
</code></pre>
<pre><code class="language-js">// 要渲染的 vnode、容器（父元素）
function render(vnode, container) {
  // 首次渲染
  mount(vnode, container)
}

// 首次挂载元素
function mount(vnode, container) {
  let { flag } = vnode
  if (flag == vnodeType.HTML) {
    // (应该使用对象实现，不然依赖有点乱)
    mountElement(vnode, container)
  } else if (flag == vnodeType.TEXT) {
    mountText(vnode, container)
  }
}

function mountElement(vnode, container) {
  let dom = document.createElement(vnode.tag)
  vnode.el = dom
  let { data, children, childrenFlag } = vnode

  // 挂载 key
  if (data) {
    for (let key in data) {
      patchData(dom, key, null, data[key])
    }
  }

  if (childrenFlag !== childrenType.EMPTY) {
    if (childrenFlag == childrenType.SINGLE) {
      mount(children, dom)
    } else if (childrenFlag == childrenType.MULTIPLE) {
      for (let i = 0; i &lt; children.length; i++) {
        mount(children[i], dom)
      }
    }
  }

  container.appendChild(dom)
}

function mountText(vnode, container) {
  let dom = document.createTextNode(vnode.children)
  vnode.el = dom
  container.appendChild(dom)
}

function patchData(el, key, prv, next) {
  switch (key) {
    case 'style':
      for (let key in next) {
        el.style[key] = next[key]
      }
      break
    case 'class':
      el.className = next
      break
    default:
      if (key[0] === '@') {
        if (next) {
          el.addEventListener(key.slice[1], next)
        }
      } else {
        el.setAttribute(key, next)
      }
      break
  }
}
</code></pre>
<h2 id="补丁">补丁</h2>
<pre><code class="language-js">function patch(prev, next, container) {
  const nextFlag = next.flag
  const prevFlag = prev.flag

  // 如 element 变为 text, 直接替换, 不管 children
  if (nextFlag !== prevFlag) {
    replaceVNode(prev, next, container)
  } else if (nextFlag == vnodeType.HTML) {
    patchElement(prev, next, container)
  } else if (nextFlag == vnodeType.TEXT) {
    patchText(prev, next, container)
  }
}

function patchElement(prev, next, container) {
  if (prev.tag !== next.tag) {
    replaceVNode(prev, next, container)
    return
  }
  const el = (next.el = prev.el)

  // patch data
  const prevData = prev.data
  const nextData = next.data
  if (nextData) {
    for (const key in nextData) {
      const prevVal = prevData[key]
      const nextVal = nextData[key]
      patchData(el, key, prevVal, nextVal)
    }
  }
  if (prevData) {
    for (const key in prevData) {
      const prevVal = prevData[key]
      if (prevVal &amp;&amp; !nextData.hasOwnProperty(key)) {
        patchData(el, key, prevVal, null)
      }
    }
  }

  // patch children
  patchChildren(prev.childrenFlag, next.childrenFlag, prev.children, next.children, el)
}

function patchChildren(prevChildrenFlag, nextChildrenFlag, prevChildren, nextChildren, container) {
  // 1. 老的是 单独的 / 空的 / 多个
  // 2. 新的是 单独的 / 空的 / 多个
  switch (prevChildrenFlag) {
    case childrenType.SINGLE:
      switch (nextChildrenFlag) {
        case childrenType.SINGLE:
          patch(prevChildren, nextChildren, container)
          break
        case childrenType.EMPTY:
          container.removeChild(prevChildren.el)
          break
        case childrenType.MULTIPLE:
          container.removeChild(prevChildren.el)
          for (let i = 0; i &lt; nextChildren.length; i++) {
            mount(nextChildren[i], container)
          }
          break
      }
      break

    case childrenType.EMPTY:
      switch (nextChildrenFlag) {
        case childrenType.SINGLE:
          mount(nextChildren, container)
          break
        case childrenType.EMPTY:
          break
        case childrenType.MULTIPLE:
          for (let i = 0; i &lt; nextChildren.length; i++) {
            mount(nextChildren[i], container)
          }
          break
      }
      break

    case childrenType.MULTIPLE:
      switch (nextChildrenFlag) {
        case childrenType.SINGLE:
          for (let i = 0; i &lt; prevChildren.length; i++) {
            container.removeChild(prevChildren[i].el)
          }
          mount(nextChildren, container)
          break
        case childrenType.EMPTY:
          for (let i = 0; i &lt; prevChildren.length; i++) {
            container.removeChild(prevChildren[i].el)
          }
          break
        case childrenType.MULTIPLE:
          // 众多虚拟 DOM 就在这里产生分歧，每家的优化策略不一样
          // 老：[abc] 新：[c**a**b**]
          // ab 不需要更改，只需要在 ab 之间或之前插入元素，或在最后新建元素
          let lastIndex = 0
          for (let i = 0; i &lt; nextChildren.length; i++) {
            let find = false
            const nextVNode = nextChildren[i]
            for (let j = 0; j &lt; prevChildren.length; j++) {
              const prevVNode = prevChildren[j]
              if (prevVNode.key === nextVNode.key) {
                find = true
                // 如果 key 相同，认为是同一个元素，补丁一下，不新建或销毁
                patch(prevVNode, nextVNode, container)
                if (j &lt; lastIndex) {
                  // 需要移动的情况
                  // lastIndex 指的是上一个找到的元素在 prevVNode 中的位置
                  // j 就是最新找到的元素在 prevVNode 中的位置
                  // 使用 insertBefore 移动元素
                  const flagNode = nextChildren[i - 1].el.nextSibling
                  container.insertBefore(prevVNode.el, flagNode)
                } else {
                  // 如果顺序正确，就更新末尾位置
                  lastIndex = j
                }
              }
            }
            if (!find) {
              // 需要新增
              const flagNode = i == 0 ? prevChildren[0].el : nextChildren[i - 1].el.nextSibling
              mount(nextVNode, container, flagNode)
            }
          }

          // 移除不需要的元素
          for (let i = 0; i &lt; prevChildren.length; i++) {
            const prevVNode = prevChildren[i]
            const has = nextChildren.find((next) =&gt; next.key === prevVNode.key)
            if (!has) {
              container.removeChild(prevVNode.el)
            }
          }
          break
      }
      break
  }
}

function patchText(prev, next, container) {
  const el = (next.el = prev.el)
  if (next.children !== prev.children) {
    el.nodeValue = next.children
  }
}

function patchData(el, key, prev, next) {
  switch (key) {
    case 'style':
      for (let key in next) {
        el.style[key] = next[key]
      }
      for (let key in prev) {
        if (!next || !next.hasOwnProperty(key)) {
          el.style[key] = ''
        }
      }

      break
    case 'class':
      el.className = next
      break
    default:
      if (key[0] === '@') {
        if (prev) {
          el.removeEventListener(key.slice(1), prev)
        }
        if (next) {
          el.addEventListener(key.slice(1), next)
        }
      } else {
        el.setAttribute(key, next)
      }
      break
  }
}

function replaceVNode(prev, next, container) {
  container.removeChild(prev.el)
  mount(next, container)
}
</code></pre>
<h2 id="vue-中的优化">Vue 中的优化</h2>
<p>对常见的修改：新增、删除、倒序排列做了特定优化，详细见之前文章。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实现简单的 SSR]]></title>
        <id>https://yuufen.com/blog/post/s-05vytU3/</id>
        <link href="https://yuufen.com/blog/post/s-05vytU3/">
        </link>
        <updated>2020-03-25T02:49:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="渲染服务器">渲染服务器</h2>
<p>server/index.js</p>
<pre><code class="language-js">const express = require('express')
const Vue = require('vue')
const fs = require('fs')

// 创建 express 实例
const app = express()

const { createBundleRenderer } = require('vue-server-renderer')

const bundle = require('../dist/server/vue-ssr-server-bundle.json')
const clientManifest = require('../dist/server/vue-ssr-client-bundle.json')
const renderer = createBundleRenderer(bundle, {
  runInNewContext: false,
  template: fs.readFileSync('./src/index.temp.html'),
  clientManifest: clientManifest,
})

function renderToString(context) {
  return new Promise((resolve, reject) =&gt; {
    renderer.renderToString(context, (err, html) =&gt; {
      if (err) {
        reject(err)
        return
      }
      resolve(html)
    })
  })
}

// // 创建 vue 实例
// const vm = new Vue({
//   data: { cnt: 1 },
//   template: `
//     &lt;div&gt;{{cnt}}&lt;/div&gt;
//   `,
// })

// 客户端部署静态文件
app.use(express.static('../dist/client'))
// 声明服务端路由
app.get('*', async function (req, res) {
  try {
    const context = {
      title: 'ssr test',
      url: req.url,
    }
    const html = await renderToString(context)
    res.send(html)
  } catch (err) {
    res.status(500).send('Internal Server Error')
  }
})

app.listen(3000, () =&gt; {
  console.log('渲染服务器启动成功')
})
</code></pre>
<h2 id="打包入口文件">打包入口文件</h2>
<h3 id="appjs">app.js</h3>
<pre><code class="language-js">// 通用：创建 Vue 实例

import Vue from 'vue'
import App from './App.vue'
import { createRouter } from './router'
import { createStore } from './store'

export function createApp(context) {
  const router = createRouter()
  const store = createStore()
  const app = new Vue({
    router,
    store,
    render: (h) =&gt; h(App),
  })
  return { app, router }
}
</code></pre>
<h3 id="entry-clientjs">entry-client.js</h3>
<pre><code class="language-js">import { createApp } from './app'

const { app, router } = createApp()

router.onReady(() =&gt; {
  // 挂载
  app.$mount('#app')
})
</code></pre>
<h3 id="entry-serverjs">entry-server.js</h3>
<pre><code class="language-js">import { createApp } from './app'

export default (context) =&gt; {
  // 返回 Promise，确保路由或组件准备就绪
  return new Promise((resolve, reject) =&gt; {
    // 创建 vue 实例
    const { app, router } = createApp(context)
    // 跳转首屏地址
    router.push(context.url)
    // 完成 promise
    router.onReady(() =&gt; {
      resolve(app)
    }, reject)
  })
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue + TS]]></title>
        <id>https://yuufen.com/blog/post/uhM7D6ItT/</id>
        <link href="https://yuufen.com/blog/post/uhM7D6ItT/">
        </link>
        <updated>2020-03-22T16:30:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="开始">开始</h2>
<h3 id="文档">文档</h3>
<p><a href="https://www.tslang.cn/docs/home.html">TypeScript参考</a></p>
<h3 id="引入-ts">引入 ts</h3>
<p>如果已存在项目，使用<code>vue add @vue/typescript</code>引入（注意：会造成破坏性更改） ，</p>
<p>否则直接使用 vue create 即可。</p>
<h2 id="特性">特性</h2>
<h3 id="类型注解和类型检查">类型注解和类型检查</h3>
<pre><code class="language-ts">let name = &quot;xx&quot;; // 类型推论
let title: string = &quot;xx&quot;; // 类型注解 
name = 2;// 错误
title = 4;// 错误

//数组使用类型
let names: string[]; names = ['Tom'];//或 Array&lt;string&gt;
let foo:any = 'xx' foo = 3

// any类型也可用于数组
let list: any[] = [1, true, &quot;free&quot;]; 
list[1] = 100;

// 函数中使用类型注解
function greeting(person: string): string {
    return 'Hello, ' + person;
}
function warnUser(): void {
    alert(&quot;This is my warning message&quot;);
}
</code></pre>
<p>Vue 组件中应用：</p>
<pre><code class="language-VUE">&lt;template&gt; 
	&lt;div&gt;  
		&lt;ul&gt;     
        	&lt;li v-for=&quot;feature in features&quot; :key=&quot;feature&quot;&gt;{{feature}}&lt;/li&gt;   
    	&lt;/ul&gt;  
    &lt;/div&gt; 
&lt;/template&gt;
&lt;script lang='ts'&gt; 
    import { Component, Prop, Vue } from &quot;vue-property-decorator&quot;;
    
	@Component 
    export default class Hello extends Vue {  
        features: string[];
    	constructor() {   
        	super();  
            this.features = [&quot;类型注解&quot;, &quot;编译型语⾔言&quot;]; 
        }
    }
&lt;/script&gt;
</code></pre>
<h2 id="函数">函数</h2>
<pre><code class="language-ts">// 此处 name 和 age 是必填参数 
// 如果要变为可选参数，加上？ 
function sayHello(name: string, age: number = 20, addr?: string): string {  
    return '你好：' + name + ' ' + age; 
}
// 重载 
// 参数数量或者类型
// 或返回类型不同
// 先声明，在实现 
function info(a: { name: string }): string;
function info(a: string): object;
function info(a: { name: string } | string): any {
    if (typeof a === &quot;object&quot;) { 
        return a.name; 
    } else {   
        return { name: a };    
    }
} 

console.log(info({ name: &quot;tom&quot; })); 
console.log(info(&quot;tom&quot;));
</code></pre>
<p>Vue 组件中应用：</p>
<pre><code class="language-vue">&lt;div&gt;  
    &lt;input type=&quot;text&quot; placeholder=&quot;输⼊入新特性&quot; @keyup.enter=&quot;addFeature&quot;&gt; 
&lt;/div&gt;
</code></pre>
<pre><code class="language-ts">// ⽣生命周期钩⼦子 
created(){}

// 普通⽅方法 
private addFeature(event: any) {
    console.log(event);   
    this.features.push(event.target.value);   
    event.target.value = ''; 
}
</code></pre>
<h2 id="类">类</h2>
<pre><code class="language-ts">class MyComp {
	private _foo: string  // 私有属性
    protected bar: string // 保护属性
    readonly baz = 'baz'  // 只读属性必须在声明时或构造函数里初始化
    
    // 构造函数：初始化成员变量
    // 参数加上修饰符，能够定义并初始化一个成员变量
    constructor(private tua = 'tua') {
        this._foo = 'foo'
        this.bar = 'bar'
    }
	
    private someMethod() {}
	
    // 存取器：存取数据时可添加额外逻辑，在 vue 中用作计算属性
    get foo() { return this._foo }
    set foo(val) {
        this._foo = val
    }
}
</code></pre>
<p>vue 组件中应用：声明自定义类型，约束数据结构</p>
<pre><code class="language-ts">// 定义一个特性类，拥有更多属性
class Feature {
    constructor(public id: number, public name: string) {}
}

// 可以对获取的数据类型做约束
@Component
export default class HelloWorld extends Vue {
    private features: Featurre[]
    
    constructor() {
        super()
        this.features = [
            { id: 1, name: '类型注解' },
            { id: 2, name: '编译型语言' },
        ]
    }
}
</code></pre>
<p>vue 组件中应用：利用 getter 设置计算属性</p>
<pre><code class="language-ts">get count() {
	return this.features.length
}
</code></pre>
<h3 id="class-是语法糖它指向的就是构造函数">class 是语法糖，它指向的就是构造函数</h3>
<pre><code class="language-ts">class Person { // 类指向构造函数
    constructor(name, age) { // constructor 是默认方法，new 实例时自动调用
        this.name = name // 属性声明在实例上，this 指向实例
        this.age = age
    }
    say() { // 方法会声明在原型上
        return this.name + &quot;，&quot; + this.age
    }
}

console.log(typeof Person) // function
console.log(Person === Person.prototype.constructor) // true
</code></pre>
<p>等效于：</p>
<pre><code class="language-ts">function Person(name, age) {
    this.name = name
    this.age = age
}

Person.prototype.say = function() {
    return this.name + &quot;，&quot; + this.age
}
</code></pre>
<h2 id="接口-interface">接口 interface</h2>
<p>仅定义结构，不负责实现</p>
<pre><code class="language-ts">interface Person {
    firstName: string;
    lastName: string;
    sayHello(): string; // 要求实现方法
}

// 实现接口
class Greeter implements Person {
    constructor(public firstName = '', public lastName = '') {}
    
    sayHello() {
        return 'Hello,' + this.firstName + this.lastName
    }
}

// 面向接口编程
function greeting(person: Person) {
    return person.sayHello()
}

// const user = {firstName: 'Jan', lastName = 'User'}
const user = new Greeter('Jane',User)
console.log(user)
console.log(greeting(user))
</code></pre>
<p>修改 Feature 为接口形式：</p>
<pre><code class="language-vue">&lt;script lang='ts'&gt;
interface Feature {
    id:number;
    name: string;
}
&lt;/script&gt;
</code></pre>
<h2 id="泛型-generics">泛型 Generics</h2>
<p>Generics 是指在定义函数、接口或类时，不预先指定 具体的类型，而是在使用的时候再指定类型的一种特性。</p>
<pre><code class="language-ts">// 定义泛型接口
interface Result&lt;T&gt; {
    ok: 0 | 1;
    data: T[];
}

// 定义泛型函数
function getData&lt;T&gt;(): Result&lt;T&gt; {
    const data: any[] = [
        { id: 1, name: '类型注解', version: '2.0' },
        { id: 2, name: '编译型语言'}
    ];
    return { ok: 1, data }
}

// 使用
this.features = getData&lt;Feature&gt;().data
</code></pre>
<p>Promise：</p>
<pre><code class="language-ts">// 泛型，返回 Promise
function getData&lt;T&gt;(): Promise&lt;Result&lt;T&gt;&gt; {
    const data: any[] = [
        { id: 1, name: '类型注解', version: '2.0' },
        { id: 2, name: '编译型语言'}
    ];
    return Promise.resolve&lt;Result&lt;T&gt;&gt;({ ok: 1, data })
}

// 使用
async created() {
	this.features = (await getData&lt;Feature&gt;()).data
}
</code></pre>
<h2 id="装饰器">装饰器</h2>
<p>装饰器实际上是<strong>工厂函数</strong>，通过定义劫持，能够对类及其方法、属性提供额外的扩展功能，传入一个对象，输出处理后的新对象。</p>
<h3 id="使用">使用</h3>
<pre><code class="language-ts">// 类装饰器
@Component
export default class Hello extends Vue {
    // 属性装饰器
    // !表示该属性一定会被赋值
    @Prop({required: true, type: String}) private msg!: string;
	
	// 函数装饰器
	// 如果 @Emit 不传参，被装饰函数名即事件名
	@Emit('add')
	private addFeature(event: any) {
        const feature = {
            name: event.target.value,
            id: this.features.length + 1,
            version: '1.0'
        }
        this.features.push(feature)
        event.target.value = feature
        
        return event.target.value
    }
}
</code></pre>
<h3 id="原理">原理</h3>
<p>装饰器为我们在类的声明及其成员上通过<strong>元编程语法添加标注</strong>提供了一种方式。</p>
<p>装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、访问符（getter、setter）、属性或参数上。装饰器使用<code>@expression</code>形式，<code>expression</code>求值后必须是一个函数，它会在运行时被调用，被装饰的声明信息作为参数传入。</p>
<h4 id="类装饰器">类装饰器</h4>
<p>类装饰器在类声明之前被声明（紧靠着类声明）。类装饰器应用于类构造函数，可以用来监视、修改或替换类定义。</p>
<pre><code class="language-ts">// 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。
function log(target: Function) {
  // target 是构造函数
  console.log(target === Foo); // true

  target.prototype.log = function() {
    console.log(this.bar)
  }
  // 如果装饰器返回一个值，它会使用提供的构造函数来替换类的声明
}

@log
class Foo { 
  bar = 'bar'
}

const foo = new Foo()
foo.log()
</code></pre>
<h4 id="方法装饰器">方法装饰器</h4>
<pre><code class="language-ts">// 方法装饰器   // 有bug？？？？？？？？？
function log(target: any, name: string, descriptor: any) {
  // target 是原型或构造函数，name 是方法名，descriptor 是属性描述符
  // 方法的定义方式：Object.defineProperty(target, name, descrriptor)
  console.log(target[name] === descriptor.value)
  // 这里通过修改 descriptor.value 扩展了 baz 方法
  const baz = descriptor.value // 保存原来的方法
  descriptor.value = function (val: string) {
    console.log('我被扩展了')
    baz(val)
  }
  return target
}

class Foo {
  @log
  baz(val: string) {
    console.log(val)
  }
}

const foo = new Foo()
foo.baz('bbb')
</code></pre>
<h4 id="属性装饰器">属性装饰器</h4>
<pre><code class="language-ts">// 属性装饰器
function mua(target, name) {
    // target 是原型或构造函数，name 是属性名
    console.log(target === Foo.prototype) // ture
    target[name] = 'mua'
}

class Foo {
    @mua mm!:string
}

const foo = new Foo()
console.log(foo.mm)
</code></pre>
<h3 id="component">@Component</h3>
<ul>
<li>目标：解析得到options</li>
</ul>
<pre><code class="language-ts">@Component({
	props: {
        mag: {
           type: String,
            default: ''
        }
    }
})
export default calss Decor extends Vue {
    // ...
}
</code></pre>
<ul>
<li>实现：工厂函数，生成装饰器</li>
</ul>
<pre><code class="language-ts">function Component(options: any) {
    return function(target: Function) {
		// 装饰的时候类还没有被实例化，只能访问类的原型对象和 description
        // 具体就去看源码吧
        
        return Vue.extend(options)
    }
}
</code></pre>
<h2 id="vuex-支持vuex-class">vuex 支持：vuex-class</h2>
<h3 id="安装">安装</h3>
<pre><code>npm i vuex-class -S
</code></pre>
<h3 id="定义">定义</h3>
<p>store.js</p>
<pre><code class="language-ts">export default new Vuex.Store({
    state: {
        features: ['类型检测', '预编译']
    },
    mutations: {
        addFeatureMutation(state: any, featureName: string) {
            state.features.push({ 
                id: state.features.length + 1, 
                name: featureName
            })
        }
    },
    actions: {
    	addFeatureAction({ commit }, featureName: string) {
            commit('addFeatureMutation', featureName)
        }
	}
})
</code></pre>
<h3 id="使用-2">使用</h3>
<p>Hello.vue</p>
<pre><code class="language-ts">import { State, Mutation, Action } from 'vuex-class'

@Component
export default Feature extends Vue {
    @State features!: string[];
    @Mutation addFeatureMutation;
    @Action addFeatureAction;
    
    private addFeature(event) {
        console.log(event);
        this.addFeatureAction(event.target.value);
        event.target.value = '';
    }
}
</code></pre>
<blockquote>
<p>复杂用例：<a href="https://github.com/ktsn/vuex-class">vuex-class</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nuxt 概览]]></title>
        <id>https://yuufen.com/blog/post/vY7s6sh95/</id>
        <link href="https://yuufen.com/blog/post/vY7s6sh95/">
        </link>
        <updated>2020-03-21T00:54:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="nuxt-渲染流程">nuxt 渲染流程</h2>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1585740512408.png" alt="" loading="lazy"></figure>
<h2 id="安装">安装</h2>
<pre><code>npx create-nuxt-app &lt;项目名&gt;
</code></pre>
<h2 id="路由自动生成">路由自动生成</h2>
<p>详见用例与文档</p>
<h3 id="动态路由">动态路由</h3>
<p>以下划线作为前缀的 .vue文件或目录会被定义为动态路由，如下面文件结构</p>
<pre><code>pages/ 
--| detail/ 
----| _id.vue
</code></pre>
<h3 id="嵌套路由">嵌套路由</h3>
<p>创建内嵌子路由，你需要添加一个 .vue 文件，同时添加一个与该文件同名的目录用来存放子视图组件。</p>
<p>构造文件结构如下：</p>
<pre><code>pages/ 
--| index/ 
----| _id.vue 
--| index.vue
</code></pre>
<h3 id="默认布局">默认布局</h3>
<p>添加路由导航，layouts/default.vue</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;nav&gt;
    &lt;nuxt-link to=&quot;/&quot;&gt;首页&lt;/nuxt-link&gt;
    &lt;!--别名：n-link，NLink，NuxtLink--&gt;   
    &lt;!-- no-prefetch 取消预加载的默认行为 --&gt;
    &lt;n-link to=&quot;/admin&quot; no-prefetch&gt;管理&lt;/n-link&gt;
    &lt;NLink to=&quot;/cart&quot;&gt;购物车&lt;/NLink&gt;
    &lt;nuxt /&gt;
  &lt;/nav&gt;
&lt;/template&gt;
</code></pre>
<p>禁用预加载： <code>&lt;n-link no-prefetch&gt;page not pre-fetched&lt;/n-link&gt;</code></p>
<h3 id="自定义布局">自定义布局</h3>
<p>创建空白布局页面 layouts/blank.vue ，用于login.vue</p>
<pre><code>&lt;template&gt;  
	&lt;div&gt;    
		&lt;nuxt /&gt;  
	&lt;/div&gt; 
&lt;/template&gt;
</code></pre>
<p>页面 pages/login.vue 使用自定义布局：</p>
<pre><code>export default {
	layout: 'blank'
}
</code></pre>
<h3 id="自定义错误页面">自定义错误页面</h3>
<p>创建layouts/error.vue</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;!-- 错误页 --&gt;
  &lt;div&gt;
    &lt;h1 v-if=&quot;error.statusCode === 404&quot;&gt;页面不存在&lt;/h1&gt;
    &lt;h1 v-else&gt;应用发生错误异常&lt;/h1&gt;
    &lt;p&gt;{{ error }}&lt;/p&gt;
    &lt;nuxt-link to=&quot;/&quot;&gt;首 页&lt;/nuxt-link&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  // 服务器会传递一个 error 对象
  props: [&quot;error&quot;],
  layout: &quot;blank&quot;
};
&lt;/script&gt;
</code></pre>
<h2 id="配置">配置</h2>
<p>页面组件就是 Vue 组件，只不过 Nuxt.js 为这些组件添加了一些特殊的配置项</p>
<h3 id="head">head</h3>
<p>给首页添加标题和 meta，index.vue</p>
<pre><code class="language-js">export default {
    head() {  
        return {   
            title: &quot;课程列列表&quot;,  
            meta: [{
                name: &quot;description&quot;, 
                hid: &quot;description&quot;, 
                content: &quot;set page meta&quot; 
            }], 
            link: [{ 
                rel: &quot;favicon&quot;, 
                href: &quot;favicon.ico&quot; 
            }],  
        }; 
    },
};
</code></pre>
<h3 id="异步数据获取">异步数据获取</h3>
<p><code>asyncData</code> 方法使得我们可以在设置组件数据之前异步获取和处理数据。</p>
<p>范例：获取商品数据</p>
<h4 id="接口准备">接口准备</h4>
<ul>
<li>
<p>安装依赖：<code>npm i koa-router koa-bodyparser -S</code></p>
</li>
<li>
<p>创建接口文件，server/api.js</p>
<pre><code class="language-js">const Koa = require('koa')
const app = new Koa()
const bodyparser = require('koa-bodyparser')
const router = require('koa-router'({ prefix: '/api' }))

// 设置 cookie 加密密钥
app.keys = ['some secret', 'another secret']

const goods = [
  { id: 1, text: '商品Ⅰ', price: 1000 },
  { id: 2, text: '商品2', price: 2000 },
]

router.get('/goods', (ctx) =&gt; {
  ctx.body = {
    ok: 1,
    goods,
  }
})

router.get('/detail', (ctx) =&gt; {
  ctx.body = {
    ok: 1,
    data: goods.find(good.id == ctx.query.id),
  }
})

router.post('/login', (ctx) =&gt; {
  const user = ctx.request.body
  if (user.username === 'jerry' &amp;&amp; user.password === '123') {
    // 将 token 存入 cookie
    const token = 'a mock token'
    ctx.cookies.set('token', token)
    ctx.body = { ok: 1, token }
  } else {
    ctx.body = { ok: 0 }
  }
})

// 解析 post 数据并注册路由
app.use(bodyparser())
app.user(router.routes())

app.listen(8080, () =&gt; console.log('api 服务器已启动'))
</code></pre>
</li>
</ul>
<h4 id="引入-axios">引入 axios</h4>
<p>安装 @nuxt/axios 模块：<code>npm install @nuxtjs/axios -S</code></p>
<p>配置 nuxt.config.js</p>
<pre><code class="language-js">modules: [   
    '@nuxtjs/axios', 
], 

axios: {    
    proxy: true
}, 
    
proxy: {    
    &quot;/api&quot;: &quot;http://localhost:8080&quot; 
}
</code></pre>
<h4 id="测试代码">测试代码</h4>
<p>index.vue</p>
<pre><code class="language-vue">&lt;script&gt; 
    export default {   
        async asyncData({ $axios, error }) {   
            const {ok, goods} = await $axios.$get(&quot;/api/goods&quot;); 
            if (ok) {          
                return { goods };     
            }        
            // 错误处理理      
            error({ statusCode: 400, message: &quot;数据查询失败&quot; }); 
        }, 
    } 
&lt;/script&gt;
</code></pre>
<h2 id="中间件">中间件</h2>
<p>中间件会在一个页面或一组页面渲染之前运行我们定义的函数，常用于权限控制、校验等任务。</p>
<h3 id="管理员保护页面">管理员保护页面</h3>
<ul>
<li>
<p>创建middleware/auth.js</p>
<pre><code class="language-js">export default function({ route, redirect, store }) {
  // 如果没有 token，则重定向到 login
  // vuex 存在浏览器的内存中，刷新后清空
  // 所以刷新时需要在服务端重新将 token 填充到 vuex 中（如果存在token）
  // 适合在 nuxtServerInit 钩子中完成上面这一步
  if (!store.state.user.token) {
    redirect(&quot;/login?redirect=&quot; + route.path);
  }
}
</code></pre>
</li>
<li>
<p>注册中间件，admin.vue</p>
<pre><code class="language-vue">&lt;script&gt;    
    export default { 
        middleware: ['auth'] 
    }
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h2 id="状态管理-vuex">状态管理 vuex</h2>
<p>应用根目录下如果存在 <code>store</code> 目录，Nuxt.js 将启用 vuex 状态数</p>
<h3 id="用户登录以及登录状态保存">用户登录以及登录状态保存</h3>
<ul>
<li>
<p>创建 store/user.js</p>
<pre><code class="language-js">export const state = () =&gt; ({
    token: '' 
});

export const mutations = {  
    init(state, token) { 
        state.token = token; 
    }
};

export const getters = { 
    isLogin(state) {  
        return !!state.token; 
    } 
};

export const actions = { 
    login({ commit, getters }, u) {  
        return this.$login(u).then(({ token }) =&gt; {  
            if (token) {     
                commit(&quot;SET_TOKEN&quot;, token);  
            }   
            return getters.isLogin; 
        });
    } 
};
</code></pre>
</li>
<li>
<p>使用</p>
</li>
</ul>
<pre><code class="language-ts">@state 
</code></pre>
<h3 id="nuxtserverinit-钩子">nuxtServerInit 钩子</h3>
<p>通过在 store 的根模块中定义 <code>nuxtServerInit</code> 方法，将服务端的一些数据传到客户端。</p>
<ul>
<li>安装依赖模块：<code>npm i cookie-universal-nuxt</code></li>
<li>注册：<code>modules: [&quot;cookie-universal-nuxt&quot;]</code></li>
</ul>
<p>登录状态初始化：store/index.js</p>
<pre><code class="language-js">export const actions = {  
    nuxtServerInit({ commit }, { app }) {   
        const token = app.$cookies.get(&quot;token&quot;); 
        if (token) {      
            console.log(&quot;nuxtServerInit: token:&quot;+token); 
            commit(&quot;user/SET_TOKEN&quot;, token);  
        }
    } 
};
</code></pre>
<h2 id="插件">插件</h2>
<p>Nuxt.js 会在运行应用之前执行插件函数，需要引入或设置 Vue 插件、自定义模块和第三方模块时特别有用。</p>
<h3 id="添加请求拦截器附加token">添加请求拦截器附加token</h3>
<ul>
<li>
<p>创建 plugins/interceptor.js</p>
<pre><code class="language-js">export default function({ $axios, store }) {  
    $axios.onRequest(config =&gt; {   
        if (store.state.user.token) {  
            config.headers.Authorization = &quot;Bearer &quot; + store.state.user.token;
        }    
        return config; 
    }); 
}
</code></pre>
</li>
<li>
<p>注册插件 nuxt.config.js</p>
<pre><code class="language-js">plugins: [&quot;@/plugins/interceptor&quot;]
</code></pre>
</li>
</ul>
<h2 id="部署">部署</h2>
<h3 id="服务端渲染应用部署">服务端渲染应用部署</h3>
<pre><code>npm run build
npm start
</code></pre>
<h3 id="静态应用部署">静态应用部署</h3>
<p>Nuxt.js 可依据路由配置将应用静态化，使得我们可以将应用部署至任意一个静态站点主机服务商。</p>
<pre><code>npm run generate
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 测试]]></title>
        <id>https://yuufen.com/blog/post/VkzI4KJ9x/</id>
        <link href="https://yuufen.com/blog/post/VkzI4KJ9x/">
        </link>
        <updated>2020-03-16T01:03:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="测试分类">测试分类</h2>
<ul>
<li>黑盒测试
<ul>
<li><strong>E2E 测试</strong>，设计 N 个用例，测试某个功能的正确性</li>
<li><strong>集成测试</strong>，集合多个测试过的单元一起测试</li>
</ul>
</li>
<li>白盒测试
<ul>
<li><strong>单元测试</strong>，如针对一些内部核心实现逻辑编写测试代码</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1584914075235.png" alt="" loading="lazy"></figure>
<h2 id="为什么要编写测试代码">为什么要编写测试代码</h2>
<ul>
<li>提供描述组件行为的文档</li>
<li>节省手动测试的时间</li>
<li>减少研发新特性时产生的 bug</li>
<li>改进设计</li>
<li>促进重构</li>
</ul>
<h2 id="准备工作">准备工作</h2>
<p>要完成测试任务，需要测试框架（运行测试代码，如 Mocha）、 断言库（编写测试代码，如 Chai）和编程框架特有的测试套件。Vue 中的组件等测试代码的编写需要 <a href="https://vue-test-utils.vuejs.org/zh/">vue-text-utils</a> 套件支持。</p>
<p>Jest 同时包含测试框架与断言库，所以演示代码使用 Jest，但是它们的语法基本一致。</p>
<h3 id="新建-vue-项目时集成">新建 vue 项目时集成</h3>
<p>选择特性 <code>Unit Testing</code> 和 <code>E2E Testing</code></p>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1584924220583.png" alt="" loading="lazy"></figure>
<p>单元测试解决方案选择 <code>Jest</code></p>
<figure data-type="image" tabindex="3"><img src="https://yuufen.com/blog/post-images/1584924289071.png" alt="" loading="lazy"></figure>
<p>端到端测试解决方案选择 <code>Cypress</code></p>
<figure data-type="image" tabindex="4"><img src="https://yuufen.com/blog/post-images/1584924306319.png" alt="" loading="lazy"></figure>
<h3 id="在已存在项目中集成">在已存在项目中集成</h3>
<p>运行 <code>vue add @vue/unit-jest</code> 和 <code>vue add @vue/e2e-cypress</code></p>
<h2 id="编写单元测试">编写单元测试</h2>
<p>单元测试（unit testing），是指对软件中最小可测试单元进行检查和验证。</p>
<ul>
<li>test/unit/demo.spec.js（<code>*.spec.js</code> 是命名规范）</li>
</ul>
<pre><code class="language-js">function add(num1, num2) {
  return num1 + num2
}

// 测试套件 test suite
describe('demo', () =&gt; {
  // 测试用例 test case
  it('测试 add 函数', () =&gt; {
    // 断言 assert
    expect(add(1,3)).toBe(3)
    expect(add('str',4)).toBe(5)
    expect(add(1,3)).toBe(4)
  })
}) 
</code></pre>
<ul>
<li><code>yarn test:unit</code></li>
</ul>
<h3 id="断言-api-简介">断言 API 简介</h3>
<ul>
<li>
<p><code>describe</code>：定义测试套件</p>
</li>
<li>
<p><code>it</code>：定义一个测试用例</p>
</li>
<li>
<p><code>expect</code>：断言的判断条件</p>
<blockquote>
<p><a href="https://jestjs.io/docs/zh-Hans/expect">更多断言 API</a></p>
</blockquote>
</li>
</ul>
<h3 id="测试-vue-组件">测试 Vue 组件</h3>
<ul>
<li>创建一个 vue 组件 components/testDemo.vue</li>
</ul>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;span&gt;{{ message }}&lt;/span&gt; &lt;button @click=&quot;changeMsg&quot;&gt;点击&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return { message: 'vue-text' }
  },
  created() {
    this.message = 'Demo'
  },
  methods: {
    changeMsg() {
      this.message = '按钮点击'
    },
  },
}
&lt;/script&gt;
</code></pre>
<ul>
<li>tests/unit/compDemo.spec.js</li>
</ul>
<pre><code class="language-js">import Vue from 'vue'
import TestDemo from '@/components/TestDemo.vue'

import { mount } from '@vue/test-utils'

describe('TestDemo', () =&gt; {
  // 原始写法：

  // 检查原始组件选项
  it('存在 created 生命周期', () =&gt; {
    expect(typeof TestDemo.created).toBe('function')
  })

  // 评估原始组件选项中的函数的结果
  it('初始 data 是 vue-text', () =&gt; {
    // 检查 data 函数存在性
    expect(typeof TestDemo.data).toBe('function')
    // 检查 data 返回的默认值
    const defaultData = TestDemo.data()
    expect(defaultData.message).toBe('Hello!')
  })

  it('mount 之后 data.message 是 Demo', () =&gt; {
    const vm = new Vue(TestDemo).$mount()
    expect(vm.message).toBe('Demo')
  })

  // 使用 vue test utils：
    
  it('按钮点击后', () =&gt; {
    // 挂载组件
    const wrapper = mount(TestDemo)
    // 查找元素，触发事件
    wrapper.find('button').trigger('click')
    // 测试数据变化
    expect(wrapper.vm.message).toBe('按钮点击')
    // 测试 html 渲染结果
    expect(wrapper.find('span').html()).toBe('&lt;span&gt;按钮点击&lt;/span&gt;')
    // 等效的方式
    expect(wrapper.find('span').text()).toBe('按钮点击')
  })
})
</code></pre>
<h3 id="测试覆盖率">测试覆盖率</h3>
<p>在jest.conﬁg.js中添加</p>
<pre><code class="language-js">module.exports = {
  collectCoverage: true,
  collectCoverageFrom: ['src/**/*.{js,vue}'],
}
</code></pre>
<p>执行 <code>yarn test:unit</code>，即可看到测试覆盖率：</p>
<figure data-type="image" tabindex="5"><img src="https://yuufen.com/blog/post-images/1585008205915.png" alt="" loading="lazy"></figure>
<blockquote>
<p><code>%Stmts</code> - 语句覆盖率（statement coverage）：是不是每个语句都执行了？<br>
<code>%Branch</code> - 分支覆盖率（branch coverage）：是不是每个 if 代码块都执行了？<br>
<code>%Funcs</code> - 函数覆盖率（function coverage）：是不是每个函数都调用过了？<br>
<code>%Lines</code> - 行覆盖率（line coverage）：是不是每一行都执行了？</p>
</blockquote>
<h3 id="e2e-测试">E2E 测试</h3>
<p>借用浏览器的能力，站在用户测试人员的角度，输入框，点击按钮等，完全模拟用户，这个和具体的框架关系不⼤，完全模拟浏览器行为。</p>
<ul>
<li>修改 tests/e2e/spec/test.js</li>
</ul>
<pre><code class="language-js">// https://docs.cypress.io/api/introduction/api.html
describe('端到端测试，抢测试⼈人员的饭碗', () =&gt; {
  it('先访问⼀一下', () =&gt; {
    cy.visit('/')
    // cy.contains('h1', 'Welcome to Your Vue.js App')
    cy.contains('span', 'Demo')
  })
})
</code></pre>
<p>测试未通过，因为没有使用 TestDemo.vue，修改 App.vue</p>
<pre><code class="language-vue">&lt;div id=&quot;app&quot;&gt;   
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; 
  &lt;test-demo&gt;&lt;/test-demo&gt; 
&lt;/div&gt;

import Kaikeba from './components/Kaikeba.vue' 
export default { 
  name: 'app', 
  components: { 
    HelloWorld,Kaikeba
  } 
}
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://yuufen.com/blog/post-images/1585012934606.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 中的数据交互]]></title>
        <id>https://yuufen.com/blog/post/LR9CET7_-/</id>
        <link href="https://yuufen.com/blog/post/LR9CET7_-/">
        </link>
        <updated>2020-03-14T19:13:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="封装-request-api">封装 request / api</h2>
<p>api service =&gt; request =&gt; local mock / easy-mock / service api</p>
<blockquote>
<p>主要问题分析：</p>
<ol>
<li>有时需要请求头、响应，进行统一预处理</li>
<li>请求不同数据源时 url 会变化，需要能根据环境自动修改url</li>
<li>可能出现的跨域问题</li>
</ol>
</blockquote>
<h3 id="srcutilsrequestjs">src/utils/request.js</h3>
<pre><code class="language-js">import axios from 'axios'
import { MessageBox, Message } from 'element-ui'
import store from '@/store'
import { getToken } from '@/utils/auth'

// 创建 axios 实例
const service = axios.create({
  baseURL: process.env.VUE_APP_BASE_API, // url 基础地址，解决不同数据源 url 变化问题
  // withCredentials: true, // 跨域时若要发送 cookie 需设置该项
  timeout: 5000, // 超时
})

// 请求拦截
service.interceptors.request.use(
  (config) =&gt; {
    // do something

    if (store.getters.token) {
      // 设置令牌请求头
      // 后端采用默认配置（规范: http://www.rfcreader.com/#rfc6750_line188）：
      config.headers['Authorization'] = 'Bearer' + getToken()
      // // 后端自定义如：
      // config.headers['x-token'] = getToken()
    }
    return config
  },
  (error) =&gt; {
    // 请求错误预处理
    // console.log(error) // for debug
    return Promise.reject(error)
  },
)

// 响应拦截
service.interceptors.response.use(
  // 通过自定义 code 判断响应状态，也可以通过 HTTP 状态码判定
  (response) =&gt; {
    // 仅返回数据部分
    const res = response.data
    // 使用自定义状态码判断错误：
    // code 不为 1 则判定为错误
    if (res.code !== 1) {
      Message({
        message: res.message || 'Error',
        type: 'error',
        duration: 5 * 1000,
      })

      // 假设：10008-非法令牌；10012-其他客户端已登录；10014-令牌过期
      if (res.code === 10008 || res.code === 10012 || res.code === 10014) {
        MessageBox.confirm('登陆状态异常，请重新登录', '确认登录信息', {
          confirmButtonText: '重新登陆',
          cancelButtonText: '取消',
          type: 'warning',
        }).then(() =&gt; {
          store.dispatch('user/resetToken').then(() =&gt; {
            location.reload()
          })
        })
      }
      return Promise.reject(new Error(res.message || 'Error'))
    } else {
      return res
    }
  },
  (error) =&gt; {
    // 使用错误码：
    Message({
      message: error.message,
      type: 'error',
      duration: 5 * 1000,
    })
  },
)

export default service
</code></pre>
<h3 id="srcapiuserjs">src/api/user.js</h3>
<pre><code class="language-js">import request from '@/utils/request'

export function login(data) {
  return request({
    url: '/user/login',
    methods: 'post',
    data,
  })
}

export function getInfo() {
  return request({
    url: '/user/info',
    methods: 'get',
  })
}
</code></pre>
<h3 id="srcstoreuserjs">src/store/user.js</h3>
<pre><code class="language-js">  getters: {
    roles: (state) =&gt; state.user.roles,
+   token: (state) =&gt; state.user.token,
    permission_routes: (state) =&gt; state.permission.routes,
  },
</code></pre>
<h3 id="srcstoreuserjs-2">src/store/user.js</h3>
<pre><code class="language-js">import { login, getInfo } from '@/api/user'

const actions = {
  // user login
  login({ commit }, userInfo) {
    // 调用接口，并处理结果，错误处理已拦截所以无需处理
    return login(userInfo).then((res) =&gt; {
      commit('SET_TOKEN', res.data)
      setToken(res.data)
    })
  },
  // get user info
  getInfo({ commit, state }) {
    return getInfo().then(({ data: roles }) =&gt; {
      commit('SET_ROLES', roles)
      return { roles }
    })
  },
</code></pre>
<h2 id="mock">mock</h2>
<h3 id="本地-mock">本地 mock</h3>
<p>vue.config.js</p>
<pre><code class="language-js">// 处理 post 请求参数
const bodyParser = require('body-parser')

// ...

module.exports = {
  publicPath: '/practice',
  devServer: {
    port,
    // 配置 mock 接口
    // app 是 express 的实例
    before: (app) =&gt; {
      // 注册中间件，处理 post 参数
      app.use(bodyParser.json())

      app.post('/dev-api/user/login', (req, res) =&gt; {
        const { username } = req.body

        if (username === 'admin' || username === 'jerry') {
          res.json({
            code: 1,
            data: username,
          })
        } else {
          res.json({
            code: 10204,
            message: '用户名或密码错误',
          })
        }
      })

      // get 之前需要一个中间件来判断 token 合法性，这里没写
      app.get('/dev-api/user/info', (req, res) =&gt; {
        const auth = req.headers['authorization']
        const roles = auth.split(' ')[1] === 'admin' ? ['admin'] : ['editor']
        res.json({
          code: 1,
          data: roles,
        })
      })
    },
  },
    
  // ...
</code></pre>
<h3 id="easy-mock">easy-mock</h3>
<p><a href="easy-mock.com">项目地址</a></p>
<h2 id="解决跨域">解决跨域</h2>
<blockquote>
<p>如果请求的接口在另一台服务器上，开发时则需要在本地设置代理服务器，避免跨域问题</p>
</blockquote>
<h3 id="配置代理-vueconfigjs">配置代理 vue.config.js</h3>
<pre><code class="language-js">const port = 7070
const title = 'Vue Learning Record'

const path = require('path')
// 将传入的相对路径转换为绝对路径，跨平台
function resolve(dir) {
  return path.join(__dirname, dir)
}

module.exports = {
  publicPath: '/practice',
  devServer: {
    port,
    // 如果请求的接口在另一台服务器上，开发时则需要设置代理避免跨域问题
    proxy: {
      // 代理 /dev-api/user/login 到 http://127.0.0.1:3000/user/login
      // 请求的还是 http://localhost:7070/..，之后的代理转发浏览器不可知
      // 代理转发发生在 before 之后，所以会被 before 拦截，所以这俩互斥 
      // 当使用绝对路径时，代理不生效
      [process.env.VUE_APP_BASE_API]: {
        target: `http://127.0.0.1:3000/`,
        changeOrigin: true,  
        pathRewrite: { // dev-api/user/login =&gt; /user/login
          ['^' + process.env.VUE_APP_BASE_API]: ''
        }
        
      }
    },
      
    // ..
</code></pre>
<h3 id="创建一个独立接口服务器~serverindexjs">创建一个独立接口服务器，~/server/index.js</h3>
<pre><code class="language-js">const express = require('express')
const app = express()
const bodyParser = require('body-parser')

app.use(bodyParser.json())
app.use(
  bodyParser.urlencoded({
    extended: true,
  }),
)

app.post('/user/login', (req, res) =&gt; {
  const { username } = req.body
  if (username === 'admin' || username === 'jerry') {
    res.json({
      code: 1,
      data: username,
    })
  } else {
    res.json({
      code: 10204,
      message: '⽤用户名或密码错误',
    })
  }
})

app.get('/user/info', (req, res) =&gt; {
  const roles = req.headers['authorization'].split(' ')[1] ? ['admin'] : ['editor']
  res.json({ code: 1, data: roles })
})

app.listen(3000)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态导航菜单组件]]></title>
        <id>https://yuufen.com/blog/post/SZ8FawuZz/</id>
        <link href="https://yuufen.com/blog/post/SZ8FawuZz/">
        </link>
        <updated>2020-03-13T20:50:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="简单实现">简单实现</h2>
<blockquote>
<p>也可以使用 name，但是容易造成冲突，并且 name 属性不必要</p>
</blockquote>
<ul>
<li>路由数据模板：</li>
</ul>
<pre><code class="language-js">export const constRoutes = [
  {
    path: '/login',
    component: () =&gt; import('@/views/Login'),
    hidden: true,
  },
  {
    path: '/',
    component: Layout,
    redirect: '/home',
    meta: {
      title: '主页',
    },
    children: [
      {
        path: 'home',
        component: () =&gt; import(/* webpackChunkName: &quot;home&quot; */ '@/views/Home'),
        name: 'Home',
        meta: {
          title: 'Home', // 导航菜单项标题
          icon: 'msg', // 导航菜单项图标
        },
      },
    ],
  },
]
</code></pre>
<ul>
<li>src/components/SideMenu/index.vue</li>
</ul>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;ul&gt;
      &lt;item
        class=&quot;item&quot;
        v-for=&quot;route in permission_routes&quot;
        :key=&quot;route.path&quot;
        :model=&quot;route&quot;
        :base-path=&quot;route.path&quot;
      &gt;&lt;/item&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Item from './Item'
import { mapGetters } from 'vuex'

export default {
  name: 'SideMenu',
  components: { Item },
  computed: {
    ...mapGetters(['permission_routes']),
  },
  mounted() {
    console.log(this.permission_routes)
  },
}
&lt;/script&gt;
</code></pre>
<ul>
<li>src/components/SideMenu/Item.vue</li>
</ul>
<pre><code class="language-vue">&lt;template&gt;
  &lt;!-- hidden 选项存在则不显示 --&gt;
  &lt;li v-if=&quot;!model.hidden&quot;&gt;
    &lt;div @click=&quot;toggle&quot;&gt;
      &lt;!-- 图标 --&gt;
      &lt;Icon v-if=&quot;model.meta &amp;&amp; model.meta.icon&quot; :icon-class=&quot;model.meta.icon&quot;&gt;&lt;/Icon&gt;
      &lt;!-- 标题 --&gt;
      &lt;span v-if=&quot;isFolder&quot;&gt;
        &lt;!-- 如果是父节点 --&gt;
        &lt;span v-if=&quot;model.meta &amp;&amp; model.meta.title&quot;&gt;
          {{ model.meta.title }}
        &lt;/span&gt;
        &lt;span&gt;{{ open ? '-' : '+' }}&lt;/span&gt;
      &lt;/span&gt;
      &lt;template v-else&gt;
        &lt;!-- 如果是叶子节点，渲染链接 --&gt;
        &lt;router-link v-if=&quot;model.meta &amp;&amp; model.meta.title&quot; :to=&quot;resolvePath(model.path)&quot;&gt;
          {{ model.meta.title }}
        &lt;/router-link&gt;
      &lt;/template&gt;
    &lt;/div&gt;

    &lt;!-- 子树，递归组件 --&gt;
    &lt;ul v-show=&quot;open&quot; v-if=&quot;isFolder&quot;&gt;
      &lt;Item
        class=&quot;item&quot;
        v-for=&quot;route in model.children&quot;
        :key=&quot;route.path&quot;
        :model=&quot;route&quot;
        :base-path=&quot;resolvePath(model.path)&quot;
      &gt;&lt;/Item&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/template&gt;

&lt;script&gt;
import path from 'path'

export default {
  name: 'Item',
  props: {
    model: Object,
    basePath: {
      tpye: String,
      default: '',
    },
  },
  data() {
    return {
      open: false,
    }
  },
  computed: {
    // 判断是否有子树
    isFolder: function() {
      return this.model.children &amp;&amp; this.model.children.length
    },
  },
  methods: {
    // 考虑跨平台，拼接父 path 和子 path 为完整 path
    resolvePath(routePath) {
      return path.resolve(this.basePath, routePath)
    },
    toggle() {
      if (this.isFolder) {
        this.open = !this.open
      }
    },
  },
}
&lt;/script&gt;
</code></pre>
<ul>
<li>src/layout/index.js</li>
</ul>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;app-wrapper&quot;&gt;
    &lt;!-- &lt;sidebar class=&quot;sidebar-container&quot; /&gt; --&gt;
    &lt;SideMenu&gt;&lt;/SideMenu&gt;
    &lt;div class=&quot;main-container&quot;&gt;
      &lt;router-view /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import SideMenu from '@/components/SideMenu'
export default {
  components: { SideMenu },
}
&lt;/script&gt;
</code></pre>
<ul>
<li>src/store/index.js</li>
</ul>
<pre><code class="language-js">  getters: {
    roles: (state) =&gt; state.user.roles,
+   permission_routes: (state) =&gt; state.permission.routes,
  },
</code></pre>
<h2 id="扩展">扩展</h2>
<ul>
<li>components/Sidebar/index.vue</li>
</ul>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;el-scrollbar wrap-class=&quot;scrollbar-wrapper&quot;&gt;
      &lt;el-menu
        :default-active=&quot;activeMenu&quot;
        :background-color=&quot;variables.menuBg&quot;
        :text-color=&quot;variables.menuText&quot;
        :unique-opened=&quot;false&quot;
        :active-text-color=&quot;variables.menuActiveText&quot;
        :collapse-transition=&quot;false&quot;
        mode=&quot;vertical&quot;
      &gt;
        &lt;sidebar-item v-for=&quot;route in permission_routes&quot; :key=&quot;route.path&quot; :item=&quot;route&quot; :base-path=&quot;route.path&quot; /&gt;
      &lt;/el-menu&gt;
    &lt;/el-scrollbar&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import { mapGetters } from 'vuex'
import SidebarItem from './SidebarItem'
export default {
  components: { SidebarItem },
  computed: {
    ...mapGetters(['permission_routes']),
    activeMenu() {
      const route = this.$route
      const { meta, path } = route
      // 默认激活项
      if (meta.activeMenu) {
        return meta.activeMenu
      }
      return path
    },
    variables() {
      return { menuText: '#bfcbd9', menuActiveText: '#409EFF', menuBg: '#304156' }
    },
  },
}
&lt;/script&gt;
</code></pre>
<ul>
<li>layout/components/Sidebar/SidebarItem.vue</li>
</ul>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div v-if=&quot;!item.hidden&quot; class=&quot;menu-wrapper&quot;&gt;
    &lt;template
      v-if=&quot;
        hasOneShowingChild(item.children, item) &amp;&amp;
          (!onlyOneChild.children || onlyOneChild.noShowingChildren) &amp;&amp;
          !item.alwaysShow
      &quot;
    &gt;
      &lt;router-link v-if=&quot;onlyOneChild.meta&quot; :to=&quot;resolvePath(onlyOneChild.path)&quot;&gt;
        &lt;el-menu-item :index=&quot;resolvePath(onlyOneChild.path)&quot; :class=&quot;{ 'submenu-title-noDropdown': !isNest }&quot;&gt;
          &lt;item :icon=&quot;onlyOneChild.meta.icon || (item.meta &amp;&amp; item.meta.icon)&quot; :title=&quot;onlyOneChild.meta.title&quot; /&gt;
        &lt;/el-menu-item&gt;
      &lt;/router-link&gt;
    &lt;/template&gt;
    &lt;el-submenu v-else ref=&quot;subMenu&quot; :index=&quot;resolvePath(item.path)&quot; popperappend-to-body&gt;
      &lt;template v-slot:title&gt;
        &lt;item v-if=&quot;item.meta&quot; :icon=&quot;item.meta &amp;&amp; item.meta.icon&quot; :title=&quot;item.meta.title&quot; /&gt;
      &lt;/template&gt;
      &lt;sidebar-item
        v-for=&quot;child in item.children&quot;
        :key=&quot;child.path&quot;
        :is-nest=&quot;true&quot;
        :item=&quot;child&quot;
        :base-path=&quot;resolvePath(child.path)&quot;
        class=&quot;nest-menu&quot;
      /&gt;
    &lt;/el-submenu&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import path from 'path'
import Item from './Item'
export default {
  name: 'SidebarItem',
  components: { Item },
  props: {
    item: { type: Object, required: true },
    isNest: { type: Boolean, default: false },
    basePath: { type: String, default: '' },
  },
  data() {
    this.onlyOneChild = null
    return {}
  },
  methods: {
    hasOneShowingChild(children = [], parent) {
      const showingChildren = children.filter((item) =&gt; {
        if (item.hidden) {
          return false
        } else {
          // 如果只有一个子菜单
          this.onlyOneChild = item
          return true
        }
      })
      // 如果只有一个子路由，则不显示父级
      if (showingChildren.length === 1) {
        return true
      }
      // 否则显示父级
      if (showingChildren.length === 0) {
        this.onlyOneChild = { ...parent, path: '', noShowingChildren: true }
        return true
      }
      return false
    },
    resolvePath(routePath) {
      return path.resolve(this.basePath, routePath)
    },
  },
}
&lt;/script&gt;

</code></pre>
<ul>
<li>layout/components/Sidebar/Item.vue</li>
</ul>
<pre><code class="language-vue">&lt;script&gt;
export default {
  name: 'MenuItem',
  functional: true,
  props: {
    icon: {
      type: String,
      default: '',
    },
    title: {
      type: String,
      default: '',
    },
  },
  render(h, context) {
    const { icon, title } = context.props
    const vnodes = []
    if (icon) {
      vnodes.push(&lt;Icon icon-class={icon} /&gt;)
    }
    if (title) {
      vnodes.push(&lt;span slot=&quot;title&quot;&gt;{title}&lt;/span&gt;)
    }
    return vnodes
  },
}
&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 中的权限控制]]></title>
        <id>https://yuufen.com/blog/post/Xoj8uZb5R/</id>
        <link href="https://yuufen.com/blog/post/Xoj8uZb5R/">
        </link>
        <updated>2020-03-13T20:40:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="路由权限控制">路由权限控制</h2>
<h3 id="1-架构">1. 架构</h3>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1584603744487.png" alt="" loading="lazy"></figure>
<h3 id="2-定义路由">2. 定义路由</h3>
<pre><code class="language-js">// src/router/index.js
import Vue from 'vue'
import Router from 'vue-router'

import Layout from '@/layout'

Vue.use(Router)

// 静态部分 通用部分
export const constRoutes = [
  {
    path: '/login',
    component: () =&gt; import('@/views/Login'),
    hidden: true,
  },
  {
    path: '/',
    component: Layout,
    redirect: '/home',
    children: [
      {
        path: 'home',
        component: () =&gt; import(/* webpackChunkName: &quot;home&quot; */ '@/views/Home'),
        name: 'Home',
        meta: {
          title: 'Home', // 导航菜单项标题
          icon: 'msg', // 导航菜单项图标
        },
      },
    ],
  },
]

export const asyncRoutes = [
  {
    path: '/about',
    component: Layout,
    redirect: '/about/index',
    children: [
      {
        path: 'index',
        component: () =&gt; import(/* webpackChunkName: &quot;home&quot; */ '@/views/About.vue'),
        name: 'about',
        meta: {
          title: 'About',
          icon: 'img',
          // 角色
          role: ['admin', 'editor'],
        },
      },
    ],
  },
]

export default new Router({
  mode: 'history',
  base: process.env.BASE_URL,
  routes: constRoutes,
})
</code></pre>
<h3 id="3-路由守卫完成动态生成路由登录的逻辑">3. 路由守卫：完成动态生成路由（登录）的逻辑</h3>
<pre><code class="language-js">// src/permission.js
// 生成全局路由
import router from './router'
import store from './store'
import { getToken } from '@/utils/auth' // 从 cookie 中获取 token

const whiteList = ['/login']

router.beforeEach(async (to, from, next) =&gt; {
  const hasToken = getToken()
  if (hasToken) {
    if (to.path === '/login') {
      next({ path: '/home' })
    } else {
      // 已登录，获取用户角色
      const hasRoles = store.getters.roles &amp;&amp; store.getters.roles.length &gt; 0

      if (hasRoles) {
        next()
      } else {
        // 这样会阻塞配置里的重定向
        // 先请求用户信息
        const { roles } = await store.dispatch('user/getInfo')
        // 根据角色生成动态路由
        const accessedRoutes = await store.dispatch('permission/generateRoutes', roles)
        // 添加至 router
        router.addRoutes(accessedRoutes)
        // 重定向
        next()
      }
    }
  } else {
    if (whiteList.indexOf(to.path) !== -1) {
      next()
    } else {
      next(`/login?redirect=${to.path}`)
    }
  }
})

</code></pre>
<h3 id="4-具体实现">4. 具体实现</h3>
<ul>
<li>src/utils/auth</li>
</ul>
<pre><code class="language-js">import Cookies from 'js-cookie'

const TOKEN = 'token'

export function getToken() {
  return Cookies.get(TOKEN)
}

export function setToken(token) {
  return Cookies.set(TOKEN,token)
}
export function removeToken() {
  return Cookies.remove(TOKEN)
}
</code></pre>
<ul>
<li>src/store/user.js</li>
</ul>
<pre><code class="language-js">// 用户信息
import { getToken, setToken, removeToken } from '@/utils/auth'

const state = {
  token: getToken(),
  roles: [],
}

const mutations = {
  SET_TOKEN: (state, token) =&gt; {
    state.token = token
  },
  SET_ROLES: (state, roles) =&gt; {
    state.roles = roles
  },
}

const actions = {
  // user login
  login({ commit }, userInfo) {
    const { username } = userInfo
    return new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        if (username === 'admin' || username === 'jerry') {
          commit('SET_TOKEN', username)
          setToken(username)
          resolve()
        } else {
          reject('用户名不存在')
        }
      }, 1000)
    })
  },
  // get user info
  getInfo({ commit, state }) {
    return new Promise((resolve) =&gt; {
      setTimeout(() =&gt; {
        const roles = state.token === 'admin' ? ['admin'] : ['editor']
        commit('SET_ROLES', roles)
        resolve({ roles })
      }, 1000)
    })
  },

  // remove token
  resetToken({ commit }) {
    return new Promise((resolve) =&gt; {
      commit('SET_TOKEN', '')
      commit('SET_ROLES', [])
      removeToken()
      resolve()
    })
  },
}
export default {
  namespaced: true,
  state,
  mutations,
  actions,
}
</code></pre>
<ul>
<li>src/store/permission.js</li>
</ul>
<pre><code class="language-js">// 路由配置信息、路由生成逻辑
import { constRoutes, asyncRoutes } from '@/router'

/**
 * 根据路由 meta.role 确定当前用户是否具有访问权限
 * @roles 用户的拥有角色
 * @route 待判断路由
 */
function hasPermission(roles, route) {
  if (route.meta &amp;&amp; route.meta.roles) {
    // 如果当前路由有 roles 字段，则需要判断用户权限
    return roles.some((role) =&gt; route.meta.roles.includes(role))
  } else {
    return true
  }
}

/**
 * 递归过滤 AsyncRoutes 路由表
 * @roles 用户拥有的角色
 * @routes 待过滤路由表， 首次传入的就是 AsyncRoutes
 */
export function filterAsyncRoutes(roles, routes) {
  const res = []
  routes.forEach((route) =&gt; {
    // 复制一份
    const tmp = { ...route }
    // 如果用户有访问权限则加入结果路由表
    if (hasPermission(roles, tmp)) {
      // 如果存在子路由则递归过滤
      if (tmp.children) {
        tmp.children = filterAsyncRoutes(roles, tmp.children)
      }
      res.push(tmp)
    }
  })
  return res
}

const state = {
  // 完整路由
  routes: [],
  // 能够访问的动态路由
  addRoutes: [],
}

const mutations = {
  SET_ROUTES: (state, routes) =&gt; {
    state.addRoutes = routes
    state.routes = constRoutes.concat(routes)
  },
}

const actions = {
  // 生成路由，在得到用户角色后会第一时间调用
  generateRoutes({ commit }, roles) {
    return new Promise((resolve) =&gt; {
      let accessedRoutes
      if (roles.includes('admin')) {
        // 如果是管理员，有全部权限
        accessedRoutes = asyncRoutes || []
      } else {
        // 否则过滤
        accessedRoutes = filterAsyncRoutes(roles, asyncRoutes)
      }
      commit('SET_ROUTES', accessedRoutes)
      resolve(accessedRoutes)
    })
  },
}

export default {
  namespaced: true,
  state,
  mutations,
  actions,
}
</code></pre>
<ul>
<li>src/store/index.js</li>
</ul>
<pre><code class="language-js">import Vue from 'vue'
import Vuex from 'vuex'

import permission from './permission'
import user from './user'

Vue.use(Vuex)

export default new Vuex.Store({
  modules: {
    permission, // 权限
    user, // 用户信息
  },
  getters: {
    roles: (state) =&gt; state.user.roles,  
  },
})
</code></pre>
<ul>
<li>登录</li>
</ul>
<pre><code class="language-js">    login() {
      this.$store
        .dispatch('user/login', { username: this.username })
        .then(() =&gt; {
          this.$router.push({
            path: this.$route.query.redirect || '/',
          })
        })
        .catch((error) =&gt; {
          alert(error)
        })
    },
</code></pre>
<blockquote>
<p>如果路由来自后端：</p>
<pre><code class="language-js">// 前端组件名和组件的映射表
const map = {
    // login: require('login/index').default // 同步
    login: () =&gt; import('login/index')       // 异步
}
// 服务端返回的 map 类似于
const serviceMap = [
    {path: '/login', component: 'login', hidden: true},
]
// 遍历 serviceMap，将 component 替换为 map[component]，动态生成 asyncRoutes
function mapComponent(route) {
    route.component = map[route.component]
    if(route.children) {
		route.children = route.children.map(child =&gt; mapComponent(child))
    }
    return route
}
</code></pre>
</blockquote>
<h2 id="组件权限控制指令">组件权限控制：指令</h2>
<ul>
<li>使用</li>
</ul>
<pre><code class="language-html">    &lt;button v-permission=&quot;['admin', 'editor']&quot;&gt;editor button&lt;/button&gt;
    &lt;button v-permission=&quot;['admin']&quot;&gt;admin button&lt;/button&gt;
</code></pre>
<ul>
<li>src/directive/permission.js</li>
</ul>
<pre><code class="language-js">// v-permission=&quot;[]&quot;
// 完成一个指令，通过传递进来的权限数组和当前用户的角色数组进行过滤
// 如果用户拥有要求的角色，则可以看到

import store from '@/store'

// 否则删除指令挂钩 DOM 元素
export default {
  // el 挂载的dom
  // binding 绑定的数组
  inserted(el, binding) {
    // 获取值
    const { value: permissionRoles } = binding
    console.log(binding)
    // 获取用户角色
    const roles = store.getters.roles
    // 合法性判断
    if (permissionRoles &amp;&amp; permissionRoles instanceof Array &amp;&amp; permissionRoles.length &gt; 0) {
      // 判断用户角色中是否有符合要求的
      const hasPermission = roles.some((role) =&gt; {
        return permissionRoles.includes(role)
      })
      // 如果没有权限，则删除当前 DOM
      if (!hasPermission) {
        el.parentNode &amp;&amp; el.parentNode.removeChild(el)
      }
    } else {
      throw new Error('v-permission 接收数组类型 value')
    }
  },
}

</code></pre>
<ul>
<li>main.js</li>
</ul>
<pre><code class="language-js">// 注册指令
import permission from '@/directive/permission'
Vue.directive('permission', permission)
</code></pre>
<blockquote>
<p>该指令只能删除挂载指令的元素，其他的相关元素不能查找到，如 el-tabs&gt;el-tab-pane</p>
<p>此时只能用 v-if 实现，如 <code>v-if=&quot;checkPermission(['admin'])&quot;</code></p>
<p>v-if 在编译过程就会体现，所以如果没有权限根本不会被渲染，就用不着去删除了</p>
</blockquote>
]]></content>
    </entry>
</feed>