<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yuufen.com/blog</id>
    <title>YuuFen</title>
    <updated>2020-03-19T20:34:20.082Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yuufen.com/blog"/>
    <link rel="self" href="https://yuufen.com/blog/atom.xml"/>
    <subtitle>å¸Œæœ›ä½ å¯ä»¥è®°ä½æˆ‘</subtitle>
    <logo>https://yuufen.com/blog/images/avatar.png</logo>
    <icon>https://yuufen.com/blog/favicon.ico</icon>
    <rights>All rights reserved 2020, YuuFen</rights>
    <entry>
        <title type="html"><![CDATA[ä½ å¥½å‘€ï¼Œé™Œç”Ÿäºº]]></title>
        <id>https://yuufen.com/blog/post/about/</id>
        <link href="https://yuufen.com/blog/post/about/">
        </link>
        <updated>2024-02-28T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>æ¬¢è¿æ¥åˆ°æˆ‘çš„å°ç«™å‘€ï¼Œå¾ˆé«˜å…´é‡è§ä½ ï¼ğŸ¤</p>
</blockquote>
<h2 id="å…³äºæœ¬ç«™">ğŸ  å…³äºæœ¬ç«™</h2>
<p>å› ä¸ºç¬”è®°å¤ªå¤šå¤ªæ‚ï¼Œå†³å®šå®šæœŸå†™å†™åšå®¢æ•´ç†æ•´ç†ç¬”è®°ã€‚</p>
<p><s>ç„¶åå› ä¸ºå„ç§åŸå› å¤±å»äº†åŠ¨åŠ›</s></p>
<p><s>å› æ­¤æä¸¢äº†å¥½å¤šç¬”è®°å•Šå•Šå•Šå•Šå•Šå•Šå•ŠğŸ˜­ğŸ˜­ğŸ˜­</s></p>
<p><s>çœ‹äº†çœ‹ä¸€å¹´å‰çš„åšæ–‡å‘ç°è‡ªå·±çœŸçš„å˜åŒ–äº†è›®å¤šçš„ï¼ˆåŠ æ²¹ğŸ’ªï¼‰</s></p>
<p>æ€»ä¹‹ç°åœ¨åˆå¼€å§‹äº†</p>
<h2 id="å…³äºæˆ‘">ğŸŸ å…³äºæˆ‘</h2>
<p>æˆ‘ç›®å‰å¤§äºŒåœ¨è¯»ï¼Œæˆ‘çš„èŒä¸šè§„åˆ’æ˜¯å‰ç«¯å·¥ç¨‹å¸ˆï¼Œæˆ‘çš„ä¸“ä¸šæ˜¯ç”µå­ä¿¡æ¯ï¼Œæ‰€ä»¥æˆ‘è¿˜äº†è§£ä¸€äº›åµŒå…¥å¼å¼€å‘ï¼ˆå½“ç„¶åªæ˜¯ä¸€äº›äº›ï¼‰ï¼Œå¯¹Pythonå’ŒTensorFlowä¹Ÿæœ‰ä¸€å®šçš„æ¶‰çŒã€‚æˆ‘æ­£åœ¨åŠªåŠ›å¯»æ‰¾æš‘æœŸå®ä¹ ï¼</p>
<p>åœ¨ä»¥ä¸‹ä½ç½®æ‰¾åˆ°æœ‰å…³æˆ‘çš„æ›´å¤šä¿¡æ¯ï¼š</p>
<p><a href="https://yuufen.com/" target="_blank" class="text-button">ä¸»é¡µ</a><a href="https://yuufen.com/blog" target="_blank" class="text-button">åšå®¢</a><a href="https://github.com/yuuFen" target="_blank" class="text-button">é¡¹ç›®</a><a href="mailto:me@yuufen.com" class="text-button">ç»™æˆ‘å‘é‚®ä»¶</a></p>
<h2 id="å…´è¶£çˆ±å¥½">ğŸ¨ å…´è¶£çˆ±å¥½</h2>
<p><strong>æ‘„å½±</strong>ã€ç¾½æ¯›çƒã€è½®æ»‘ï¼Œand playing!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[è¯­å½• æ‘˜æŠ„]]></title>
        <id>https://yuufen.com/blog/post/m2rntOl9f/</id>
        <link href="https://yuufen.com/blog/post/m2rntOl9f/">
        </link>
        <updated>2022-03-30T21:19:42.000Z</updated>
        <content type="html"><![CDATA[<p>è™½ç„¶éšç€ Vueã€Reactã€Angular è¿™äº›æ¡†æ¶çš„æµï¨ˆï¼Œé›…è™å†›è§„å½“ä¸­ä¸€äº›ä¼˜åŒ–çš„æ–¹æ³•å·²ï¥§åœ¨é€‚ç”¨ï¼Œä½†æ˜¯ï¼Œï¤å¤šçš„æ—¶å€™ï¼Œæˆ‘ä»¬æ˜¯å­¦ä¹ è¿™äº›æ–¹æ³•èƒŒåçš„æ€æƒ³ï¼Œè€Œï¥§æ˜¯å»æ­»è®°ç¡¬èƒŒæŸä¸ªæ–¹æ³•ï¼ŒæŠ€æœ¯æ€»æ˜¯åœ¨ï¤è¿­ï¼Œåªæœ‰æ¡æ–¹æ³•èƒŒåçš„æ€æƒ³ï¼Œæ‰èƒ½å¤Ÿç«‹äºï¥§è´¥ä¹‹åœ°ã€‚</p>
<p>actionsåœ¨Vuexä¸­æ˜¯å¼‚æ­¥çš„ã€‚è®©è°ƒç”¨å‡½æ•°ï¼ˆåŠ¨ä½œçš„å‘èµ·è€…ï¼‰çŸ¥é“æŸä¸ªåŠ¨ä½œå·²å®Œæˆçš„å”¯ä¸€æ–¹æ³•æ˜¯é€šè¿‡è¿”å›Promiseå¹¶åœ¨ä»¥åè§£å†³å®ƒã€‚</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[è™šæ‹Ÿ DOM æ·±å…¥ä¸ç®€å•å®ç°]]></title>
        <id>https://yuufen.com/blog/post/M0Xa7RsWm/</id>
        <link href="https://yuufen.com/blog/post/M0Xa7RsWm/">
        </link>
        <updated>2020-03-18T03:24:31.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue å®è·µæ€»ç»“]]></title>
        <id>https://yuufen.com/blog/post/pXhlFIaIC/</id>
        <link href="https://yuufen.com/blog/post/pXhlFIaIC/">
        </link>
        <updated>2020-03-14T07:41:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="config">config</h2>
<h3 id="æŸ¥çœ‹é…ç½®">æŸ¥çœ‹é…ç½®</h3>
<pre><code>vue inspect
vue inspect --rules
vue inspect --rule vue
</code></pre>
<h3 id="é…ç½®-svg-loader">é…ç½® svg loader</h3>
<p>å·²æœ‰é…ç½®ï¼š</p>
<pre><code class="language-js">/* config.module.rule('svg') */
{
  test: /\.(svg)(\?.*)?$/,
  use: [
    {
      loader: 'file-loader',        
      options: {
        name: 'img/[name].[hash:8].[ext]'
      }
    }
  ]
}
</code></pre>
<blockquote>
<p>ç›®æ ‡ï¼š</p>
<ol>
<li>svg é…ç½®å¿½ç•¥ src/icons</li>
<li>åˆ›å»ºæ–°çš„é…ç½®ä½¿ç”¨ scg-sprite-loader æ¥åŠ è½½ src/icons</li>
</ol>
</blockquote>
<p>å®ç°ï¼š</p>
<pre><code class="language-js">const port = 7070
const title = 'Vue Learning Record'

const path = require('path')
// å°†ä¼ å…¥çš„ç›¸å¯¹è·¯å¾„è½¬æ¢ä¸ºç»å¯¹è·¯å¾„ï¼Œè·¨å¹³å°
function resolve(dir) {
  return path.join(__dirname, dir)
}

module.exports = {
  publicPath: '/practice',
  devServer: {
    port,
  },
  configureWebpack: {
    // ä¸å¤Ÿçµæ´»
    name: title,
  },
  chainWebpack(config) {
    // ä¿®æ”¹å·²æœ‰é…ç½®ï¼Œå¿½ç•¥ src/icons
    config.module.rule('svg')
      .exclude.add(resolve('src/icons'))

    // æ–°å»ºé…ç½®ï¼Œä½¿ç”¨ svg-sprite-loader åŠ è½½ src/icons
    config.module.rule('icons')
      .test(/\.svg$/)
      .include.add(resolve('src/icons')) // add ä¼šæ”¹å˜ä¸Šä¸‹æ–‡è¿›å…¥æ•°ç»„
        .end() // ç»“æŸæ•°ç»„æ“ä½œï¼Œä¸Šä¸‹æ–‡å›é€€
      .use('svg-sprite-loader') // æ·»åŠ  loader
      .loader('svg-sprite-loader') // åˆ‡æ¢ä¸Šä¸‹æ–‡åˆ° loader
        .options({ symbolId: 'icon-[name]' }) // æŒ‡å®šé€‰é¡¹
        .end()
  }
}
</code></pre>
<pre><code class="language-js">/* config.module.rule('icons') */
{
  test: /\.svg$/,
  include: [
    'C:\\Users\\u\\Desktop\\vue-learning-record\\src\\icons'
  ],
  use: [
    {
      loader: 'svg-sprite-loader',
      options: {
        symbolId: 'icon-[name]'
      }
    }
  ]
}
</code></pre>
<p>ä½¿ç”¨ï¼š</p>
<pre><code class="language-html">  &lt;svg&gt;
    &lt;use :xlink:href=&quot;#icon-msg&quot; /&gt;
  &lt;/svg&gt;
&lt;script&gt;
import '@/icons/svg/msg.svg'
</code></pre>
<h3 id="è‡ªåŠ¨å¯¼å…¥-å°è£…ç»„ä»¶">è‡ªåŠ¨å¯¼å…¥ã€å°è£…ç»„ä»¶</h3>
<pre><code class="language-js">import Vue from 'vue'
import Icon from '@/components/Icon.vue'
// å›¾æ ‡è‡ªåŠ¨å¯¼å…¥
// åˆ©ç”¨ webpack çš„ require.context

// è¿”å›çš„ req æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œåªèƒ½åŠ è½½ svg ç›®å½•ä¸­ç¬¦åˆ /\.svg$/ çš„æ–‡ä»¶
// å®ƒçš„ keys() ä¼šè¿”å›æ‰€æœ‰ç¬¦åˆè§„å®šçš„æ–‡ä»¶çš„ç›¸å¯¹è·¯å¾„
const req = require.context('./svg', false, /\.svg$/) // (ä¸é€’å½’ï¼ŒåªåŠ è½½ .svg )

console.log(req.keys())

req.keys().map(req)

Vue.component('Icon', Icon)
</code></pre>
<h2 id="æƒé™æ§åˆ¶">æƒé™æ§åˆ¶</h2>
<h3 id="1-æ¶æ„">1. æ¶æ„</h3>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1584603744487.png" alt="" loading="lazy"></figure>
<h3 id="2-å®šä¹‰è·¯ç”±">2. å®šä¹‰è·¯ç”±</h3>
<pre><code class="language-js">// src/router/index.js
import Vue from 'vue'
import Router from 'vue-router'

import Layout from '@/layout'

Vue.use(Router)

// é™æ€éƒ¨åˆ† é€šç”¨éƒ¨åˆ†
export const constRoutes = [
  {
    path: '/login',
    component: () =&gt; import('@/views/Login'),
    hidden: true,
  },
  {
    path: '/',
    component: Layout,
    redirect: '/home',
    children: [
      {
        path: 'home',
        component: () =&gt; import(/* webpackChunkName: &quot;home&quot; */ '@/views/Home'),
        name: 'Home',
        meta: {
          title: 'Home', // å¯¼èˆªèœå•é¡¹æ ‡é¢˜
          icon: 'msg', // å¯¼èˆªèœå•é¡¹å›¾æ ‡
        },
      },
    ],
  },
]

export const asyncRoutes = [
  {
    path: '/about',
    component: Layout,
    redirect: '/about/index',
    children: [
      {
        path: 'index',
        component: () =&gt; import(/* webpackChunkName: &quot;home&quot; */ '@/views/About.vue'),
        name: 'about',
        meta: {
          title: 'About',
          icon: 'img',
          // è§’è‰²
          role: ['admin', 'editor'],
        },
      },
    ],
  },
]

export default new Router({
  mode: 'history',
  base: process.env.BASE_URL,
  routes: constRoutes,
})
</code></pre>
<h3 id="3-å®ŒæˆåŠ¨æ€ç”Ÿæˆè·¯ç”±ç™»å½•çš„é€»è¾‘">3. å®ŒæˆåŠ¨æ€ç”Ÿæˆè·¯ç”±ï¼ˆç™»å½•ï¼‰çš„é€»è¾‘</h3>
<pre><code class="language-js">// src/permission.js
// ç”Ÿæˆå…¨å±€è·¯ç”±
import router from './router'
import store from './store'
import { getToken } from '@/utils/auth' // ä» cookie ä¸­è·å– token

const whiteList = ['/login']

router.beforeEach(async (to, from, next) =&gt; {
  const hasToken = getToken()
  if (hasToken) {
    if (to.path === '/login') {
      next({ path: '/home' })
    } else {
      // å·²ç™»å½•ï¼Œè·å–ç”¨æˆ·è§’è‰²
      const hasRoles = store.getters.roles &amp;&amp; store.getters.roles.length &gt; 0

      if (hasRoles) {
        next()
      } else {
        // è¿™æ ·ä¼šé˜»å¡é…ç½®é‡Œçš„é‡å®šå‘
        // å…ˆè¯·æ±‚ç”¨æˆ·ä¿¡æ¯
        const { roles } = await store.dispatch('user/getInfo')
        // æ ¹æ®è§’è‰²ç”ŸæˆåŠ¨æ€è·¯ç”±
        const accessedRoutes = await store.dispatch('permission/generateRoutes', roles)
        // æ·»åŠ è‡³ router
        router.addRoutes(accessedRoutes)
        // é‡å®šå‘
        next()
      }
    }
  } else {
    if (whiteList.indexOf(to.path) !== -1) {
      next()
    } else {
      next(`/login?redirect=${to.path}`)
    }
  }
})

</code></pre>
<h3 id="4-å…·ä½“å®ç°">4. å…·ä½“å®ç°</h3>
<ul>
<li>src/utils/auth</li>
</ul>
<pre><code class="language-js">import Cookies from 'js-cookie'

const TOKEN = 'token'

export function getToken() {
  return Cookies.get(TOKEN)
}

export function setToken(token) {
  return Cookies.set(TOKEN,token)
}
export function removeToken() {
  return Cookies.remove(TOKEN)
}
</code></pre>
<ul>
<li>src/store/user.js</li>
</ul>
<pre><code class="language-js">// ç”¨æˆ·ä¿¡æ¯
import { getToken, setToken, removeToken } from '@/utils/auth'

const state = {
  token: getToken(),
  roles: [],
}

const mutations = {
  SET_TOKEN: (state, token) =&gt; {
    state.token = token
  },
  SET_ROLES: (state, roles) =&gt; {
    state.roles = roles
  },
}

const actions = {
  // user login
  login({ commit }, userInfo) {
    const { username } = userInfo
    return new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        if (username === 'admin' || username === 'jerry') {
          commit('SET_TOKEN', username)
          setToken(username)
          resolve()
        } else {
          reject('ç”¨æˆ·åä¸å­˜åœ¨')
        }
      }, 1000)
    })
  },
  // get user info
  getInfo({ commit, state }) {
    return new Promise((resolve) =&gt; {
      setTimeout(() =&gt; {
        const roles = state.token === 'admin' ? ['admin'] : ['editor']
        commit('SET_ROLES', roles)
        resolve({ roles })
      }, 1000)
    })
  },

  // remove token
  resetToken({ commit }) {
    return new Promise((resolve) =&gt; {
      commit('SET_TOKEN', '')
      commit('SET_ROLES', [])
      removeToken()
      resolve()
    })
  },
}
export default {
  namespaced: true,
  state,
  mutations,
  actions,
}
</code></pre>
<ul>
<li>src/store/permission.js</li>
</ul>
<pre><code class="language-js">// è·¯ç”±é…ç½®ä¿¡æ¯ã€è·¯ç”±ç”Ÿæˆé€»è¾‘
import { constRoutes, asyncRoutes } from '@/router'

/**
 * æ ¹æ®è·¯ç”± meta.role ç¡®å®šå½“å‰ç”¨æˆ·æ˜¯å¦å…·æœ‰è®¿é—®æƒé™
 * @roles ç”¨æˆ·çš„æ‹¥æœ‰è§’è‰²
 * @route å¾…åˆ¤æ–­è·¯ç”±
 */
function hasPermission(roles, route) {
  if (route.meta &amp;&amp; route.meta.roles) {
    // å¦‚æœå½“å‰è·¯ç”±æœ‰ roles å­—æ®µï¼Œåˆ™éœ€è¦åˆ¤æ–­ç”¨æˆ·æƒé™
    return roles.some((role) =&gt; route.meta.roles.includes(role))
  } else {
    return true
  }
}

/**
 * é€’å½’è¿‡æ»¤ AsyncRoutes è·¯ç”±è¡¨
 * @roles ç”¨æˆ·æ‹¥æœ‰çš„è§’è‰²
 * @routes å¾…è¿‡æ»¤è·¯ç”±è¡¨ï¼Œ é¦–æ¬¡ä¼ å…¥çš„å°±æ˜¯ AsyncRoutes
 */
export function filterAsyncRoutes(roles, routes) {
  const res = []
  routes.forEach((route) =&gt; {
    // å¤åˆ¶ä¸€ä»½
    const tmp = { ...route }
    // å¦‚æœç”¨æˆ·æœ‰è®¿é—®æƒé™åˆ™åŠ å…¥ç»“æœè·¯ç”±è¡¨
    if (hasPermission(roles, tmp)) {
      // å¦‚æœå­˜åœ¨å­è·¯ç”±åˆ™é€’å½’è¿‡æ»¤
      if (tmp.children) {
        tmp.children = filterAsyncRoutes(roles, tmp.children)
      }
      res.push(tmp)
    }
  })
  return res
}

const state = {
  // å®Œæ•´è·¯ç”±
  routes: [],
  // èƒ½å¤Ÿè®¿é—®çš„åŠ¨æ€è·¯ç”±
  addRoutes: [],
}

const mutations = {
  SET_ROUTES: (state, routes) =&gt; {
    state.addRoutes = routes
    state.routes = constRoutes.concat(routes)
  },
}

const actions = {
  // ç”Ÿæˆè·¯ç”±ï¼Œåœ¨å¾—åˆ°ç”¨æˆ·è§’è‰²åä¼šç¬¬ä¸€æ—¶é—´è°ƒç”¨
  generateRoutes({ commit }, roles) {
    return new Promise((resolve) =&gt; {
      let accessedRoutes
      if (roles.includes('admin')) {
        // å¦‚æœæ˜¯ç®¡ç†å‘˜ï¼Œæœ‰å…¨éƒ¨æƒé™
        accessedRoutes = asyncRoutes || []
      } else {
        // å¦åˆ™è¿‡æ»¤
        accessedRoutes = filterAsyncRoutes(roles, asyncRoutes)
      }
      commit('SET_ROUTES', accessedRoutes)
      resolve(accessedRoutes)
    })
  },
}

export default {
  namespaced: true,
  state,
  mutations,
  actions,
}
</code></pre>
<ul>
<li>src/store/index.js</li>
</ul>
<pre><code class="language-js">import Vue from 'vue'
import Vuex from 'vuex'

import permission from './permission'
import user from './user'

Vue.use(Vuex)

export default new Vuex.Store({
  modules: {
    permission, // æƒé™
    user, // ç”¨æˆ·ä¿¡æ¯
  },
  getters: {
    roles: (state) =&gt; state.user.roles,  
  },
})
</code></pre>
<ul>
<li>ç™»å½•</li>
</ul>
<pre><code class="language-js">    login() {
      this.$store
        .dispatch('user/login', { username: this.username })
        .then(() =&gt; {
          this.$router.push({
            path: this.$route.query.redirect || '/',
          })
        })
        .catch((error) =&gt; {
          alert(error)
        })
    },
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue æºç è§£æ]]></title>
        <id>https://yuufen.com/blog/post/jD_rI1NpH/</id>
        <link href="https://yuufen.com/blog/post/jD_rI1NpH/">
        </link>
        <updated>2020-03-11T18:22:09.000Z</updated>
        <content type="html"><![CDATA[<center>
        <a href="https://yuufen.com/blog/post/28tbvr2E1/">å¯åŠ¨é¡¹ç›®ä¸å…¥å£æ–‡ä»¶åˆ†æ</a>
</center>
<center>
        <a href="https://yuufen.com/blog/post/sW2ztpxVO/">ä»å…¥å£æ–‡ä»¶åˆ° Vue å£°æ˜ï¼Œcreate</a>
</center>
<center>
        <a href="https://yuufen.com/blog/post/LGEsZIcVg/">æ•°æ®å“åº”å¼å®ç°ç»†èŠ‚</a>
</center>
<center>
        <a href="https://yuufen.com/blog/post/xFIRxtfFh/">ä»è™šæ‹Ÿ DOM åˆ° DOMï¼Œmount</a>
</center>
<center>
        <a href="https://yuufen.com/blog/post/cRGCDD5es/">æ¨¡æ¿ç¼–è¯‘</a>
</center>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue æºç è§£æï¼šæ¨¡æ¿ç¼–è¯‘]]></title>
        <id>https://yuufen.com/blog/post/cRGCDD5es/</id>
        <link href="https://yuufen.com/blog/post/cRGCDD5es/">
        </link>
        <updated>2020-03-10T21:20:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="æ¨¡æ¿ç¼–è¯‘çš„ç›®çš„">æ¨¡æ¿ç¼–è¯‘çš„ç›®çš„</h2>
<p>æ¨¡æ¿ç¼–è¯‘çš„ä¸»è¦ç›®æ ‡æ˜¯å°†æ¨¡æ¿ï¼ˆtemplateï¼‰è½¬æ¢ä¸ºæ¸²æŸ“å‡½æ•°ï¼ˆrenderï¼‰</p>
<p>Vue 2.0 éœ€è¦ç”¨ VNode æè¿°è§†å›¾ä»¥åŠå„ç§äº¤äº’ï¼Œæ‰‹å†™æ˜¾ç„¶ï¥§åˆ‡å®é™…ï¼Œå› æ­¤ç”¨æˆ·å¯åªç¼–å†™ç±»ä¼¼ HTML ä»£ç çš„ Vue æ¨¡æ¿ï¼Œé€šè¿‡ç¼–è¯‘ï¨¸å°†æ¨¡æ¿è½¬æ¢ä¸ºå¯è¿”å› VNode çš„ render å‡½æ•°ã€‚</p>
<h2 id="è¾“å…¥è¾“å‡º">è¾“å…¥è¾“å‡º</h2>
<p>å¸¦ç¼–è¯‘ï¨¸çš„ç‰ˆæœ¬ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ template æˆ– el çš„æ–¹å¼å£°æ˜æ¨¡æ¿</p>
<pre><code class="language-html">&lt;div id=&quot;demo&quot;&gt;
  &lt;h1&gt;æµ‹è¯•&lt;/h1&gt;
  &lt;p&gt;{{foo}}&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
  // ä½¿ç”¨ el
  const app = new Vue({
    date: { foo: 'foo' },
    el: &quot;#demo&quot;
  })
  // è¾“å‡ºæ¸²æŸ“å‡½æ•°
  console.log(app.$options.render)
&lt;/script&gt;
</code></pre>
<blockquote>
<p>å¾—åˆ°è¾“å‡ºç»“æœå¤§è‡´å¦‚ä¸‹ï¼š</p>
<pre><code class="language-js">Æ’unction anonymous() { 
     with (this) {
       return _c('div', { attrs: { &quot;id&quot;: &quot;demo&quot; } }, [
          _c('h1', [_v(&quot;Vue.jsæµ‹è¯•&quot;)]), 
          _v(&quot; &quot;), 
          _c('p', [_v(_s(foo))])
       ])
     }
}
</code></pre>
<p>å…ƒç´ èŠ‚ç‚¹ä½¿ç”¨ createElement åˆ›å»ºï¼Œåˆ«å _c</p>
<p>æ–‡æœ¬èŠ‚ç‚¹ä½¿ç”¨ createTextVNode åˆ›å»ºï¼Œåˆ«å _v</p>
<p>è¡¨è¾¾å¼å…ˆä½¿ç”¨ toString æ ¼å¼åŒ–ï¼Œåˆ«å _s</p>
</blockquote>
<h2 id="è¿‡ç¨‹">è¿‡ç¨‹</h2>
<p>å®ç°æ¨¡æ¿ç¼–è¯‘å…±æœ‰ä¸‰ä¸ªé˜¶æ®µï¼šè§£æã€ä¼˜åŒ–å’Œç”Ÿæˆã€‚</p>
<pre><code class="language-js">// src\compiler\index.js
export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  // è§£æï¼Œå°†æ¨¡æ¿è½¬æ¢ä¸ºæŠ½è±¡è¯­æ³•æ ‘
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    // ä¼˜åŒ–å¾—åˆ°çš„æŠ½è±¡è¯­æ³•æ ‘
    optimize(ast, options)
  }
  // ç”Ÿæˆï¼Œå°† AST è½¬æ¢æˆæ¸²æŸ“å‡½æ•°ä¸­çš„å†…å®¹ï¼Œå³ä»£ç å­—ç¬¦ä¸²
  // ä½œä¸º code çš„å±æ€§ï¼Œä¹‹åç”¨ new Function(str) ç”Ÿæˆå‡½æ•°
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})
</code></pre>
<h3 id="è§£æ-parse">è§£æ - parse</h3>
<p>è§£æå™¨å°†æ¨¡æ¿è§£æä¸ºæŠ½è±¡è¯­æ³•æ ‘ ASTï¼Œåªæœ‰å°†æ¨¡æ¿è§£ææˆ AST åï¼Œæ‰èƒ½åŸºäºå®ƒåšä¼˜åŒ–æˆ–è€…ç”Ÿæˆä»£ç å­—ç¬¦ä¸²ã€‚</p>
<p>è°ƒè¯•æŸ¥çœ‹å¾—åˆ°çš„ ASTï¼Œç»“æ„å¦‚ä¸‹ï¼š</p>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1584314460429.png" alt="" loading="lazy"></figure>
<p>è§£æå™¨å†…éƒ¨åˆ†äº† <strong>HTML è§£æå™¨</strong>ã€<strong>æ–‡æœ¬è§£æå™¨</strong>å’Œ<strong>è¿‡æ»¤å™¨è§£æå™¨</strong>ï¼Œå…¶ä¸­æœ€ä¸»è¦çš„æ˜¯ HTML è§£æå™¨ï¼Œæ ¸å¿ƒç®—æ³•å¦‚ä¸‹ï¼š</p>
<pre><code class="language-js">// src\compiler\parser\index.js
parseHTML(tempalte, {
  start(tag, attrs, unary){}, // é‡åˆ°å¼€å§‹æ ‡ç­¾çš„å¤„ç†ï§¤    
  end(){},// é‡åˆ°ç»“æŸæ ‡ç­¾çš„å¤„ç†ï§¤    
  chars(text){},// é‡åˆ°â½‚æ–‡æœ¬æ ‡ç­¾çš„å¤„ç†ï§¤   
  comment(text){}// é‡åˆ°æ³¨é‡Šæ ‡ç­¾çš„å¤„ç†ï§¤ 
})
</code></pre>
<h3 id="ä¼˜åŒ–-optimize">ä¼˜åŒ– - optimize</h3>
<p>ä¼˜åŒ–å™¨çš„ä½œç”¨æ˜¯åœ¨ AST ä¸­æ‰¾å‡ºé™æ€å­æ ‘å¹¶æ‰“ä¸Šæ ‡è®°ã€‚é™æ€å­æ ‘æ˜¯åœ¨ AST ä¸­æ°¸è¿œä¸å˜çš„èŠ‚ç‚¹ï¼Œå¦‚çº¯æ–‡æœ¬èŠ‚ç‚¹ã€‚</p>
<p>æ ‡è®°é™æ€å­æ ‘çš„å¥½å¤„ï¼š</p>
<ul>
<li>æ¯æ¬¡é‡æ–°æ¸²æŸ“ï¼Œä¸éœ€è¦ä¸ºé™æ€å­æ ‘åˆ›å»ºæ–°èŠ‚ç‚¹</li>
<li>è™šæ‹Ÿ DOM ä¸­ patch æ—¶ï¼Œå¯ä»¥è·³è¿‡é™æ€å­æ ‘</li>
</ul>
<p>ä»£ç å®ç°ï¼š</p>
<pre><code class="language-js">// src\compiler\optimizer.js
export function optimize (root: ?ASTElement, options: CompilerOptions) {
  if (!root) return
  isStaticKey = genStaticKeysCached(options.staticKeys || '')
  isPlatformReservedTag = options.isReservedTag || no
  // first pass: æ‰¾å‡ºé™æ€èŠ‚ç‚¹å¹¶æ ‡è®°
  markStatic(root)
  // second pass: æ‰¾å‡ºé™æ€æ ¹èŠ‚ç‚¹ï¼ˆå³æ‰€æœ‰å­èŠ‚ç‚¹éƒ½æ˜¯é™æ€èŠ‚ç‚¹ï¼‰å¹¶æ ‡è®°
  markStaticRoots(root, false)
}
</code></pre>
<p>æ ‡è®°ç»“æŸï¼š</p>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1584316301907.png" alt="" loading="lazy"></figure>
<h3 id="ä»£ç ç”Ÿæˆ-generate">ä»£ç ç”Ÿæˆ -generate</h3>
<p>å°† AST è½¬æ¢æˆæ¸²æŸ“å‡½æ•°ä¸­çš„å†…å®¹ï¼Œå³ä»£ç å­—ç¬¦ä¸²ã€‚</p>
<p>ä»£ç å®ç°ï¼š</p>
<pre><code class="language-js">// src\compiler\codegen\index.js
export function generate (
  ast: ASTElement | void,
  options: CompilerOptions
): CodegenResult {
  const state = new CodegenState(options)
  const code = ast ? genElement(ast, state) : '_c(&quot;div&quot;)'
  return {
    render: `with(this){return ${code}}`,
    staticRenderFns: state.staticRenderFns
  }
}

// ç”Ÿæˆçš„ code é•¿è¿™æ · 
// `_c('div',{attrs:{&quot;id&quot;:&quot;demo&quot;}},[ 
//   _c('h1',[_v(&quot;Vue.jsæµ‹è¯•&quot;)]), 
//   _c('p',[_v(_s(foo))]) 
// ])`

</code></pre>
<h3 id="v-if-v-for">v-ifã€v-for</h3>
<p>ç€é‡è§‚å¯Ÿå‡ ä¸ªç»“æ„æ€§æŒ‡ä»¤çš„è§£æè¿‡ç¨‹ï¼š</p>
<pre><code class="language-js">// src\compiler\parser\index.js
// è§£æ v-if
function processIf (el) {
  const exp = getAndRemoveAttr(el, 'v-if') // è·å– v-if=&quot;exp&quot; ä¸­çš„ expï¼Œå¹¶åˆ é™¤ v-if å±æ€§
  if (exp) {
    el.if = exp // ä¸º AST æ·»åŠ  if è¡¨ç¤ºæ¡ä»¶
    addIfCondition(el, { // ä¸º AST æ·»åŠ  ifConditions è¡¨ç¤ºå„ç§æƒ…å†µå¯¹åº”ç»“æœ
      exp: exp,
      block: el
    })
  } else { 
    // å…¶ä»–æƒ…å†µå¤„ç†
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true
    }
    const elseif = getAndRemoveAttr(el, 'v-else-if')
    if (elseif) {
      el.elseif = elseif
    }
  }
}
</code></pre>
<pre><code class="language-js">// src\compiler\codegen\index.js
// ifConditions ä»£ç ç”Ÿæˆ
function genIfConditions (
  conditions: ASTIfConditions,
  state: CodegenState,
  altGen?: Function,
  altEmpty?: string
): string {
  if (!conditions.length) {
    return altEmpty || '_e()'
  }

  const condition = conditions.shift() // æ¯æ¬¡å¤„ç†ä¸€ä¸ªæ¡ä»¶
  if (condition.exp) { // æ¯ç§æ¡ä»¶ç”Ÿæˆä¸€ä¸ª ä¸‰ç›®è¡¨è¾¾å¼
    return `(${condition.exp})?${
      genTernaryExp(condition.block)
    }:${
      genIfConditions(conditions, state, altGen, altEmpty)
    }`
  } else {
    return `${genTernaryExp(condition.block)}`
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp (el) {
    return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
  }
}
</code></pre>
<p>è§£æç»“æœï¼š</p>
<figure data-type="image" tabindex="3"><img src="https://yuufen.com/blog/post-images/1584320046441.png" alt="" loading="lazy"></figure>
<p>ç”Ÿæˆç»“æœï¼š</p>
<pre><code class="language-js">&quot;with(this){return _c('div',{attrs:{&quot;id&quot;:&quot;demo&quot;}},[  
  (foo) ? _c('h1',[_v(_s(foo))]) : _c('h1',[_v(&quot;no title&quot;)]), 
    _v(&quot; &quot;),_c('abc')],1)}&quot;

</code></pre>
<blockquote>
<p>æ‰€ä»¥å¯çŸ¥ v-ifã€v-for è¿™äº›æŒ‡ä»¤åªèƒ½åœ¨ç¼–è¯‘é˜¶æ®µå¤„ç†ï¼Œå¦‚æœè¦åœ¨ render å‡½æ•°ä¸­å¤„ç†æ¡ä»¶æˆ–å¾ªç¯ï¼Œéœ€è¦ä½¿ç”¨ js çš„ if å’Œ for</p>
<pre><code class="language-js">Vue.component('comp', {
  props: ['foo'],
  render(h) {
    if (this.foo == 'foo') {
      return h('div', 'foo')
    }
    return h('div', 'bar')
  }
})
</code></pre>
</blockquote>
<h3 id="æ’æ§½">æ’æ§½</h3>
<p>ç»„ä»¶ç¼–è¯‘çš„é¡ºåºæ˜¯<strong>å…ˆç¼–è¯‘çˆ¶ç»„ä»¶ï¼Œåœ¨ç¼–è¯‘å­ç»„ä»¶</strong>ã€‚</p>
<p><strong>æ™®é€šæ’æ§½</strong>æ˜¯åœ¨<strong>çˆ¶å…ƒç´ ç¼–è¯‘å’Œæ¸²æŸ“é˜¶æ®µ</strong>ç”Ÿæˆ <code>vnodes</code>ï¼Œæ•°æ®çš„<strong>ä½œç”¨åŸŸ</strong>æ˜¯<strong>çˆ¶ç»„ä»¶</strong>ï¼Œå­ç»„ä»¶æ¸²æŸ“çš„æ—¶å€™ç›´æ¥æ‹¿åˆ°è¿™äº›</p>
<p>æ¸²æŸ“å¥½çš„ <code>vnodes</code>ã€‚</p>
<p><strong>ä½œç”¨åŸŸæ’æ§½</strong>ï¼Œçˆ¶ç»„ä»¶åœ¨ç¼–è¯‘å’Œæ¸²æŸ“é˜¶æ®µå¹¶ä¸ä¼šç›´æ¥ç”Ÿæˆ <code>vnodes</code>ï¼Œè€Œæ˜¯åœ¨çˆ¶èŠ‚ç‚¹ä¿ç•™ä¸€ä¸ª <code>scopedSlots</code> å¯¹è±¡ï¼Œ<strong>å‚¨å­˜ç€ä¸åŒåç§°çš„æ’æ§½ä»¥åŠå®ƒä»¬å¯¹åº”çš„æ¸²æŸ“å‡½æ•°</strong>ï¼Œåªæœ‰<strong>åœ¨ç¼–è¯‘å’Œæ¸²æŸ“å­ç»„ä»¶é˜¶æ®µæ‰ä¼šæ‰§è¡Œ</strong>è¿™ä¸ªæ¸²æŸ“å‡½æ•°ç”Ÿæˆ <code>vnodes</code>ï¼Œç”±äºæ˜¯åœ¨å­ç»„ä»¶ç¯å¢ƒæ‰§è¡Œçš„ï¼Œæ‰€ä»¥<strong>å¯¹åº”çš„æ•°æ®ä½œç”¨åŸŸæ˜¯å­ç»„ä»¶å®ä¾‹</strong>ã€‚</p>
<p>è§£æç›¸å…³ä»£ç ï¼š</p>
<pre><code class="language-js">// src\compiler\parser\index.js

// processSlotContent: å¤„ç† &lt;template v-slot:xxx=&quot;yyy&quot;&gt;
const slotBinding = getAndRemoveAttrByRegex(el, slotRE) // æŸ¥æ‰¾ v-slot:xxx ç„¶å remove è¯¥å±æ€§
if (slotBinding) {
  const { name, dynamic } = getSlotName(slotBinding) // name æ˜¯ xxx
  // xxx èµ‹å€¼ç»™ slotTarget
  el.slotTarget = name
  el.slotTargetDynamic = dynamic
  // yyy èµ‹å€¼ç»™ slotScope
  el.slotScope = slotBinding.value || emptySlotScopeToken // force it into a scoped slot for perf
}

// processSlotContent: å¤„ç† &lt;slot&gt;
function processSlotOutlet (el) {
  if (el.tag === 'slot') {
    // è·å– slot çš„ name å¹¶èµ‹å€¼ç»™ slotName
    el.slotName = getBindingAttr(el, 'name')
  }
}
</code></pre>
<p>ç”Ÿæˆç›¸å…³ä»£ç </p>
<pre><code class="language-js">// src\compiler\codegen\index.js
// genScopedSlot: æŠŠ slotScope ä½œä¸ºå½¢å‚è½¬æ¢ä¸ºå·¥å‚å‡½æ•°è¿”å›å†…å®¹
  const fn = `function(${slotScope}){` +
    `return ${el.tag === 'template'
      ? el.if &amp;&amp; isLegacySyntax
        ? `(${el.if})?${genChildren(el, state) || 'undefined'}:undefined`
        : genChildren(el, state) || 'undefined'
      : genElement(el, state)
    }}`
  // reverse proxy v-slot without scope on this.$slots
  const reverseProxy = slotScope ? `` : `,proxy:true`
  return `{key:${el.slotTarget || `&quot;default&quot;`},fn:${fn}${reverseProxy}}`
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue æºç è§£æï¼šä»è™šæ‹Ÿ DOM åˆ° DOMï¼Œmount]]></title>
        <id>https://yuufen.com/blog/post/xFIRxtfFh/</id>
        <link href="https://yuufen.com/blog/post/xFIRxtfFh/">
        </link>
        <updated>2020-03-08T12:28:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="è™šæ‹Ÿ-dom">è™šæ‹Ÿ DOM</h2>
<h3 id="ä¼˜ç‚¹">ä¼˜ç‚¹</h3>
<p>è™šæ‹Ÿ DOM è½»é‡ã€å¿«é€Ÿï¼Œå½“å®ƒä»¬å‘ç”Ÿå˜åŒ–æ—¶ï¼Œé€šè¿‡æ–°æ—§è™šæ‹ŸDOMæ¯”å¯¹å¯ä»¥å¾—åˆ°æœ€å° DOM æ“ä½œé‡ï¼Œä»è€Œæå‡æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒã€‚æœ¬è´¨ä¸Šæ˜¯ä½¿ç”¨ JavaScript è¿ç®—æˆæœ¬æ›¿æ¢ DOM æ“ä½œçš„æ‰§è¡Œæˆæœ¬ï¼Œå‰è€…è¿ç®—é€Ÿåº¦æ¯”åè€…å¿«å¾ˆå¤šã€‚</p>
<p>Vue 1.0 ä¸­æœ‰ç»†ç²’åº¦çš„æ•°æ®å˜åŒ–ä¾¦æµ‹ï¼Œå®ƒæ˜¯ä¸éœ€è¦è™šæ‹ŸDOMçš„ï¼Œä½†æ˜¯ç»†ç²’åº¦é€ æˆäº†å¤§é‡å¼€é”€ï¼Œè¿™å¯¹äºå¤§å‹é¡¹ç›®æ¥è¯´æ˜¯ä¸å¯æ¥å—çš„ã€‚</p>
<p>å› æ­¤ï¼ŒVue 2.0 é€‰æ‹©äº†ä¸­ç­‰ç²’åº¦çš„è§£å†³æ–¹æ¡ˆï¼Œæ¯ä¸€ä¸ªç»„ä»¶åˆ›å»ºä¸€ä¸ª Watcher å®ä¾‹ï¼Œè¿™æ ·çŠ¶æ€å˜åŒ–æ—¶åªèƒ½é€šçŸ¥åˆ°ç»„ä»¶ï¼Œæ‰€ä»¥å†é€šè¿‡å¼•å…¥è™šæ‹ŸDOMå»è¿›è¡Œå¯¹æ¯”å’Œæ¸²æŸ“ï¼ˆåŒæ—¶å¯ä»¥è§£å†³è·¨å¹³å°çš„é—®é¢˜ï¼‰ã€‚</p>
<h2 id="ä»è¡¨åˆ°é‡Œ">ä»è¡¨åˆ°é‡Œ</h2>
<blockquote>
<pre><code>new Vue().$mount('#app')
</code></pre>
</blockquote>
<h3 id="1-mount">1. $mount</h3>
<p>src\platforms\web\runtime\index.js</p>
<pre><code class="language-js">// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  // æ‹¿åˆ°å¯¹åº” DOM å…ƒç´ 
  el = el &amp;&amp; inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
</code></pre>
<ul>
<li>mountComponent</li>
</ul>
<h3 id="2-mountcomponent">2. mountComponent</h3>
<p>src\core\instance\lifecycle.js</p>
<pre><code class="language-js">export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  // æŒ‚è½½ el
  vm.$el = el

  // å¦‚æœå¸¦ç¼–è¯‘å™¨ï¼Œä¼šåœ¨è°ƒç”¨å‰ç¼–è¯‘å‡º render å‡½æ•°
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
    // çœç•¥æŠ¥é”™
  }
  // è°ƒç”¨ç”Ÿå‘½å‘¨æœŸé’©å­ beforeMountã€‚initå’Œç¼–è¯‘éƒ½å‘ç”Ÿåœ¨è¿™ä¹‹å‰
  // ï¼ˆä»initMixinçš„createdåˆ°è°ƒç”¨$mountæ‰§è¡Œåˆ°è¿™é‡Œï¼Œåšäº†å¾ˆå¤šäº‹æƒ…ï¼‰
  callHook(vm, 'beforeMount')

  // å®šä¹‰äº†æ›´æ–°å‡½æ•°
  let updateComponent
  updateComponent = () =&gt; {
    // vm._render ä¸­è°ƒç”¨äº† $options ä¸Šçš„ renderï¼Œè¿”å› VNode
    // ç„¶å VNode ä½œä¸ºå‚æ•°ä¼ å…¥ vm._updateï¼ŒåšçœŸå® DOM æ›´æ–°
    vm._update(vm._render(), hydrating)
  }

  // åœ¨åˆ›å»ºç»„ä»¶æ—¶ä¼š new ä¸€ä¸ªå’Œç»„ä»¶å¯¹åº” Watcher å®ä¾‹ï¼ˆå³render watcherï¼‰ï¼Œ
  // render watcher ä¼šç‹¬ç«‹äºç»„ä»¶çš„å…¶ä»– watcher å•ç‹¬ä¿å­˜
  // å®ƒä¼šåœ¨æ•°æ®æ›´æ–°æ—¶é€šçŸ¥ ç»„ä»¶ æ›´æ–° DOMï¼ˆä¸­ç­‰ç²’åº¦ï¼‰
  // å³è°ƒç”¨ updateComponentã€‚
  // ï¼ˆä½¿ç”¨ $watcher / watcheré€‰é¡¹ ä¼šé¢å¤–åˆ›å»º Watcher å®ä¾‹ï¼‰
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted &amp;&amp; !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    // è°ƒç”¨ç”Ÿå‘½å‘¨æœŸé’©å­ mountedã€‚beforeMounted åˆ° mounted çš„è¿‡ç¨‹ï¼Œ
    // è°ƒç”¨äº†å·²æœ‰çš„renderå‡½æ•°ç”Ÿæˆäº†è™šæ‹Ÿ DOMï¼Œç„¶åç”Ÿæˆäº†çœŸå® DOM
    callHook(vm, 'mounted')
  }
  return vm
}
</code></pre>
<ul>
<li>_render</li>
<li>_update</li>
</ul>
<h3 id="3-_render">3. _render</h3>
<p>src\core\instance\render.js</p>
<pre><code class="language-js">const { render, _parentVnode } = vm.$options	
// ...
vnode = render.call(vm._renderProxy, vm.$createElement)
// ...
return vnode
</code></pre>
<h3 id="4-_update">4. _update</h3>
<p>src\core\instance\lifecycle.js</p>
<pre><code class="language-js">    if (!prevVnode) {
      // initial render
      // æ²¡æœ‰æ—§çš„ vnodeï¼Œå³ç¬¬ä¸€æ¬¡æ¸²æŸ“æ—¶
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
      // updates
      // æ›´æ–°ï¼Œæ–°æ—§ vnode ä¹‹é—´ diffï¼Œè¿”å›æ–°çš„ DOM
      vm.$el = vm.__patch__(prevVnode, vnode)
    }

	// ç„¶ååšä¸€äº›çŠ¶æ€æ›´æ–°
	// ...
</code></pre>
<ul>
<li>_<em>patch</em>_</li>
</ul>
<h3 id="5-_patch_">5. _<em>patch</em>_</h3>
<p>src\platforms\web\runtime\index.js</p>
<pre><code class="language-js">import { patch } from './patch'
Vue.prototype.__patch__ = inBrowser ? patch : noop
</code></pre>
<ul>
<li>patch</li>
</ul>
<p>src\platforms\web\runtime\patch.js</p>
<pre><code class="language-js">// é‡Œé¢å°è£…æœ‰å„ä¸ªæµè§ˆå™¨å¹³å°ä¸­å¯¹ DOM èŠ‚ç‚¹çš„æ“ä½œ
import * as nodeOps from 'web/runtime/node-ops'
import { createPatchFunction } from 'core/vdom/patch'
import baseModules from 'core/vdom/modules/index'
// é‡Œé¢å°è£…æœ‰å„ä¸ªæµè§ˆå™¨å¹³å°ä¸­å¯¹å±æ€§çš„æ“ä½œ
import platformModules from 'web/runtime/modules/index'

// the directive module should be applied last, after all
// built-in modules have been applied.
// æ‰©å±•æ“ä½œï¼šæŠŠé€šç”¨æ¨¡å—å’Œæµè§ˆå™¨ä¸­ç‰¹æœ‰æ¨¡å—åˆå¹¶
const modules = platformModules.concat(baseModules)

// å·¥å‚å‡½æ•°ï¼šåˆ›å»ºç”¨æˆ·ä½¿ç”¨çš„æµè§ˆå™¨ç‰¹æœ‰çš„ patch å‡½æ•°ï¼Œä¸»è¦æ˜¯ä¸ºäº†å®ç°è·¨å¹³å°
export const patch: Function = createPatchFunction({ nodeOps, modules })
</code></pre>
<ul>
<li>createPatchFunction</li>
</ul>
<p>src\core\vdom\patch.js</p>
<pre><code class="language-js">// è¿™æ˜¯ä¸€ä¸ªå·¥å‚å‡½æ•°ï¼Œè¿”å›äº†æµè§ˆå™¨ä¸­ä½¿ç”¨çš„ patch æ–¹æ³•
// åœ¨ 700 è¡Œå·¦å³ return
// è¯¦è§ä¸‹æ–‡
</code></pre>
<h2 id="patch-è§£æ">patch è§£æ</h2>
<p>vue ä½¿ç”¨çš„ patching ç®—æ³•åŸºäº Snabbdomï¼ŒVNodeçš„ children / text äºŒé€‰ä¸€ï¼Œä¸å¯å…±å­˜ ã€‚</p>
<p>patch å°†æ–°è€ VNode èŠ‚ç‚¹è¿›è¡Œæ¯”å¯¹ï¼ˆdiff ç®—æ³•ï¼‰ï¼Œç„¶åæ ¹æ®æ¯”è¾ƒç»“æœè¿›è¡Œæœ€å°é‡çš„ DOM æ“ä½œï¼Œè€Œä¸æ˜¯å°†æ•´ä¸ªè§†å›¾æ ¹æ®æ–°çš„ VNode é‡ç»˜ã€‚</p>
<p>é‚£ä¹ˆ patch æ˜¯æ€ä¹ˆå·¥ä½œçš„å‘¢ï¼Ÿ</p>
<p>é¦–å…ˆè¯´ä¸€ä¸‹ patch çš„æ ¸å¿ƒ â€”â€” diff ç®—æ³•ï¼šé€šè¿‡<strong>åŒå±‚çš„æ ‘èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒ</strong>ï¼ˆä¸€èˆ¬çš„ web å¼€å‘ä¸ä¼šå‡ºç°è·¨å±‚çš„ DOM å˜åŒ–ï¼‰ï¼Œè€Œéå¯¹æ ‘è¿›è¡Œé€å±‚æœç´¢éå†çš„æ–¹å¼ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦åªæœ‰ O(n)ï¼Œè€Œä¸æ˜¯ O(n^3)ï¼Œæ˜¯ä¸€ç§ç›¸å½“é«˜æ•ˆçš„ç®—æ³•ã€‚</p>
<p>åŒå±‚çº§åªåšä¸‰ä»¶äº‹ï¼šå¢åˆ æ”¹ã€‚new VNode ä¸å­˜åœ¨å°±åˆ ï¼›old VNode ä¸å­˜åœ¨å°±å¢ï¼›éƒ½å­˜åœ¨å°±æ¯”è¾ƒï¼ˆæ ‡ç­¾ï¼‰ç±»å‹å’Œ keyï¼Œæœ‰ä¸€é¡¹ä¸åŒå°±ç›´æ¥æ•´ä½“æ›¿æ¢ï¼Œéƒ½ç›¸åŒæ‰§è¡Œæ›´æ–°ï¼ˆé€’å½’ï¼‰ã€‚</p>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1584040706895.png" alt="" loading="lazy"></figure>
<h3 id="1-createpatchfunction">1. createPatchFunction</h3>
<p>è¿™æ˜¯ä¸€ä¸ªå·¥å‚å‡½æ•°ï¼Œåœ¨ 700 è¡Œå·¦å³è¿”å›äº†æµè§ˆå™¨ä¸­ä½¿ç”¨çš„ patch æ–¹æ³•</p>
<pre><code class="language-js">  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    // å¦‚æœæ²¡æœ‰æ–°çš„ vnodeï¼šåˆ 
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      return
    }

    let isInitialPatch = false
    const insertedVnodeQueue = []

    if (isUndef(oldVnode)) {
      // å¦‚æœè€èŠ‚ç‚¹ä¸å­˜åœ¨ï¼šå¢
      // empty mount (likely as component), create new root element
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue)
    } else {
      // oldVnodeï¼Œvnode éƒ½å­˜åœ¨ï¼Œæœ‰ä¸‰ç§æƒ…å†µ
      // 1. oldVnode ä¸æ˜¯ DOMï¼Œå¹¶ä¸”æ–°è€ VNode æ˜¯ &quot;sameVnode&quot;ï¼Œå°±è°ƒç”¨ patchVnode
      // 2. oldVnode ä¸æ˜¯ DOMï¼Œä½†æ˜¯æ–°è€ VNode ä¸æ˜¯ &quot;sameVnode&quot;ï¼Œå°±æ•´ä½“æ›¿æ¢
      // 3. oldVnode æ˜¯çœŸå® DOMï¼Œåˆå§‹åŒ–è¿‡ç¨‹ï¼ˆæˆ–è€…æ˜¯ SSR ç›¸å…³ï¼Œè¿˜æ²¡çœ‹ï¼‰ï¼Œå°±æ•´ä½“æ›¿æ¢
      
      // å¦‚æœ oldVnode å­˜åœ¨nodeTypeï¼Œè¯´æ˜ä¼ è¿›æ¥çš„æ˜¯ä¸€ä¸ªçœŸå® DOM
      const isRealElement = isDef(oldVnode.nodeType)
      if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) {
        // è‡ªå®šä¹‰ç»„ä»¶çš„è¡¥ä¸æ“ä½œ
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR)
            hydrating = true
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true)
              return oldVnode
            } else if (process.env.NODE_ENV !== 'production') {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing ' +
                'full client-side render.'
              )
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode)
        }

        // replacing existing element
        // ä¸‹é¢æ˜¯æ›¿æ¢æ“ä½œï¼Œå¯ä»¥æ‰“æ–­ç‚¹çœ‹çœ‹
        const oldElm = oldVnode.elm
        const parentElm = nodeOps.parentNode(oldElm)

        // create new node
        // ä»¥è€èŠ‚ç‚¹ä¸ºæ¨¡æ¿ï¼Œæ–°å»ºäº†ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆå…¶ä¸­å€¼å·²ç»æ›´æ–°ï¼‰
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        )

        // update parent placeholder node element, recursively
        // è¿™æ—¶ parent ä¸­å­˜åœ¨ç€ æ–°è€ä¸¤ä¸ªèŠ‚ç‚¹
        if (isDef(vnode.parent)) {
          let ancestor = vnode.parent
          const patchable = isPatchable(vnode)
          while (ancestor) {
            for (let i = 0; i &lt; cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor)
            }
            ancestor.elm = vnode.elm
            if (patchable) {
              for (let i = 0; i &lt; cbs.create.length; ++i) {
                cbs.create[i](emptyNode, ancestor)
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the &quot;inserted&quot; hook.
              const insert = ancestor.data.hook.insert
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (let i = 1; i &lt; insert.fns.length; i++) {
                  insert.fns[i]()
                }
              }
            } else {
              registerRef(ancestor)
            }
            ancestor = ancestor.parent
          }
        }

        // destroy old node
        // ç›´åˆ°è¿™é‡Œï¼Œè€èŠ‚ç‚¹è¢«é”€æ¯
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0) // è¿™é‡Œ remove äº†è€èŠ‚ç‚¹ï¼Œparent ä¸­åªå‰©æ–°èŠ‚ç‚¹
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode)
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
    return vnode.elm
  }
</code></pre>
<h3 id="2-samevnode">2. sameVnode</h3>
<pre><code class="language-js">function sameVnode (a, b) {
  return (
    a.key === b.key &amp;&amp; (
      (
        a.tag === b.tag &amp;&amp;
        a.isComment === b.isComment &amp;&amp;
        isDef(a.data) === isDef(b.data) &amp;&amp;
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &amp;&amp;
        a.asyncFactory === b.asyncFactory &amp;&amp;
        isUndef(b.asyncFactory.error)
      )
    )
  )
}
</code></pre>
<h3 id="2-patchvnode">2. patchVnode</h3>
<p>ä¸¤ä¸ª VNode æ˜¯ â€œsameVnodeâ€ï¼Œå°±æ‰§è¡Œæ›´æ–°æ“ä½œï¼ŒåŒ…æ‹¬ï¼š<strong>å±æ€§æ›´æ–° props</strong>ã€<strong>æ–‡æœ¬æ›´æ–° text</strong>ã€<strong>å­èŠ‚ç‚¹æ›´æ–° å¦‚reorder</strong>ã€‚ï¼ˆVNode çš„ children / text äºŒè€…åªèƒ½å­˜åœ¨ä¸€ä¸ªï¼‰</p>
<p>patchVNode å…·ä½“è§„åˆ™å¦‚ä¸‹ï¼š</p>
<ol>
<li>
<p>å¦‚æœæ–°æ—§ VNode éƒ½æ˜¯<strong>é™æ€çš„</strong>ï¼ˆä¸ä¼šæ”¹å˜ï¼‰ï¼ŒåŒæ—¶å®ƒä»¬çš„ key ç›¸åŒï¼ˆä»£è¡¨åŒä¸€èŠ‚ç‚¹ï¼‰ï¼Œå¹¶ä¸”æ–°çš„ VNode æ˜¯ clone æˆ–è€…æ ‡è®°äº† v-onceï¼Œé‚£ä¹ˆåªéœ€è¦æ›¿æ¢ elm ä»¥åŠ <code>componentInstance</code> å³å¯ï¼›</p>
</li>
<li>
<p>å¦‚æœæ–°è€èŠ‚ç‚¹éƒ½æœ‰ <code>children</code> å­èŠ‚ç‚¹ï¼Œåˆ™å¯¹å­èŠ‚ç‚¹è¿›è¡Œ diff æ“ä½œï¼Œè°ƒç”¨ updateChildrenï¼Œå®ƒæ˜¯ diff çš„æ ¸å¿ƒä¹‹ä¸€ï¼›</p>
</li>
<li>
<p>å¦‚æœè€èŠ‚ç‚¹æ²¡æœ‰å­èŠ‚ç‚¹ï¼Œè€Œæ–°èŠ‚ç‚¹å­˜åœ¨å­èŠ‚ç‚¹ï¼Œåˆ™å…ˆæ¸…ç©ºè€èŠ‚ç‚¹ DOM çš„æ–‡æœ¬å†…å®¹ï¼Œç„¶åä¸ºå½“å‰ DOM èŠ‚ç‚¹åŠ å…¥å­èŠ‚ç‚¹ï¼›</p>
</li>
<li>
<p>å½“æ–°èŠ‚ç‚¹æ²¡æœ‰å­èŠ‚ç‚¹ï¼Œè€Œè€èŠ‚ç‚¹å­˜åœ¨å­èŠ‚ç‚¹æ—¶ï¼Œåˆ™ç§»é™¤è¯¥ DOM èŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹ï¼›</p>
</li>
<li>
<p>å½“æ–°è€èŠ‚ç‚¹éƒ½æ— å­èŠ‚ç‚¹æ—¶ï¼Œå°±åªæ˜¯æ–‡æœ¬çš„æ›¿æ¢ã€‚</p>
</li>
</ol>
<pre><code class="language-js">  function patchVnode (
    oldVnode,
    vnode,
    insertedVnodeQueue,
    ownerArray,
    index,
    removeOnly
  ) {
    // æ–°æ—§ VNode ç›¸åŒå°±ç›´æ¥è¿”å›
    if (oldVnode === vnode) {
      return
    }

    if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode)
    }

    // elm ä¿å­˜ç€å¯¹åº”çš„ DOMï¼Œè¿™é‡Œæ–°çš„ä»è€çš„é‚£é‡Œè·å–åˆ° elm
    const elm = vnode.elm = oldVnode.elm

    // å¼‚æ­¥ç»„ä»¶çš„ç‰¹æ®Šå¤„ç†
    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)
      } else {
        vnode.isAsyncPlaceholder = true
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    // é™æ€èŠ‚ç‚¹å¯å¤ç”¨ï¼Œæ›´æ–° componentIstance ï¼Œç„¶åè·³è¿‡
    if (isTrue(vnode.isStatic) &amp;&amp;
      isTrue(oldVnode.isStatic) &amp;&amp;
      vnode.key === oldVnode.key &amp;&amp;
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance
      return
    }

    let i
    const data = vnode.data
    if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) {
      i(oldVnode, vnode)
    }

    const oldCh = oldVnode.children
    const ch = vnode.children

    // æ›´æ–°å±æ€§ï¼Ÿ
    if (isDef(data) &amp;&amp; isPatchable(vnode)) {
      for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)
      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)
    }

    // å‰æï¼švnode çš„ children / text åªèƒ½å­˜åœ¨ä¸€ä¸ª
    if (isUndef(vnode.text)) {
      // æ–°çš„ æ²¡æœ‰ textï¼ˆå³åªå¯èƒ½å­˜åœ¨ childrenï¼‰æ—¶ï¼š
      if (isDef(oldCh) &amp;&amp; isDef(ch)) {
        // å¦‚æœæ–°è€ éƒ½æœ‰å­èŠ‚ç‚¹
        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
      } else if (isDef(ch)) {
        // å¦‚æœè€çš„æ²¡æœ‰å­èŠ‚ç‚¹ï¼Œæ–°çš„æœ‰å­èŠ‚ç‚¹ï¼š
        if (process.env.NODE_ENV !== 'production') {
          checkDuplicateKeys(ch)
        }
        if (isDef(oldVnode.text)){
          // å¦‚æœè€çš„æœ‰ textï¼šæ¸…ç©º
          nodeOps.setTextContent(elm, '')
        }
        // å¾€ elm ä¸­åŠ ä¸œè¥¿
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
      } else if (isDef(oldCh)) {
        // å¦‚æœè€çš„æœ‰å­èŠ‚ç‚¹ï¼Œæ–°çš„æ²¡æœ‰å­èŠ‚ç‚¹ï¼šåˆ æ‰
        removeVnodes(oldCh, 0, oldCh.length - 1)
      } else if (isDef(oldVnode.text)) {
        // å¦‚æœè€çš„æ²¡æœ‰å­èŠ‚ç‚¹ï¼Œæœ‰ textï¼›æ–°çš„æ²¡æœ‰å­èŠ‚ç‚¹ä¹Ÿæ²¡æœ‰ textï¼šæ¸…ç©º
        nodeOps.setTextContent(elm, '')
      }
    } else if (oldVnode.text !== vnode.text) {
      // æ–°èŠ‚ç‚¹æœ‰textï¼Œæ–°è€ text ä¸åŒï¼ˆå¦‚æœç›¸åŒå°±ä¸æ”¹äº†ï¼‰æ—¶ï¼š
      nodeOps.setTextContent(elm, vnode.text)
    }

    // é’©å­ï¼Œæš‚æ—¶ä¸çœ‹äº†
    if (isDef(data)) {
      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)
    }
  }
</code></pre>
<ul>
<li>updateChildren</li>
</ul>
<h3 id="31-updatechildren">3.1 updateChildren</h3>
<p>updateChildren çš„ä¸»è¦ä½œç”¨æ˜¯ç”¨ä¸€ç§è¾ƒé«˜æ•ˆçš„æ–¹å¼æ¯”å¯¹æ–°æ—§ä¸¤ä¸ª VNode çš„ childrenï¼Œå¾—å‡ºæœ€å°æ“ä½œã€‚</p>
<p>ä¼ ç»Ÿæ–¹å¼æ˜¯æ‰§è¡Œä¸€ä¸ªåŒå¾ªç¯ï¼ŒVue ä¸­é’ˆå¯¹ web  åœºæ™¯ç‰¹ç‚¹åšäº†ç‰¹åˆ«çš„ç®—æ³•ä¼˜åŒ–ï¼š</p>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1584051570854.png" alt="" loading="lazy"></figure>
<p>æ–°è€ä¸¤ç»„ VNode èŠ‚ç‚¹çš„å·¦å³å¤´å°¾ä¸¤ä¾§éƒ½æœ‰ä¸€ä¸ªå˜é‡æ ‡è®°ï¼Œåœ¨éå†è¿‡ç¨‹ä¸­è¿™å‡ ä¸ªå˜é‡éƒ½ä¼šå‘ä¸­é—´é æ‹¢ã€‚å½“ oldStartIdx &gt; oldEndIdx æˆ–è€… newStartIdx &gt; newEndIdx æ—¶ï¼Œç»“æŸå¾ªç¯ï¼ˆä¸éœ€è¦å† updateChildrenï¼Œè€Œæ˜¯åšå…¶ä»–æ“ä½œï¼‰ã€‚</p>
<p>ä¸‹é¢æ˜¯éå†è§„åˆ™ï¼š</p>
<p>é¦–å…ˆï¼ŒoldStartVNodeã€oldEndVNode ä¸ newStartVNodeã€newEndVNode <strong>ä¸¤ä¸¤äº¤å‰æ¯”è¾ƒ</strong>ï¼Œå…±æœ‰ 4 ç§æ¯”è¾ƒæ–¹æ³•ã€‚å…¶ä¸­å½“ oldStartVNode å’Œ newStartVNode æˆ–è€… oldEndVNode å’Œ newEndVNode æ»¡è¶³ sameVNodeï¼Œç›´æ¥å°†è¯¥ VNode èŠ‚ç‚¹è¿›è¡Œ patchVNode å³å¯ï¼Œä¸éœ€è¦å†éå†å°±å®Œæˆäº†ä¸€æ¬¡å¾ªç¯ï¼ˆä¹‹åå¯¹åé¢çš„å…ƒç´ è¿›è¡Œä¸‹ä¸€æ¬¡å¾ªç¯ï¼‰ï¼š</p>
<figure data-type="image" tabindex="3"><img src="https://yuufen.com/blog/post-images/1584051578325.png" alt="" loading="lazy"></figure>
<p>å¦‚æœ oldStartVNode ä¸ newEndVNode æ»¡è¶³ sameVNodeï¼Œè¯´æ˜ oldStartVNode å·²ç»è¢«ç§»åŠ¨åˆ° oldEndVNode åé¢äº†ï¼Œè¿›è¡ŒpatchVNode çš„åŒæ—¶è¿˜è¦å°†çœŸå® DOM èŠ‚ç‚¹ç§»åŠ¨åˆ° oldEndVNode çš„åé¢ï¼ˆä¹‹åå¯¹åé¢çš„å…ƒç´ è¿›è¡Œä¸‹ä¸€æ¬¡å¾ªç¯ï¼‰ï¼š</p>
<figure data-type="image" tabindex="4"><img src="https://yuufen.com/blog/post-images/1584051582834.png" alt="" loading="lazy"></figure>
<p>å¦‚æœ oldEndVNode ä¸ oldEndVNode newStartVNode æ»¡è¶³ sameVNodeï¼Œè¯´æ˜ oldEndVNode å·²ç»è¢«ç§»åŠ¨åˆ° newStartVNode å‰é¢äº†ï¼Œè¿›è¡ŒpatchVNode çš„åŒæ—¶è¿˜è¦å°†çœŸå® DOM èŠ‚ç‚¹ç§»åŠ¨åˆ° newStartVNode çš„å‰é¢ï¼ˆä¹‹åå¯¹åé¢çš„å…ƒç´ è¿›è¡Œä¸‹ä¸€æ¬¡å¾ªç¯ï¼‰ï¼š</p>
<figure data-type="image" tabindex="5"><img src="https://yuufen.com/blog/post-images/1584051587249.png" alt="" loading="lazy"></figure>
<p>å¦‚æœä»¥ä¸Šæƒ…å†µéƒ½ä¸ç¬¦åˆï¼Œåˆ™åœ¨ old VNode ä¸­æ‰¾ä¸ newStartVNode æ»¡è¶³ sameVNode çš„ VNodeï¼ˆæ ‡è®°ä¸º vnodeToMoveï¼‰ï¼Œè‹¥å­˜åœ¨ï¼Œåˆ™æ‰§è¡Œ patchVNodeï¼ŒåŒæ—¶å°† vnodeToMove å¯¹åº” DOM ç§»åŠ¨åˆ° oldStartVNode å¯¹åº” DOM çš„å‰é¢ï¼ˆç„¶åå°† new VNode ä¸­æ¸¸æ ‡åç§»ä¸€ä¸ªï¼Œè¿›å…¥ä¸‹ä¸€æ¬¡å¾ªç¯ï¼‰ï¼š</p>
<figure data-type="image" tabindex="6"><img src="https://yuufen.com/blog/post-images/1584051592284.png" alt="" loading="lazy"></figure>
<p>ä¹Ÿæœ‰å¯èƒ½ newStartVNode åœ¨ old VNode ä¸­æ‰¾ä¸åˆ° sameVNodeï¼Œè¿™æ˜¯ä¼šè°ƒç”¨ createElm åˆ›å»ºä¸€ä¸ªæ–°çš„ DOM èŠ‚ç‚¹ï¼š</p>
<figure data-type="image" tabindex="7"><img src="https://yuufen.com/blog/post-images/1584051596648.png" alt="" loading="lazy"></figure>
<p>ç›´åˆ°å¾ªç¯ç»“æŸï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜éœ€è¦å¤„ç†å‰©ä¸‹çš„èŠ‚ç‚¹ï¼š</p>
<ol>
<li>å¦‚æœç»“æŸæ—¶ oldStartIdx &gt; oldEndIdxï¼Œè¯´æ˜è¿™ä¸ªæ—¶å€™æ—§çš„ VNode èŠ‚ç‚¹å·²ç»éå†å®Œäº†ï¼Œä½†æ˜¯æ–°çš„èŠ‚ç‚¹è¿˜æ²¡æœ‰ï¼›è¯´æ˜æ–°çš„ VNode èŠ‚ç‚¹å®é™…ä¸Šæ¯”è€çš„ VNode èŠ‚ç‚¹å¤šï¼Œéœ€è¦å°†å‰©ä¸‹çš„ VNode å¯¹åº”çš„ DOM æ’å…¥åˆ°çœŸå® DOM ä¸­ï¼Œæ­¤æ—¶è°ƒç”¨ addVNodesï¼ˆå…¶ä¸­æ‰¹é‡è°ƒç”¨ createE lm æ¥å£ï¼‰ï¼š</li>
</ol>
<figure data-type="image" tabindex="8"><img src="https://yuufen.com/blog/post-images/1584051601336.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>å¦‚æœ newStart &gt; newEndIdxï¼Œè¯´æ˜æ–°çš„ VNode èŠ‚ç‚¹å·²ç»éå†å®Œäº†ï¼Œä½†æ˜¯è€çš„èŠ‚ç‚¹è¿˜æœ‰å¤šï¼Œéœ€è¦æ‰§è¡Œ remove æ“ä½œ</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://yuufen.com/blog/post-images/1584051605554.png" alt="" loading="lazy"></figure>
<pre><code class="language-js">  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    let oldStartIdx = 0
    let newStartIdx = 0
    let oldEndIdx = oldCh.length - 1
    let oldStartVnode = oldCh[0]
    let oldEndVnode = oldCh[oldEndIdx]
    let newEndIdx = newCh.length - 1
    let newStartVnode = newCh[0]
    let newEndVnode = newCh[newEndIdx]
    let oldKeyToIdx, idxInOld, vnodeToMove, refElm

    // removeOnly is a special flag used only by &lt;transition-group&gt;
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    const canMove = !removeOnly

    if (process.env.NODE_ENV !== 'production') {
      checkDuplicateKeys(newCh)
    }

    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx]
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
        oldStartVnode = oldCh[++oldStartIdx]
        newStartVnode = newCh[++newStartIdx]
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
        oldEndVnode = oldCh[--oldEndIdx]
        newEndVnode = newCh[--newEndIdx]
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
        oldStartVnode = oldCh[++oldStartIdx]
        newEndVnode = newCh[--newEndIdx]
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
        oldEndVnode = oldCh[--oldEndIdx]
        newStartVnode = newCh[++newStartIdx]
      } else {
        // æ–°è€é¦–å°¾ä¸¤ä¸¤ä¸åŒï¼Œå¼€å§‹éå† 
        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
        if (isUndef(idxInOld)) { // New element
          // æ–°å…ƒç´ åœ¨è€çš„é‡Œé¢ä¸å­˜åœ¨
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
        } else {
          vnodeToMove = oldCh[idxInOld]
          if (sameVnode(vnodeToMove, newStartVnode)) {
            // æ‰¾åˆ°äº†ç›¸åŒçš„
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
            oldCh[idxInOld] = undefined
            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
          }
        }
        newStartVnode = newCh[++newStartIdx]
      }
    }
    // å¾ªç¯ç»“æŸä¹‹åï¼Œæ–°è€ VNode å¯èƒ½æœ‰è¿˜æœ‰ä¸€ä¸ªçš„å­©å­èŠ‚ç‚¹æ²¡æœ‰å¤„ç†å®Œ
    if (oldStartIdx &gt; oldEndIdx) {
      // æ–°çš„è¿˜å‰©ï¼Œæ‰¹é‡æ–°å¢
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
    } else if (newStartIdx &gt; newEndIdx) {
      //è€çš„è¿˜å‰©ï¼Œæ‰¹é‡åˆ é™¤
      removeVnodes(oldCh, oldStartIdx, oldEndIdx)
    }
  }
</code></pre>
<h3 id="32-å±æ€§æ›´æ–°">3.2 å±æ€§æ›´æ–°</h3>
<pre><code class="language-js">// patch.js
const hooks = ['create', 'activate', 'update', 'remove', 'destroy']
export function createPatchFunction (backend) {
  let i, j
  const cbs = {}

  // ä¼ è¿›æ¥çš„æ‰©å±•æ¨¡å—å’ŒèŠ‚ç‚¹æ“ä½œå¯¹è±¡
  const { modules, nodeOps } = backend

  for (i = 0; i &lt; hooks.length; ++i) {
    // cbs['update'] = []
    cbs[hooks[i]] = []
    //modules: [ attrs, klass, events, domProps, style, transition]
    for (j = 0; j &lt; modules.length; ++j) {
      // modules[0]['update'] æ˜¯åˆ›å»ºå±æ€§æ‰§â¾è¡Œï¨ˆå‡½æ•°ï¼Œå…¶ä»–hookä»¥æ­¤ç±»æ¨
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]])
      }
    }
    // cbs['update']: [fn,fn,fn....]
  }
  // ...
    
  function patchVnode (...) {
    // æ›´æ–°å±æ€§
    if (isDef(data) &amp;&amp; isPatchable(vnode)) {
      // æ¯æ¬¡ patch å…ˆæ›´æ–°å±æ€§
      for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)
      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)
    }
    // ...
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue æºç è§£æï¼šæ•°æ®å“åº”å¼]]></title>
        <id>https://yuufen.com/blog/post/LGEsZIcVg/</id>
        <link href="https://yuufen.com/blog/post/LGEsZIcVg/">
        </link>
        <updated>2020-03-05T21:21:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="æŒ‰å¼•ç”¨é¡ºåº-æ¦‚è§ˆ">æŒ‰å¼•ç”¨é¡ºåº æ¦‚è§ˆ</h2>
<h3 id="srccoreinstancestatejs-initdata">src\core\instance\state.js &gt; initData</h3>
<pre><code class="language-js">function initData (vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  if (!isPlainObject(data)) {
	// data functions should return an object
    data = {}
  }
  // proxy data on instance
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if ( /* key æ˜¯å¯ä»¥ä½¿ç”¨çš„ï¼ˆæ²¡æœ‰è¢«å ç”¨ä¹Ÿä¸æ˜¯ä¿ç•™åï¼‰ */ ) {
      // è®¾ç½®ä»£ç†ï¼ŒæŠŠ key ç›´æ¥æŒ‚è½½å®ä¾‹ this ä¸Š
      proxy(vm, `_data`, key)
    }
  }
  // observe data
  // æ ¸å¿ƒï¼šè®¾ç½®å“åº”å¼
  observe(data, true /* asRootData */)
}
</code></pre>
<ul>
<li>proxy</li>
<li>observe</li>
</ul>
<h3 id="srccoreobserverindexjs-observe">src\core\observer\index.js &gt; observe</h3>
<pre><code class="language-js">/**
 * å°è¯•åˆ›å»ºè§‚å¯Ÿè€…å®ä¾‹
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
export function observe (value: any, asRootData: ?boolean): Observer | void {
  // å¦‚æœä¸æ˜¯ objectï¼Œç›´æ¥ return äº†ï¼ˆæ•°ç»„ä¹Ÿç®—æ˜¯ objcetï¼‰
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  let ob: Observer | void
  if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    shouldObserve &amp;&amp;
    !isServerRendering() &amp;&amp;
    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;
    Object.isExtensible(value) &amp;&amp;
    !value._isVue
  ) {
    ob = new Observer(value)
  }
  if (asRootData &amp;&amp; ob) {
    ob.vmCount++
  }
  return ob
}
</code></pre>
<ul>
<li>Observer</li>
</ul>
<h3 id="srccoreobserverindexjs-observer">src\core\observer\index.js &gt; observer</h3>
<pre><code class="language-js">/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    def(value, '__ob__', this)

    // åˆ¤æ–­å½“å‰çš„valueæ˜¯æ•°ç»„ / Object
    if (Array.isArray(value)) {
      // å¦‚æœæ˜¯æ•°ç»„
      // å°±æŠŠæ•°ç»„çš„ 7 ä¸ªå¯ä»¥æ”¹å˜æ•°æ®çš„æ–¹æ³•å…¨æ‹¦æˆªäº†
      if (hasProto) {
        // å…¼å®¹æ€§å¤„ç†ï¼Œå¦‚æœæµè§ˆå™¨æœ‰åŸå‹
        protoAugment(value, arrayMethods)
      } else {
        // å¦‚æœæµè§ˆå™¨æ²¡æœ‰åŸå‹
        copyAugment(value, arrayMethods, arrayKeys)
      }
      // ç„¶åå¾ªç¯ä¸€é
      this.observeArray(value)
    } else {
      // å¦‚æœæ˜¯å¯¹è±¡
      this.walk(value)
    }
  }

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i &lt; keys.length; i++) {
      // æ¯ä¸€é¡¹éƒ½èµ°ä¸€é
      defineReactive(obj, keys[i])
    }
  }

  /**
   * Observe a list of Array items.
   */
  // å¦‚æœæ˜¯å¯¹è±¡åˆ—è¡¨ï¼Œåˆ™æ¯ä¸€é¡¹éƒ½èµ°ä¸€é observe
  observeArray (items: Array&lt;any&gt;) {
    for (let i = 0, l = items.length; i &lt; l; i++) {
      // ç›´æ¥ä¼ å…¥æ•°ç»„å…ƒç´ ï¼Œçœç•¥åœ¨é”®ä¸Šè®¾ç½® getter/setter çš„æ­¥éª¤
      observe(items[i]) // å¼•ç”¨å˜é‡ï¼Œä¼ å…¥çš„æ˜¯æŒ‡å‘çš„å€¼
    }
  }
}
</code></pre>
<ul>
<li>arrayMethods</li>
<li>defineReactive</li>
</ul>
<h3 id="srccoreobserverindexjs-definereactive">src\core\observer\index.js &gt; defineReactive</h3>
<pre><code class="language-js">export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property &amp;&amp; property.configurable === false) {
    return
  }

  // å¦‚æœç”¨æˆ·è‡ªå·±è®¾ç½®äº†getterå’Œsetterçš„å¤„ç†
  const getter = property &amp;&amp; property.get
  const setter = property &amp;&amp; property.set
  if ((!getter || setter) &amp;&amp; arguments.length === 2) {
    // åŸç†å’Œæˆ‘ä»¬å®ç°çš„ä¸€æ ·
    val = obj[key]
  }

  // å¦‚æœè¿˜æ˜¯å¯¹è±¡ï¼Œé€’å½’ï¼Œå…ˆæ‰§è¡Œ
  let childOb = !shallow &amp;&amp; observe(val)
  // å­å¯¹è±¡å¤„ç†å®Œä¹‹åï¼š
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // å¦‚æœç”¨æˆ·è‡ªå·±è®¾ç½®äº†getter
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        // Dep.target æ˜¯ä¸€ä¸ª watcher å®ä¾‹
        // åŸç†å’Œæˆ‘ä»¬å®ç°çš„ä¸€æ ·ï¼Œå¦‚æœå­˜åœ¨ targetï¼Œå°±æ·»åŠ åˆ° Dep å®ä¾‹ä¸Š
        // ä½†æ˜¯è¿™é‡ŒåŒæ—¶ä¼šæŠŠ dep çš„ id ä¿å­˜åœ¨ watcher ä¸Šï¼Œæ˜¯å¤šå¯¹å¤šçš„å…³ç³»
        // è¿˜æœ‰ä¸€ç‚¹ï¼šè¿™é‡Œçš„ watcher æ˜¯ç»„ä»¶çº§çš„ï¼ˆå¦‚æœä¸ä½¿ç”¨$watcherï¼‰
        // å¦‚æœä¸ä½¿ç”¨$watcherï¼Œä¸€ä¸ªç»„ä»¶åªæœ‰ä¸€ä¸ªwatcherå®ä¾‹ï¼ˆåˆ›å»ºç»„ä»¶æ—¶ä¼š new ä¸€ä¸ªï¼‰
        // å®ƒä¼šæŠŠæ›´æ–°æ¶ˆæ¯ä¼ é€’ç»™ç»„ä»¶ï¼Œç„¶åç»„ä»¶åœ¨è¿›è¡Œè™šæ‹Ÿ DOM ç­‰æ“ä½œ
        // ï¼ˆ$watcher è¿˜æ²¡æœ‰çœ‹åˆ°ï¼‰
        dep.depend()
        if (childOb) {
          // çˆ¶å¯¹è±¡æ›´æ–°æ—¶å­å¯¹è±¡è¦æ›´æ–°ï¼ŒåŒæ—¶
          // å­å¯¹è±¡æ›´æ–°ä¹‹åï¼Œçˆ¶å¯¹è±¡ä¹Ÿè¦æ›´æ–°
          // æ¯”å¦‚ä» &quot;{foo: 'foo'}&quot; å˜æˆ &quot;{doo: 'doo'}&quot;
          // æ‰€ä»¥è¦æŠŠè¿™ä¸ª watcher æ·»åŠ ç»™ childOb çš„ dep
          childOb.dep.depend()
          if (Array.isArray(value)) {
            // å¦‚æœæ˜¯æ•°ç»„ï¼Œè¿˜éœ€è¦å¾ªç¯
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter &amp;&amp; !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      // æ¯”å¦‚æœ¬æ¥æ˜¯ 'str'ï¼Œç”¨æˆ·æ”¹æˆäº† {foo: 'str}
      // æ‰€ä»¥è¦é€’å½’
      childOb = !shallow &amp;&amp; observe(newVal)
      dep.notify()
    }
  })
}
</code></pre>
<ul>
<li>Dep.target ï¼ˆæœªç†æ¸…ï¼‰</li>
<li>Dep</li>
<li>Watcher</li>
</ul>
<h3 id="srccoreobserverwatcherjs">src\core\observer\watcher.js</h3>
<pre><code class="language-js">  constructor (
    vm: Component,
    expOrFn: string | Function, // $watcher('foo.bar') / ç»„ä»¶çš„çš„ updateComponent
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm
    // å¦‚æœæ˜¯render watcherï¼Œå•ç‹¬ä¿å­˜
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this)
    // options
 	// ä¸€äº›ç»†èŠ‚
    // ã€‚ã€‚ã€‚
      
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      // å¦‚æœæ˜¯ç»„ä»¶åˆ›å»ºæ—¶åˆ›å»ºçš„ watcher å®ä¾‹ï¼ˆrender watcherï¼‰
      // getter å°±æ˜¯æ›´æ–° DOM çš„æ–¹æ³•
      // å½“ç„¶ä¹Ÿå¯èƒ½æ˜¯watchï¼ŒåŸç†ä¸€æ ·ï¼Œéƒ½æ˜¯è°ƒç”¨æ–¹æ³•
      this.getter = expOrFn
    } else {
      // å¦‚æœæ˜¯å¦‚ $watcher('foo.bar') åˆ›å»ºçš„ watcherå®ä¾‹
      // getter å°±æ˜¯è·å– vm[foo][bar] çš„æ–¹æ³•ï¼ˆå°±æ˜¯æˆ‘ä¹‹å‰å†™çš„å¤„ç†åµŒå¥—çš„æ–¹æ³•ï¼‰
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = noop
        process.env.NODE_ENV !== 'production' &amp;&amp; warn(
          `Failed watching path: &quot;${expOrFn}&quot; ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get() // è¿™é‡Œè°ƒç”¨äº†getï¼Œgetä¸­è°ƒç”¨äº†ä¸Šé¢çš„getter
  }
  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      // watcher é˜Ÿåˆ—ï¼Œæ‰¹é‡æ‰§è¡Œï¼Œä½¿ç”¨ nextTick å‡å°‘ DOM æ“ä½œ
      queueWatcher(this)
    }
  }
</code></pre>
<ul>
<li>
<p>queueWatcher</p>
<ul>
<li>
<p>nextTick</p>
<ul>
<li>timerFunc</li>
</ul>
<blockquote>
<p>å„ç§å…¼å®¹å›é€€ï¼Œé¦–é€‰å¾®ä»»åŠ¡ã€‚</p>
<p>ä¸€æ¬¡å®ä»»åŠ¡æ‰§è¡Œå®Œä¹‹åæµè§ˆå™¨ä¼šåˆ·æ–°ä¸€æ¬¡ç”»é¢ï¼Œæ‰€ä»¥é¦–é€‰å…ˆåœ¨å¾®ä»»åŠ¡ä¸­æ·»åŠ  DOM æ“ä½œï¼Œåœ¨ä¸€æ¬¡å®ä»»åŠ¡ä¸­æ‰¹é‡æ“ä½œã€‚</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="ç»†èŠ‚">ç»†èŠ‚</h2>
<h3 id="æ•°ç»„çš„å“åº”å¼-arraymethods">æ•°ç»„çš„å“åº”å¼ arrayMethods</h3>
<pre><code class="language-js">/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

import { def } from '../util/index'

const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)

// 7 ä¸ªå¯ä»¥æ”¹å˜æ•°ç»„çš„æ–¹æ³•
const methodsToPatc h = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  // æ·»åŠ é¢å¤–çš„åŠŸèƒ½ï¼šé€šçŸ¥æ›´æ–°
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args)
    const ob = this.__ob__

    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    // å¦‚æœæ˜¯æ’å…¥æ“ä½œï¼Œæ–°å¢å…ƒç´ ï¼Œåˆ™éœ€è¦é¢å¤–åšå“åº”å¼
    if (inserted) ob.observeArray(inserted)
    
    // notify change
    ob.dep.notify()
    return result
  })
})
</code></pre>
<blockquote>
<h2 id="æ•°ç»„å°å‘">æ•°ç»„å°å‘</h2>
<pre><code class="language-js">// Observer ä¸­
observeArray (items: Array&lt;any&gt;) {
  for (let i = 0, l = items.length; i &lt; l; i++) {
    // ç›´æ¥ä¼ å…¥æ•°ç»„å…ƒç´ ï¼Œçœç•¥åœ¨é”®ä¸Šè®¾ç½® getter/setter çš„æ­¥éª¤
    observe(items[i]) // å¼•ç”¨å˜é‡ï¼Œä¼ å…¥çš„æ˜¯æŒ‡å‘çš„å€¼
  }
}
</code></pre>
<p>æ‰€ä»¥æ•°ç»„çš„é”®æ²¡æœ‰é…ç½® getter / setterï¼Œæ‰€ä»¥ Vue ä¸­æ•°ç»„æœ‰å“åº”å¼çš„æ“ä½œåªæœ‰è¿™ä¸ƒç§ï¼Œç›´æ¥é€šè¿‡ç´¢å¼•èµ‹å€¼ä¹Ÿä¸è¡Œï¼ˆåªèƒ½é€šè¿‡$setï¼‰ã€‚</p>
<pre><code class="language-js">this.arr[0] = '123434312122' // æ”¹çš„æ˜¯é”®ï¼ˆåœ°å€ï¼‰ï¼ŒæŒ‡å‘çš„å€¼æ²¡æœ‰å˜ï¼Œæ— å“åº”å¼æ›´æ–°
this.arr[0] = { doo: 'doo' } // æ”¹çš„æ˜¯é”®ï¼ˆåœ°å€ï¼‰ï¼ŒæŒ‡å‘çš„å€¼æ²¡æœ‰å˜ï¼Œæ— å“åº”å¼æ›´æ–°
this.arr[0].foo = 'doo' // æœ‰æ›´æ–°
this.$set(this.arr, 0, { doo: 'doo' }) // æœ‰æ›´æ–°
</code></pre>
<p>å› ä¸º js æ“ä½œæ•°ç»„å¾ˆå®¹æ˜“æ”¹å˜keyï¼Œå¦‚æœä½¿ç”¨getter / setterï¼Œå¾ˆå®¹æ˜“å¤±æ•ˆã€‚</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue æºç è§£æï¼šä»å…¥å£æ–‡ä»¶åˆ° Vue å£°æ˜ï¼Œcreate]]></title>
        <id>https://yuufen.com/blog/post/sW2ztpxVO/</id>
        <link href="https://yuufen.com/blog/post/sW2ztpxVO/">
        </link>
        <updated>2020-03-05T08:46:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="ç»å†äº†ä»€ä¹ˆ">ç»å†äº†ä»€ä¹ˆ</h2>
<p>src/platforms/web/entry-runtime-with-compiler.js</p>
<pre><code class="language-js">import Vue from './runtime/index'

const mount = Vue.prototype.$mount
</code></pre>
<p>src/platforms/web/runtime.js</p>
<pre><code class="language-js">import Vue from 'core/index'

// ...

// è¡¥ä¸ç®—æ³•ï¼ŒVNode diff -&gt; DOM
Vue.prototype.__patch__ = inBrowser ? patch : noop

// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el &amp;&amp; inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
</code></pre>
<ul>
<li>mountComponent
<ul>
<li>è™šæ‹Ÿ DOM</li>
<li>diff</li>
<li>patch</li>
<li>......</li>
</ul>
</li>
<li>_<em>patch</em>_</li>
</ul>
<p>src/core/index.js</p>
<pre><code class="language-js">import Vue from './instance/index'

initGlobalAPI(Vue)
</code></pre>
<ul>
<li>initGlobalAPI
<ul>
<li>set</li>
<li>delete</li>
<li>nextTick</li>
<li>......</li>
</ul>
</li>
</ul>
<p>src/core/instance/index.js æ€»ç®—åˆ°ç«™äº†</p>
<pre><code class="language-js">function Vue (options) {
  this._init(options)
}

// åˆå¹¶å‚æ•°ã€åˆå§‹åŒ– $parent ç­‰å±æ€§ã€åˆå§‹åŒ–äº‹ä»¶ä¸­å¿ƒã€æŒ‚è½½ h å‡½æ•°ï¼ˆ$createElementï¼‰
// è°ƒç”¨ç”Ÿå‘½å‘¨æœŸé’©å­ beforeCreate
// è·å–æ³¨å…¥çš„æ•°æ®ã€åˆå§‹åŒ– propsã€methodsã€dataã€computedã€watch
// æ³¨å…¥æ•°æ®å¤„ç†
// è°ƒç”¨ç”Ÿå‘½å‘¨æœŸé’©å­ created
initMixin(Vue) 
// å®ç° $setã€$deleteã€$watch
stateMixin(Vue)
// å®ç° $onã€$onceã€$offã€$emit
eventsMixin(Vue)
// å®ç° _updateï¼ˆè°ƒç”¨è¡¥ä¸ç®—æ³•ï¼‰ã€$forceUpdateã€$destroy
lifecycleMixin(Vue)
// installRenderHelpers
// å®ç°äº† $nextTickã€_render(è¿™é‡Œè°ƒç”¨ $options ä¸Šçš„æ¸²æŸ“å‡½æ•°)
renderMixin(Vue)
</code></pre>
<ul>
<li>initMixin
<ul>
<li>initLifecycle</li>
<li>initEvents</li>
<li>initRender</li>
<li>callHook(vm, 'beforeCreate')</li>
<li>initInjections</li>
<li>initState (<a href="https://yuufen.com/blog/post/LGEsZIcVg/">æ•°æ®å“åº”å¼ç»†èŠ‚</a>)</li>
<li>initProvide</li>
<li>callHook(vm, 'created')</li>
</ul>
</li>
<li>stateMixin
<ul>
<li>$set</li>
<li>$delete</li>
<li>$watch</li>
</ul>
</li>
<li>eventsMixin
<ul>
<li>$on</li>
<li>$once</li>
<li>$off</li>
<li>$emit</li>
</ul>
</li>
<li>lifecycleMixin
<ul>
<li>_updateï¼ˆè°ƒç”¨è¡¥ä¸ç®—æ³•ï¼‰</li>
<li>$forceUpdate</li>
<li>$destroy</li>
</ul>
</li>
<li>renderMixin
<ul>
<li>installRenderHelpers</li>
<li>$nextTick</li>
<li>_render(è¿™é‡Œè°ƒç”¨initæŒ‚è½½çš„æ¸²æŸ“å‡½æ•°)</li>
</ul>
</li>
</ul>
<h2 id="initmixin">initMixin</h2>
<pre><code class="language-js">export function initMixin (Vue: Class&lt;Component&gt;) {
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++

    let startTag, endTag
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // a flag to avoid this being observed
    vm._isVue = true
    // åˆå¹¶å‚æ•°
    if (options &amp;&amp; options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') { 
      initProxy(vm) // è®¾ç½®ä¸Šä¸‹æ–‡
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    initLifecycle(vm) // åˆå§‹åŒ–ä¸å½“å‰ç»„ä»¶ç›¸å…³çš„å±æ€§ï¼ˆ$parentç­‰ç­‰ï¼‰ï¼ˆè¿™æ—¶parentå·²ç»å­˜åœ¨äº†ï¼‰
    initEvents(vm) // åˆå§‹åŒ–äº‹ä»¶ä¸­å¿ƒ
    initRender(vm) // å®šä¹‰äº† vm.$createElement ï¼ˆrender å‡½æ•°é‡Œçš„ h å‡½æ•°ï¼‰
    callHook(vm, 'beforeCreate') // è°ƒç”¨ç”Ÿå‘½å‘¨æœŸé’©å­ beforeCreate
    initInjections(vm) // è·å–æ³¨å…¥çš„æ•°æ®ï¼ˆæ˜¯å“åº”å¼çš„ï¼‰ï¼Œåœ¨ initState ä¹‹å‰
    initState(vm) // åˆå§‹åŒ– propsã€methodsã€dataã€computedã€watch
    initProvide(vm) // æ³¨å…¥æ•°æ®å¤„ç†ï¼Œåœ¨ initState ä¹‹å
    callHook(vm, 'created') // è°ƒç”¨ç”Ÿå‘½å‘¨æœŸé’©å­ created

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
</code></pre>
<h3 id="initevents">initEvents</h3>
<pre><code class="language-js">
export function initEvents (vm: Component) {
  vm._events = Object.create(null)
  vm._hasHookEvent = false
  // init parent attached events
  const listeners = vm.$options._parentListeners
  if (listeners) {
    updateComponentListeners(vm, listeners)
  }
}
</code></pre>
<ul>
<li>updateComponentListeners</li>
</ul>
<h3 id="initstate">initState</h3>
<pre><code class="language-js">export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
</code></pre>
<ul>
<li>initProps</li>
<li>initMethods</li>
<li>initData</li>
<li>initComputed</li>
<li>watch</li>
</ul>
<h2 id="statemixin">stateMixin</h2>
<pre><code class="language-js">export function stateMixin (Vue: Class&lt;Component&gt;) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  const dataDef = {}
  dataDef.get = function () { return this._data }
  const propsDef = {}
  propsDef.get = function () { return this._props }
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function () {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      )
    }
    propsDef.set = function () {
      warn(`$props is readonly.`, this)
    }
  }
  // æŒ‚è½½åªè¯»å±æ€§
  Object.defineProperty(Vue.prototype, '$data', dataDef)
  Object.defineProperty(Vue.prototype, '$props', propsDef)
  // æŒ‚è½½äº† $setã€$deleteã€$watch
  Vue.prototype.$set = set
  Vue.prototype.$delete = del

  Vue.prototype.$watch = function (...
  }
}
</code></pre>
<h2 id="eventsmixinæœªå®Œæˆ">eventsMixinï¼ˆæœªå®Œæˆï¼‰</h2>
<pre><code class="language-js">export function eventsMixin (Vue: Class&lt;Component&gt;) {
  const hookRE = /^hook:/
  Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component {
    const vm: Component = this
    if (Array.isArray(event)) {
      for (let i = 0, l = event.length; i &lt; l; i++) {
        vm.$on(event[i], fn)
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn)
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true
      }
    }
    return vm
  }

  Vue.prototype.$once = function (event: string, fn: Function): Component {
    const vm: Component = this
    function on () {
      vm.$off(event, on)
      fn.apply(vm, arguments)
    }
    on.fn = fn
    vm.$on(event, on)
    return vm
  }

  Vue.prototype.$off = function (event?: string | Array&lt;string&gt;, fn?: Function): Component {
    const vm: Component = this
    // all
    if (!arguments.length) {
      vm._events = Object.create(null)
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (let i = 0, l = event.length; i &lt; l; i++) {
        vm.$off(event[i], fn)
      }
      return vm
    }
    // specific event
    const cbs = vm._events[event]
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null
      return vm
    }
    // specific handler
    let cb
    let i = cbs.length
    while (i--) {
      cb = cbs[i]
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1)
        break
      }
    }
    return vm
  }

  Vue.prototype.$emit = function (event: string): Component {
    const vm: Component = this
    if (process.env.NODE_ENV !== 'production') {
      const lowerCaseEvent = event.toLowerCase()
      if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) {
        tip(
          `Event &quot;${lowerCaseEvent}&quot; is emitted in component ` +
          `${formatComponentName(vm)} but the handler is registered for &quot;${event}&quot;. ` +
          `Note that HTML attributes are case-insensitive and you cannot use ` +
          `v-on to listen to camelCase events when using in-DOM templates. ` +
          `You should probably use &quot;${hyphenate(event)}&quot; instead of &quot;${event}&quot;.`
        )
      }
    }
    let cbs = vm._events[event]
    if (cbs) {
      cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs
      const args = toArray(arguments, 1)
      const info = `event handler for &quot;${event}&quot;`
      for (let i = 0, l = cbs.length; i &lt; l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info)
      }
    }
    return vm
  }
}
</code></pre>
<h2 id="lifecyclemixinæœªå®Œæˆ">lifecycleMixinï¼ˆæœªå®Œæˆï¼‰</h2>
<pre><code class="language-js">export function lifecycleMixin (Vue: Class&lt;Component&gt;) {
  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this
    const prevEl = vm.$el
    const prevVnode = vm._vnode
    const restoreActiveInstance = setActiveInstance(vm)
    vm._vnode = vnode
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode)
    }
    restoreActiveInstance()
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  }

  Vue.prototype.$forceUpdate = function () {
    const vm: Component = this
    if (vm._watcher) {
      vm._watcher.update()
    }
  }

  Vue.prototype.$destroy = function () {
    const vm: Component = this
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy')
    vm._isBeingDestroyed = true
    // remove self from parent
    const parent = vm.$parent
    if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) {
      remove(parent.$children, vm)
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown()
    }
    let i = vm._watchers.length
    while (i--) {
      vm._watchers[i].teardown()
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--
    }
    // call the last hook...
    vm._isDestroyed = true
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null)
    // fire destroyed hook
    callHook(vm, 'destroyed')
    // turn off all instance listeners.
    vm.$off()
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null
    }
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue æºç è§£æï¼šå¯åŠ¨é¡¹ç›®ä¸å…¥å£æ–‡ä»¶åˆ†æ]]></title>
        <id>https://yuufen.com/blog/post/28tbvr2E1/</id>
        <link href="https://yuufen.com/blog/post/28tbvr2E1/">
        </link>
        <updated>2020-03-04T10:40:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="å¯åŠ¨é¡¹ç›®">å¯åŠ¨é¡¹ç›®</h2>
<h3 id="è·å–-vue-é¡¹ç›®">è·å– Vue é¡¹ç›®</h3>
<p>é¡¹ç›®åœ°å€ï¼šhttps://github.com/vuejs/vue</p>
<p>å½“å‰ç‰ˆæœ¬ï¼š2.6.11</p>
<h3 id="è°ƒè¯•æ–¹å¼">è°ƒè¯•æ–¹å¼</h3>
<ol>
<li>æµè§ˆå™¨è°ƒè¯•ï¼ˆæˆ‘ä»¬é€‰æ‹©è¿™ä¸€é¡¹ï¼‰</li>
<li>ä½¿ç”¨æ‹¦æˆªå™¨æˆ–å…¶ä»–å·¥å…·</li>
</ol>
<h3 id="è°ƒè¯•ç¯å¢ƒæ­å»º">è°ƒè¯•ç¯å¢ƒæ­å»º</h3>
<ul>
<li>
<p>å®‰è£…ä¾èµ–ï¼š<code>npm i</code></p>
</li>
<li>
<p>å®‰è£… rollupï¼š<code>npm i -g rollup</code></p>
</li>
</ul>
<blockquote>
<p>rollup æ˜¯æ‰“åŒ…å·¥å…·ï¼Œç”¨äºæ‰“åŒ…çº¯ä»£ç é¡¹ç›®ï¼Œvue ä½¿ç”¨äº† rollup æ‰“åŒ…</p>
</blockquote>
<ul>
<li>package.json ä¸­ä¿®æ”¹ dev è„šæœ¬ï¼Œæ·»åŠ  sourcemapï¼Œæ–¹ä¾¿è°ƒè¯•</li>
</ul>
<pre><code>&quot;dev&quot;: &quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev&quot;,
</code></pre>
<ul>
<li>è¿è¡Œå¼€å‘ç‰ˆæœ¬æ‰“åŒ…å‘½ä»¤ï¼š<code>npm run dev</code></li>
<li>åœ¨æµ‹è¯•ç”¨ä¾‹ä¸­å¼•å…¥æ‰“åŒ…ç”Ÿæˆçš„æ–°çš„ vue.js</li>
</ul>
<blockquote>
<p>ç„¶åå°±å¯ä»¥æ„‰å¿«çš„æ‰“æ–­ç‚¹è°ƒè¯•äº†</p>
</blockquote>
<h2 id="å…¥å£æ–‡ä»¶åˆ†æ">å…¥å£æ–‡ä»¶åˆ†æ</h2>
<h3 id="ç›®å½•ç»“æ„">ç›®å½•ç»“æ„</h3>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1583685102033.png" alt="" loading="lazy"></figure>
<blockquote>
<p>Vue æºç ä½¿ç”¨ flow ç¼–å†™ï¼Œæ‰€ä»¥è¿˜è¦é¢å¤–ç»´æŠ¤ TypeScript ç±»å‹å®šä¹‰ï¼ŒåŠ ä¸Š flow ç›®å‰å·²åœæ­¢ç»´æŠ¤ï¼Œæ‰€ä»¥ vue 3 ä½¿ç”¨ TypeScript é‡å†™ã€‚</p>
</blockquote>
<h3 id="æ‰¾åˆ°å…¥å£">æ‰¾åˆ°å…¥å£</h3>
<p>package.json ä¸­ï¼Œmain æ˜¯ require çš„å…¥å£ï¼Œmodule æ˜¯ import çš„å…¥å£</p>
<pre><code>&quot;main&quot;: &quot;dist/vue.runtime.common.js&quot;,
&quot;module&quot;: &quot;dist/vue.runtime.esm.js&quot;,
</code></pre>
<p>dist æ˜¯æ‰§è¡Œæ„å»ºè„šæœ¬<code>&quot;build&quot;: &quot;node scripts/build.js&quot;</code>åˆ›å»ºçš„ï¼Œæ‰€ä»¥<code>npm run build</code>æ‰§è¡Œçš„æ˜¯ scripts/build.jsã€‚</p>
<pre><code class="language-js">// è·å–æ‰€æœ‰æ‰“åŒ…é…ç½®
let builds = require('./config').getAllBuilds()

// æ ¹æ®å‚æ•°è¿‡æ»¤æ‰ä¸éœ€è¦çš„
if (process.argv[2]) {
  const filters = process.argv[2].split(',')
  builds = builds.filter(b =&gt; {
    return filters.some(f =&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1)
  })
} else {
  // è¿‡æ»¤æ‰åŒ…å« weex çš„é…ç½®
  builds = builds.filter(b =&gt; {
    return b.output.file.indexOf('weex') === -1
  })
}

build(builds)
</code></pre>
<p>build.js ä¸­å¼•å…¥äº† script/config.jsï¼Œåœ¨é‡Œé¢å¯ä»¥æ‰¾åˆ°å„ä¸ªç‰ˆæœ¬çš„æ‰“åŒ…é…ç½®ã€‚</p>
<blockquote>
<h3 id="æœ¯è¯­è§£é‡Š">æœ¯è¯­è§£é‡Š</h3>
<p>runtimeï¼šä»…åŒ…å«è¿è¡Œæ—¶çš„ç‰ˆæœ¬ï¼ŒåŒ…å« vue è¿è¡Œçš„æ ¸å¿ƒä»£ç ï¼Œä½†æ²¡æœ‰æ¨¡æ¿ç¼–è¯‘å™¨ï¼Œå¦‚ vue.runtime.js</p>
<p>umdï¼šUniversal Module Definition è§„èŒƒï¼Œç”¨äºæµè§ˆå™¨çš„ script æ ‡ç­¾ï¼Œé»˜è®¤åŒ…å«è¿è¡Œæ—¶å’Œç¼–è¯‘å™¨ï¼Œå¦‚ vue.js</p>
<p>commonjsï¼šcjs è§„èŒƒï¼Œç”¨äºæ—§ç‰ˆæ‰“åŒ…å™¨ï¼Œå¦‚ browserifyã€webpack 1ï¼Œå¦‚ vue.runtime.common.js</p>
<p>esmï¼šES module è§„èŒƒï¼Œç”¨äºç°ä»£æ‰“åŒ…å™¨ï¼Œå¦‚ webpack 2 åŠä»¥ä¸Šç‰ˆæœ¬ï¼Œå¦‚ vue.runtime.esm.js</p>
<h3 id="compile-vs-runtime">Compile vs Runtime</h3>
<p>å¸¦ compiler ç‰ˆæœ¬æ”¯æŒ template é€‰é¡¹ï¼Œå¯ä»¥å®æ—¶ç¼–è¯‘æ¨¡æ¿</p>
<p>ä»… runtime ç‰ˆä¸æ”¯æŒ templateï¼Œä½“ç§¯å°ï¼Œéœ€è¦å€ŸåŠ© webpack æŠŠ template è§£ææˆ render å‡½æ•°</p>
</blockquote>
<p>å› ä¸ºæˆ‘ä»¬å¸Œæœ›åœ¨æµè§ˆå™¨ä¸­è°ƒè¯•ï¼Œæ‰€ä»¥æŸ¥çœ‹umdæ ¼å¼çš„ç‰ˆæœ¬ã€‚</p>
<pre><code class="language-js">  // Runtime+compiler development build (Browser)
  'web-full-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },
</code></pre>
<p>ç»“åˆscript/alias.jsä¸­çš„åˆ«åå¯ä»¥æ‰¾åˆ°å…¥å£æ–‡ä»¶ src/platforms/web/entry-runtime-with-compiler.js</p>
<pre><code class="language-js">// æ ¸å¿ƒä»£ç åœ¨è¿™é‡Œ
// æ‰©å±•é»˜è®¤çš„ $mount æ–¹æ³•ï¼Œèƒ½å¤Ÿç¼–è¯‘ template æˆ– el æŒ‡å®šçš„æ¨¡æ¿
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el &amp;&amp; query(el)

  // ä¸èƒ½æŒ‚è½½åˆ° body æˆ–è€… html ä¸Š
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`
    )
    return this
  }
  
  // è·å–é€‰é¡¹
  const options = this.$options
  // å¦‚æœ options ä¸Šä¸å­˜åœ¨ render é€‰é¡¹ï¼Œåˆ™å°† template/el è½¬åŒ–ä¸º render å‡½æ•°ï¼ŒæŒ‚è½½åˆ° options ä¸Š
  // å¦‚æœ options ä¸Šå­˜åœ¨ renderï¼Œç›´æ¥æ¸²æŸ“
  if (!options.render) {
    let template = options.template
    if (template) {
      // å¦‚æœæœ‰ templateï¼Œè§£æ template é€‰é¡¹
      if (typeof template === 'string') {
        // å¦‚æœæ˜¯å­—ç¬¦ä¸² / æ¨¡æ¿å­—ç¬¦ä¸²
        if (template.charAt(0) === '#') {
          // å¦‚æœæ˜¯ '#app' ç­‰ id é€‰æ‹©å™¨ï¼Œè½¬åŒ–ä¸ºæ¨¡æ¿å­—ç¬¦ä¸²
          template = idToTemplate(template)
        }
      } else if (template.nodeType) {
        // å¦‚æœæ˜¯ DOM å…ƒç´ 
        template = template.innerHTML
      }
    } else if (el) {
      //å¦åˆ™è§£æ el
      template = getOuterHTML(el)
    }
    if (template) {
      // å¦‚æœæœ‰æ¨¡æ¿å­—ç¬¦ä¸²ï¼Œéœ€è¦ç”¨ç¼–è¯‘å™¨ç¼–è¯‘ï¼Œå¾—åˆ° render å‡½æ•°
      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns
    }
  }
  // æ¸²æŸ“
  return mount.call(this, el, hydrating)
}
</code></pre>
]]></content>
    </entry>
</feed>