<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yuufen.com/blog</id>
    <title>YuuFen</title>
    <updated>2020-03-08T12:21:27.699Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yuufen.com/blog"/>
    <link rel="self" href="https://yuufen.com/blog/atom.xml"/>
    <subtitle>希望你可以记住我</subtitle>
    <logo>https://yuufen.com/blog/images/avatar.png</logo>
    <icon>https://yuufen.com/blog/favicon.ico</icon>
    <rights>All rights reserved 2020, YuuFen</rights>
    <entry>
        <title type="html"><![CDATA[你好呀，陌生人]]></title>
        <id>https://yuufen.com/blog/post/about/</id>
        <link href="https://yuufen.com/blog/post/about/">
        </link>
        <updated>2024-02-28T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>因为笔记太多太杂，决定定期写写博客整理整理笔记。</p>
<p><s>然后因为各种原因失去了动力</s></p>
<p><s>因此搞丢了好多笔记啊啊啊啊啊啊啊😭😭😭</s></p>
<p><s>看了看一年前的博文发现自己真的变化了蛮多的（加油💪）</s></p>
<p>总之现在又开始了</p>
<h2 id="关于我">🐟 关于我</h2>
<p>我目前大二在读，我的职业规划是前端工程师，我的专业是电子信息，所以我还了解一些嵌入式开发（当然只是一些些），对Python和TensorFlow也有一定的涉猎。我正在努力寻找暑期实习！</p>
<p>在以下位置找到有关我的更多信息：</p>
<p><a href="https://yuufen.com/" target="_blank" class="text-button">主页</a><a href="https://yuufen.com/blog" target="_blank" class="text-button">博客</a><a href="https://github.com/yuuFen" target="_blank" class="text-button">项目</a><a href="mailto:me@yuufen.com" class="text-button">给我发邮件</a></p>
<h2 id="兴趣爱好">🎨 兴趣爱好</h2>
<p><strong>摄影</strong>、羽毛球、轮滑，and playing!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端性能优化]]></title>
        <id>https://yuufen.com/blog/post/xYd9Z_Vfp/</id>
        <link href="https://yuufen.com/blog/post/xYd9Z_Vfp/">
        </link>
        <updated>2020-03-06T06:21:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="从输入-url-到显示页面发生了什么">从输入 url 到显示页面，发生了什么？</h2>
<p><strong>从输入 url 到显示页面，发生了什么？</strong></p>
<ol>
<li>用户输入 yuufen.com</li>
<li>浏览器通过 DNS，把 url 解析为 IP</li>
<li>和 IP 地址建立 TCP 连接，发送 HTTP 请求</li>
<li>服务器接收请求，查库，读文件等，拼接好返回的 HTTP 响应</li>
<li>浏览器收到首屏 html，开始渲染</li>
<li>解析 html 为 dom（同时加载额外的 css 和 js）</li>
<li>解析 css 为 css-tree</li>
<li>dom + css 生成 render-tree，绘图</li>
</ol>
<p>这是一个万能的面试题，这个题的答案包含着整个互联网运行的过程，我们性能优化的策略就是基于它的答案，针对每一步依次解析，让整体的时间变短。所以有两个大方向：</p>
<ol>
<li>少加载文件</li>
<li>少执行代码</li>
</ol>
<h2 id="雅虎军规">雅虎军规</h2>
<blockquote>
<p>虽然随着 Vue、React、Angular 这些框架的流行，雅虎军规当中一些优化的方法已不在适用，但是，更多的时候，我们是学习这些方法背后的思想，而不是去死记硬背某个方法，技术总是在更迭，只有握方法背后的思想，才能够立于不败之地。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1583615829278.jpg" alt="" loading="lazy"></figure>
<p>https://developer.yahoo.com/performance/rules.html</p>
<p>https://juejin.im/post/5b73ef38f265da281e048e51</p>
<h2 id="性能指标">性能指标</h2>
<blockquote>
<p>抛开场景谈性能优化，都是耍流氓</p>
</blockquote>
<h3 id="performance-api">Performance API</h3>
<h3 id="lighthouse">Lighthouse</h3>
<pre><code>lighthouse https://yuufen.com/
</code></pre>
<h2 id="dns">DNS</h2>
<p>prefetch</p>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1583617452917.png" alt="" loading="lazy"></figure>
<h2 id="tcp">TCP</h2>
<h3 id="ip-tcp-http-的关系">IP、TCP、HTTP 的关系</h3>
<ol>
<li>
<p>IP-门牌号，通过IP协议找到对应机器</p>
</li>
<li>
<p>TCP负责数据完整性和有序性，通过三次握手、粘包、滑动窗口等非常庞大的网络协议机制</p>
</li>
<li>
<p>HTTP负责应用层数据，文件编码、cookie、缓存、数据终止时机等</p>
</li>
</ol>
<h3 id="优化tcp策略">优化（TCP）策略</h3>
<ol>
<li>长连接</li>
<li>减少文件体积
<ol>
<li>js打包压缩</li>
<li>图片压缩</li>
<li>gzip</li>
</ol>
</li>
<li>减少文件请求次数
<ol>
<li>雪碧图</li>
<li>js、css打包</li>
<li>缓存控制</li>
<li>懒加载</li>
</ol>
</li>
<li>减少用户和服务器的举例
<ol>
<li>cdn</li>
</ol>
</li>
<li>本地储存</li>
</ol>
<h2 id="图片">图片</h2>
<h3 id="格式">格式</h3>
<ol>
<li>PNG</li>
</ol>
<p>png-8 png-24 png-32</p>
<p>logo，颜色简单但对图片质量要求高、精灵图</p>
<ol start="2">
<li>
<p>JPG/JPEG</p>
</li>
<li>
<p>GIF</p>
</li>
<li>
<p>SVG</p>
</li>
</ol>
<p>SVG图像中的文本时可选取可搜索的。</p>
<p>常用来绘制地图、股票k线图</p>
<p>会损耗性能</p>
<ol start="5">
<li>WebP</li>
</ol>
<p>全能的解决方案，但是兼容性不好，需要根据浏览器判断加载格式</p>
<ol start="6">
<li>Base64</li>
</ol>
<p>图片base64之后会变大，适合小的矢量图标</p>
<h3 id="其他">其他</h3>
<ol>
<li>图片渐进显示</li>
<li>懒加载</li>
<li>骨架图</li>
</ol>
<h2 id="缓存">缓存</h2>
<p>可以少加载文件</p>
<ol>
<li>cdn 缓存</li>
<li>本地缓存
<ol>
<li>localstorage</li>
<li>indexdb</li>
<li>cookie</li>
</ol>
</li>
<li>浏览器缓存</li>
</ol>
<h3 id="cdn">CDN</h3>
<p>缓存+回源</p>
<p>地理位置更近，新的域名规避cookie</p>
<h3 id="浏览器缓存">浏览器缓存</h3>
<ol>
<li>获取文件</li>
<li>文件返回express或者cache-control设置过期时间，并且带上etag或者lastModfied字段</li>
<li>再次请求，浏览器先查询expres或者cache-control是否过期，若没过期，强缓存生效，不发出网络请求，直接使用缓存</li>
<li>若强缓存失效，浏览器会带上etag或者lastModfied数据，使用if-none-match或者if-Modified-Since字段，咨询后端是否过期</li>
<li>若没过期，返回304状态码，直接用缓存</li>
<li>若过期，状态码200，返回新资源</li>
</ol>
<h4 id="强缓存">强缓存</h4>
<h4 id="协商缓存">协商缓存</h4>
<h3 id="webpack打包和缓存的关系">webpack打包和缓存的关系</h3>
<ol>
<li>hash：整个项目相关的hash</li>
<li>chunkhash：入口文件依赖的chunkhash</li>
<li>contenthash：文件内容的hash</li>
</ol>
<h3 id="其他-2">其他</h3>
<ol>
<li>
<p>memory cache 内存缓存，比如储存在变量里，关闭tab就没了</p>
</li>
<li>
<p>Disk cache 硬盘上的缓存</p>
</li>
<li>
<p>Push cache推送缓存 http2</p>
</li>
<li>
<p>service worker 浏览器背后的独立进程</p>
</li>
</ol>
<h2 id="渲染">渲染</h2>
<h3 id="浏览器渲染原理">浏览器渲染原理</h3>
<p>经典文章 how browser works</p>
<p>https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[虚拟 DOM 深入与简单实现]]></title>
        <id>https://yuufen.com/blog/post/M0Xa7RsWm/</id>
        <link href="https://yuufen.com/blog/post/M0Xa7RsWm/">
        </link>
        <updated>2020-03-04T20:24:31.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简单实现 Vue（MVVM模式）]]></title>
        <id>https://yuufen.com/blog/post/_IR3q9jGE/</id>
        <link href="https://yuufen.com/blog/post/_IR3q9jGE/">
        </link>
        <updated>2020-02-29T17:13:55.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/yuuFen/vue-reimplement">https://github.com/yuuFen/vue-reimplement</a></p>
<h2 id="vue-工作机制">Vue 工作机制</h2>
<p>在 <code>new Vue()</code> 时会调用 _init() 进行初始化，会初始化生命周期、事件、props、methods、data、computed 和 watch 等。其中最重要的是 <code>Object.defineProperty</code> 设置 <code>setter</code> 与 <code>getter</code> ，用来实现<strong>响应式</strong>以及<strong>依赖收集</strong>。</p>
<p>初始化后调用 <code>$mount</code> 挂载组件：</p>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1583512098725.png" alt="" loading="lazy"></figure>
<p>化简版：</p>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1583502362745.png" alt="" loading="lazy"></figure>
<h2 id="响应式">响应式</h2>
<h3 id="实现">实现</h3>
<pre><code class="language-js">class Vue {
  constructor(options) {
    this.$options = options

    this.$data = options.data

    // 响应化处理
    this.observe(this.$data)

    Object.keys(this.$data).forEach((key) =&gt; {
      // 只需要给 data 的第一层设置代理
      // 不然 set 多余的键时会给 data 添加属性
      this.proxyData(key)
    })
  }

  observe(value) {
    if (!value || typeof value !== 'object') {
      return
    }

    Object.keys(value).forEach((key) =&gt; {
      // setter 和 getter 使用中介 val，防止无限循环
      // 需要新建一个作用域（闭包）来保存 val,
      // Object.defineProperty(obj, key, { // val })
      this.defineReactive(value, key, value[key])
    })
  }

  defineReactive(obj, key, val) {
    // 递归，处理对象
    this.observe(val)

    // 会在 obj 上添加新属性，或者修改现有属性
    // 所以是个引用变量
    Object.defineProperty(obj, key, {
      get() {
        return val
      },
      set(newVal) {
        if (newVal !== val) {
          val = newVal
        }
      },
    })
  }

  // 在 Vue 实例根上定义属性转发至 data 中的数据
  proxyData(key) {
    // this 指 Vue 实例
    Object.defineProperty(this, key, {
      get() {
        return this.$data[key]
      },
      set(newVal) {
        this.$data[key] = newVal
      },
    })
  }
}
</code></pre>
<h3 id="测试">测试</h3>
<pre><code class="language-html">&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  const app = new Vue({
    data: {
      foo: 'foooooo',
      bar: {
        doo: 'dooooooo',
      },
    },
  })

  console.log(app.bar)
  app.bar = 'baaaar'
  console.log(app.bar)
&lt;/script&gt;
</code></pre>
<h2 id="依赖收集与追踪">依赖收集与追踪</h2>
<p>流程：</p>
<figure data-type="image" tabindex="3"><img src="https://yuufen.com/blog/post-images/1583577271564.png" alt="" loading="lazy"></figure>
<p>关系：</p>
<figure data-type="image" tabindex="4"><img src="https://yuufen.com/blog/post-images/1583579033936.png" alt="" loading="lazy"></figure>
<h3 id="案例">案例</h3>
<pre><code class="language-js">new Vue({
  template: `
    &lt;div&gt;
      &lt;span&gt;{{name1}}&lt;/span&gt;  
      &lt;span&gt;{{name2}}&lt;/span&gt;  
      &lt;span&gt;{{name1}}&lt;/span&gt;  
    &lt;/div&gt;
  `,
  data: {
    name1: 'name1',
    name2: 'name2',
    name3: 'name3',
  },
})
</code></pre>
<blockquote>
<p>修改 name1，视图更新，且要更新两处；</p>
<p>修改 name2，视图更新；</p>
<p>修改 name3，没有使用，视图不更新。</p>
<p>需要扫描视图收集依赖，知道视图中到底那些地方对数据有依赖。</p>
</blockquote>
<h3 id="实现-2">实现</h3>
<pre><code class="language-js">class Vue {
  constructor(options) {
    this.$options = options

    this.$data = options.data

    // 响应化处理
    this.observe(this.$data)

    Object.keys(this.$data).forEach((key) =&gt; {
      // 只需要给 data 的第一层设置代理
      // 不然 set 多余的键时会给 data 添加属性
      this.proxyData(key)
    })

    // 测试
    new Watcher(this, 'foo')
    new Watcher(this, 'bar.doo')
  }

  observe(value) {
    if (!value || typeof value !== 'object') {
      return
    }

    Object.keys(value).forEach((key) =&gt; {
      // setter 和 getter 使用中介 val，防止无限循环
      // 需要新建一个作用域（闭包）来保存 val,
      // Object.defineProperty(obj, key, { // val })
      this.defineReactive(value, key, value[key])
    })
  }

  defineReactive(obj, key, val) {
    // 递归，处理对象
    this.observe(val)

    const dep = new Dep()

    // 会在 obj 上添加新属性，或者修改现有属性，是个引用变量
    // 这里导致形成闭包
    Object.defineProperty(obj, key, {
      get() {
        // 若存在 targetWatcher（watcher的构造阶段），则添加
        Dep.targetWatcher &amp;&amp; dep.addWatcher(Dep.targetWatcher)
        return val
      },
      set(newVal) {
        if (newVal !== val) {
          val = newVal
          // 通知更新
          dep.notify()
        }
      },
    })
  }

  // 在 Vue 实例根上定义属性转发至 data 中的数据
  proxyData(key) {
    // this 指 Vue 实例
    Object.defineProperty(this, key, {
      get() {
        return this.$data[key]
      },
      set(newVal) {
        this.$data[key] = newVal
      },
    })
  }
}

// 创建 Dep: 管理所有的 Watcher
class Dep {
  constructor() {
    this.watchers = []
  }
  addWatcher(watcher) {
    this.watchers.push(watcher)
  }
  notify() {
    this.watchers.forEach((watcher) =&gt; {
      watcher.update()
    })
  }
}

// 创建 Watcher：与视图中的变量对应(出现一次就创建一个 Watcher 实例)
class Watcher {
  constructor(vm, key) {
    this.vm = vm
    this.key = key

    Dep.targetWatcher = this
    this.vm[this.key] // key解析出来之后为字符串， 但是若如 'bar.doo'，需要额外操作
    Dep.targetWatcher = null
  }
  update() {
    console.log(this.key, '更新——来自 watcher')
    // do something
  }
}
</code></pre>
<h2 id="编译-compile">编译 compile</h2>
<figure data-type="image" tabindex="5"><img src="https://yuufen.com/blog/post-images/1583580639945.png" alt="" loading="lazy"></figure>
<ol>
<li>获取并遍历 DOM 树</li>
<li>文本节点：获取 <code>{{}}</code> 格式的内容并解析</li>
<li>元素节点：访问节点特性，截获 <code>v-</code> 开头和 <code>@</code> 开头内容并解析</li>
</ol>
<h3 id="使用场景">使用场景</h3>
<pre><code>new Vue {
  el: '#app',
}
</code></pre>
<pre><code class="language-js">class Vue {
  constructor(options) {
    // ...
    new Compile(this, options.el)
  }
  // ...
}
</code></pre>
<h3 id="遍历节点">遍历节点</h3>
<pre><code class="language-js">class Compile {
  constructor(vm, el) {
    // new Watcher 需要 vm
    this.$vm = vm
    this.$el = document.querySelector(el)

    if (this.$el) {
      // 提取宿主中模板内容到 fragment 标签（结束后 $el 中没有子元素）
      // 不会引起页面回流（对元素位置和几何上的计算），性能更好
      this.$fragment = this.node2Fragment(this.$el)
      // 编译，并进行依赖收集
      this.compile(this.$fragment)
      // 编译结束后把 fragment 再添加到 el 中
      this.$el.appendChild(this.$fragment)
    }
  }

  node2Fragment(el) {
    const fragment = document.createDocumentFragment()
    let child
    while ((child = el.firstChild)) {
      fragment.appendChild(child)
    }
    return fragment
  }

  compile(el) {
    const childNodes = el.childNodes

    Array.from(childNodes).forEach((node) =&gt; {
      // 判断节点类型
      if (node.nodeType === 1) {
        // Element 节点
        console.log('遍历到节点', node.nodeName)
      } else if (this.isInterpolation(node)) {
        // 插值表达式
        console.log('遍历到插值表达式', node.textContent)
      }
      // 如果有子节点
      if (node.children &amp;&amp; node.childNodes.length &gt; 0) {
        this.compile(node)
      }
    })
  }

  isInterpolation(node) {
    // 是文本且符合{{...}}
    return node.nodeType === 3 &amp;&amp; /\{\{(.*)\}\}/.test(node.textContent)
  }
}
</code></pre>
<h3 id="插值表达式的响应式更新">插值表达式的响应式更新</h3>
<p>Compile：</p>
<pre><code class="language-js">  // ...
  // 遍历到插值表达式时
  compileText(node) {
    // console.log(RegExp.$1)
    const exp = RegExp.$1
    this.update(node, exp, 'text')
  }

  update(node, exp, dir) {
    const updater = this[dir + 'Updater']
    updater &amp;&amp; updater(node, exp)
    // 注意 this
    const get = this.getContent
    // 形成闭包，和一个 Watcher 实例对应
    new Watcher(
      this.$vm,
      // exp, // 在闭包中处理
      function() {
        get(exp)
      },
      function() {
        updater &amp;&amp; updater(node, exp)
      },
    )
  }

  // 注意 this
  textUpdater = (node, exp) =&gt; {
    node.textContent = this.getContent(exp)
  }

  // 注意 this
  getContent = (exp) =&gt; {
    // 解决嵌套，get 嵌套属性的值
    const p = exp.split('.')
    let content = this.$vm[p[0]]
    for (let i = 1; i &lt; p.length; i++) {
      content = content[p[i]]
    }
    return content
  }
}
</code></pre>
<p>Watcher：</p>
<pre><code class="language-js">// 初始化时再接受 get 和 updater，不再需要 key 和 vm
// 对应的 update(node, keys, dir) {...} 形成闭包

class Watcher {
  constructor(get, cb) {
    // this.vm = vm
    // this.key = key
    this.cb = cb

    this.get = get // 获取嵌套属性的方法

    Dep.targetWatcher = this
    // key解析出来之后为字符串， 但是若如 'bar.doo'，需要额外操作
    // 访问 bar.doo，会将它同时挂载到 bar 和 doo 的 Dep 实例（也是有必要的）
    // 这里直接在闭包中处理
    this.get()
    Dep.targetWatcher = null
  }
  update() {
    // 更新视图
    this.cb()
  }
}
</code></pre>
<blockquote>
<p>Watcher 实例对应的 update 形成闭包，存有 get、updater、node、exp。</p>
<p>也可以把 update 的相关内容直接放在 watcher 里面，更直观一点，但是 Watcher 太臃肿。</p>
</blockquote>
<pre><code class="language-js">class Watcher {
  constructor(vm, node, exp, dir) {
    this.vm = vm
    this.node = node
    this.exp = exp
    this.dir = dir

    this.updater = this[dir + 'Updater']

    Dep.targetWatcher = this
    this.getContent()
    Dep.targetWatcher = null

    this.updater()
  }
  update() {
    this.updater()
  }

  textUpdater() {
    this.node.textContent = this.getContent(this.exp)
  }

  // ...

  getContent() {
    // 解决嵌套，get 嵌套属性的值
    const p = this.exp.split('.')
    let content = this.vm[p[0]]
    for (let i = 1; i &lt; p.length; i++) {
      content = content[p[i]]
    }
    return content
  }
}
</code></pre>
<h3 id="元素属性的响应式">元素属性的响应式</h3>
<h4 id="v-text">v-text</h4>
<pre><code class="language-js">  compileElement(node) {
    const nodeAttrs = node.attributes
    Array.from(nodeAttrs).forEach((attr) =&gt; {
      const attrName = attr.name
      const exp = attr.value
      if (attrName.indexOf('v-') === 0) {
        const dir = attrName.substring(2)
        this[dir] &amp;&amp; this[dir](node, exp)
      }
    })
  }

  text(node, exp) {
    this.update(node, exp, 'text')
  }
</code></pre>
<h4 id="v-html">v-html</h4>
<p>和 text 一样，把 node.textContent 改为 node.innerHTML</p>
<h4 id="v-model">v-model</h4>
<p>修改 node.value，监听 node 的 input 事件</p>
<p>新建 set 方法，解决嵌套属性的 set 问题</p>
<pre><code class="language-js">setContent = (exp, value) =&gt; {
  const p = exp.split('.')
  if (p.length === 1) {
    this.$vm[p] = value
  } else if (p.length &gt; 1) {
    let content = this.$vm[p[0]]
    for (let i = 1; i &lt; p.length - 1; i++) {
      content = content[p[i]]
    }
    content[p[p.length - 1]] = value
  }
}
</code></pre>
<h4 id="事件绑定">@ 事件绑定</h4>
<pre><code>@click=&quot;handleClick&quot;
</code></pre>
<p>获取到 click、handleClick，绑定到 node 上，注意 this。</p>
<h2 id="汇总">汇总</h2>
<h3 id="compilejs">compile.js</h3>
<pre><code class="language-js">class Compile {
  constructor(vm) {
    // new Watcher 需要 vm
    this.$vm = vm
    this.$el = document.querySelector(this.$vm.$options.el)

    if (this.$el) {
      // 提取宿主中模板内容到 fragment 标签（结束后 $el 中没有子元素）
      // 不会引起页面回流（对元素位置和几何上的计算），性能更好
      this.$fragment = this.node2Fragment(this.$el)
      // 编译，并进行依赖收集
      this.compile(this.$fragment)
      // 编译结束后把 fragment 再添加到 el 中
      this.$el.appendChild(this.$fragment)
    }
  }

  node2Fragment(el) {
    const fragment = document.createDocumentFragment()
    let child
    while ((child = el.firstChild)) {
      fragment.appendChild(child)
    }
    return fragment
  }

  compile(el) {
    const childNodes = el.childNodes

    Array.from(childNodes).forEach((node) =&gt; {
      // 判断节点类型
      if (node.nodeType === 1) {
        // Element 节点
        console.log('遍历到节点', node.nodeName)
        this.compileElement(node)
      } else if (this.isInterpolation(node)) {
        // 插值表达式
        console.log('遍历到插值表达式', node.textContent)
        this.compileText(node)
      }
      // 如果有子节点
      if (node.children &amp;&amp; node.childNodes.length &gt; 0) {
        this.compile(node)
      }
    })
  }

  isInterpolation(node) {
    // 是文本且符合{{...}}
    return node.nodeType === 3 &amp;&amp; /\{\{(.*)\}\}/.test(node.textContent)
  }

  compileText(node) {
    // console.log(RegExp.$1)
    const exp = RegExp.$1
    this.update(this.$vm, node, exp, 'text')
  }

  update(vm, node, exp, dir) {
    const updater = this[dir + 'Updater']
    // 也可以把 updater 的实现直接放在 watcher 里面
    // 就不用形成闭包，但是这样 watcher 就太臃肿了。
    updater &amp;&amp; updater(node, exp)
    // 注意 this
    const get = this.getContent
    // 形成闭包，和一个 Watcher 实例对应
    new Watcher(
      // vm, // 在这里处理
      // exp, // 在这里处理
      function() {
        get(exp)
      },
      function() {
        updater &amp;&amp; updater(node, exp)
      },
    )
  }

  // 注意 this
  textUpdater = (node, exp) =&gt; {
    node.textContent = this.getContent(exp)
  }
  htmlUpdater = (node, exp) =&gt; {
    node.innerHTML = this.getContent(exp)
  }
  modelUpdater = (node, exp) =&gt; {
    node.value = this.getContent(exp)
  }

  // 注意 this
  getContent = (exp) =&gt; {
    // 解决嵌套，get 嵌套属性的值
    const p = exp.split('.')
    let content = this.$vm[p[0]]
    for (let i = 1; i &lt; p.length; i++) {
      content = content[p[i]]
    }
    return content
  }
  setContent = (exp, value) =&gt; {
    const p = exp.split('.')
    if (p.length === 1) {
      this.$vm[p] = value
    } else if (p.length &gt; 1) {
      let content = this.$vm[p[0]]
      for (let i = 1; i &lt; p.length - 1; i++) {
        content = content[p[i]]
      }
      content[p[p.length - 1]] = value
    }
  }

  compileElement(node) {
    const nodeAttrs = node.attributes
    Array.from(nodeAttrs).forEach((attr) =&gt; {
      const attrName = attr.name
      const exp = attr.value
      if (attrName.indexOf('v-') === 0) {
        const dir = attrName.substring(2)
        this[dir] &amp;&amp; this[dir](this.$vm, node, exp)
      } else if (attrName.indexOf('@') === 0) {
        // @click=&quot;handleClick&quot;
        const dir = attrName.substring(1)
        this.eventHandler(this.$vm, node, exp, dir)
      }
    })
  }

  text(vm, node, exp) {
    this.update(vm, node, exp, 'text')
  }

  html(vm, node, exp) {
    this.update(vm, node, exp, 'html')
  }

  model(vm, node, exp) {
    this.update(vm, node, exp, 'model')
    node.addEventListener('input', (e) =&gt; {
      this.setContent(exp, e.target.value)
    })
  }

  eventHandler(vm, node, exp, dir) {
    const fn = vm.$options.methods &amp;&amp; vm.$options.methods[exp]
    // console.log(node, exp, dir, fn)
    if (dir &amp;&amp; fn) {
      // 注意 this
      node.addEventListener(dir, fn.bind(vm))
    }
  }
}
</code></pre>
<h3 id="vuejs">vue.js</h3>
<pre><code class="language-js">class Vue {
  constructor(options) {
    this.$options = options

    this.$data = options.data

    // 响应化处理
    this.observe(this.$data)

    Object.keys(this.$data).forEach((key) =&gt; {
      // 只需要给 data 的第一层设置代理
      // 不然 set 多余的键时会给 data 添加属性
      this.proxyData(key)
    })

    // new Watcher(this, 'foo')
    // new Watcher(this, 'bar.doo')

    new Compile(this)
  }

  observe(value) {
    if (!value || typeof value !== 'object') {
      return
    }

    Object.keys(value).forEach((key) =&gt; {
      // setter 和 getter 使用中介 val，防止无限循环
      // 需要新建一个作用域（闭包）来保存 val,
      // Object.defineProperty(obj, key, { // val })
      this.defineReactive(value, key, value[key])
    })
  }

  defineReactive(obj, key, val) {
    // 递归，处理对象
    this.observe(val)

    const dep = new Dep()

    // 会在 obj 上添加新属性，或者修改现有属性，是个引用变量
    // 这里导致形成闭包
    Object.defineProperty(obj, key, {
      get() {
        // 若存在 targetWatcher（watcher的构造阶段），则添加
        Dep.targetWatcher &amp;&amp; dep.addWatcher(Dep.targetWatcher)
        // console.log('get');
        return val
      },
      set(newVal) {
        if (newVal !== val) {
          // console.log('set');
          val = newVal
          // 通知更新
          dep.notify()
        }
      },
    })
  }

  // 在 Vue 实例根上定义属性转发至 data 中的数据
  proxyData(key) {
    // this 指 Vue 实例
    Object.defineProperty(this, key, {
      get() {
        return this.$data[key]
      },
      set(newVal) {
        this.$data[key] = newVal
      },
    })
  }
}

// 创建 Dep: 管理所有的 Watcher
class Dep {
  constructor() {
    this.watchers = []
  }
  addWatcher(watcher) {
    this.watchers.push(watcher)
  }
  notify() {
    this.watchers.forEach((watcher) =&gt; {
      watcher.update()
    })
  }
}

// 创建 Watcher：与视图中的变量对应(出现一次就创建一个 Watcher 实例)
class Watcher {
  constructor(get, cb) {
    // this.vm = vm
    // this.key = key
    this.cb = cb

    this.get = get // 获取嵌套属性的方法

    Dep.targetWatcher = this
    // key解析出来之后为字符串， 但是若如 'bar.doo'，需要额外操作
    // 访问 bar.doo，会将它同时挂载到 bar 和 doo 的 Dep 实例（也是有必要的）
    // 这里直接在闭包中处理
    this.get()
    Dep.targetWatcher = null
  }
  update() {
    // 更新视图
    this.cb()
  }
}
</code></pre>
<h3 id="indexhtml">index.html</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
      &lt;p&gt;{{name}}&lt;/p&gt;
      &lt;p v-text=&quot;name&quot;&gt;&lt;/p&gt;
      &lt;p&gt;{{age}}&lt;/p&gt;
      &lt;p&gt;{{doubleAge}}&lt;/p&gt;
      &lt;p&gt;{{bar}}&lt;/p&gt;
      &lt;p&gt;{{bar.doo}}&lt;/p&gt;
      &lt;div&gt;{{}}&lt;/div&gt;
      &lt;input type=&quot;text&quot; v-model=&quot;name&quot; /&gt; &lt;button @click=&quot;changeName&quot;&gt;修改name&lt;/button&gt;
      &lt;input type=&quot;text&quot; v-model=&quot;bar.doo&quot; /&gt; &lt;button @click=&quot;changeDoo&quot;&gt;修改doo&lt;/button&gt;
      &lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;

    &lt;script src=&quot;compile.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      const app = new Vue({
        el: '#app',
        data: {
          name: 'I am test.',
          age: 12,
          html: '&lt;button&gt;html测试&lt;/button&gt;',
          foo: 'foooooo',
          bar: {
            doo: '嵌套属性',
          },
        },
        methods: {
          changeName() {
            // console.log('执行了吗')
            // 注意 this
            this.name = '调用了methods'
          },
          changeDoo() {
            this.bar.doo = '调用了methods'
          },
        },
      })

      setTimeout(() =&gt; {
        app.name = '666666666666'
        app.bar.doo = 'oooo'
        // console.log(app.bar.doo)
        // app.bar = 'oooo'
      }, 1000)

      // console.log(app['bar.doo'])
      // app.foo = 'ffff'
      // console.log(app.bar)
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见设计模式总结]]></title>
        <id>https://yuufen.com/blog/post/_lKjmwEdd/</id>
        <link href="https://yuufen.com/blog/post/_lKjmwEdd/">
        </link>
        <updated>2020-02-28T06:51:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="总结">总结</h2>
<p>创建设计模式：单例、工厂、建造者</p>
<p>结构化设计模式：代理、装饰器、外观、享元、适配器、</p>
<p>行为型：观察者、策略、中介者、迭代器、责任链、模板方法、备忘录</p>
<p>vue &amp; element / react &amp; redux 的源码值得学习</p>
<h2 id="pub-sub订阅-发布模式观察者模式">pub / sub（订阅 / 发布模式，观察者模式）</h2>
<h3 id="优点">优点</h3>
<p>解耦，降低代码入侵性</p>
<pre><code class="language-js">原始：
ModuleA
  import B
  B.action()
ModuleB
  action() {
    import C
    C.action()
  }
ModuleC
  action() {
    doSomething()
  }

观察者：
Event
ModuleA
  event.$emit()
ModuleB
  event.$on()
  event.$emit()
ModuleC
  event.$on()
</code></pre>
<h3 id="目标-实现">目标 &amp; 实现</h3>
<p>参考 vue</p>
<pre><code class="language-js">// 实现：
class Event {
  constructor() {
    this.callback = {}
  }

  $on(name, fn) {
    ;(this.callback[name] || (this.callback[name] = [])).push(fn)
  }

  $emit(name, ...args) {
    const cbs = this.callback[name]
    if (cbs) {
      cbs.forEach((cb) =&gt; {
        cb.call(this, ...args)
      })
    }
  }

  $off(name) {
    this.callback[name] = null
  }
}

// 目标：
let event = new Event()
// 监听
event.$on('event1', (...args) =&gt; {
  console.log('event1', ...args)
})
event.$on('event1', (...args) =&gt; {
  console.log('event1 again', ...args)
})
// 触发
event.$emit('event1', 1, 2, 3)
// 解绑
console.log('-'.repeat(20))
event.$off('event1')
event.$emit('event1', 1, 2, 3) // 测试
</code></pre>
<h2 id="单例模式">单例模式</h2>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h3 id="适用场景">适用场景</h3>
<p>如：</p>
<ol>
<li>弹窗，无论点击多少次都只被创建一次。</li>
<li>redux 的 store，全局唯一</li>
</ol>
<h3 id="简单举例">简单举例</h3>
<pre><code class="language-js">// 新建弹窗，期望弹窗全局唯一
// 伪代码:
// function createModalLayer() {
//   // 闭包储存单例实例
//   let result
//   return function() {
//     return result || (result = 新建弹窗)
//   }
// }
// 提取：
// 高阶函数：
function getSingle(fn) {
  let result
  return function() {
    return result || (result = fn.apply(this, arguments))
  }
}
function createModalLayer() {
  console.log('新建弹窗')
  const div = document.createElement('div')
  div.innerHTML = new Date()
  div.className = 'modal'
  div.style.display = 'none'
  document.body.appendChild(div)
  div.addEventListener(
    'click',
    function() {
      div.style.display = 'none'
    },
    false,
  )
  return div
}

createModalLayer = getSingle(createModalLayer)

document.getElementById('modal-btn').addEventListener('click', function() {
  // 新建弹窗
  const modalLayer = createModalLayer()
  modalLayer.style.display = 'block'
})
</code></pre>
<h2 id="策略模式">策略模式</h2>
<h3 id="分析">分析</h3>
<p>KISS 原则 keep it simple and stupid</p>
<p>策略模式指定义一系列算法，把他们一个个封装起来，并使他们可以相互替换。</p>
<p>目的是将算法的使用和实现分离。</p>
<p>一个基于策略模式的程序至少由两部分组成。第一部分是一组策略类（可变），封装了具体的算法，负责具体的计算过程；第二部分是环境类 Context（不变），Context 接收客户的请求，随后将请求委托给某一个策略类。要做到这一点，说明 Context 中要维持对某个策略对象的引用。</p>
<h3 id="举例">举例</h3>
<p>原始（面条式代码）：</p>
<pre><code class="language-js">let form = 获取表单
form.onSubmit = function() {
  if (form.name.value === '') {
    弹出错误消息
  }
  if (form.password.value === '') {
    弹出错误消息
  }
  if (form.password.value.length &lt; 5) {
    弹出错误消息
  }
  正则等等
}
</code></pre>
<p>策略模式（具体看 element 的表单验证 https://github.com/ElemeFE/element/blob/dev/packages/form/src/form.vue ），其他例子：</p>
<pre><code class="language-js">// 1. 策略
// 可以使用配置
const policy = {
  S: function(salary) {
    return salary * 4
  },
  A: function(salary) {
    return salary * 3
  },
  B: function(salary) {
    return salary * 2
  },
  C: function(salary) {
    return salary
  },
}
// 2. 使用
function calculate(level, salary) {
  return policy[level] ? policy[level](salary) : 0
}
</code></pre>
<h2 id="代理模式">代理模式</h2>
<p>定义：为一个对象提供一个占用品或占位符，以便控制对它的访问。</p>
<p>常用的虚拟代理形式：某花销很大的操作，可通过虚拟代理的方式延迟到需要它的时候再创建（如使用虚拟代理实现图片懒加载）。</p>
<h3 id="适用场景-2">适用场景</h3>
<ol>
<li>图片懒加载的方式：先通过一张 loading 图占位，然后同通过异步的方式加载图片，等图片加载好了再把完成的图片加载到 img 标签里面。</li>
</ol>
<pre><code class="language-js">// 给图片实例一个setSrc方法，先设置loading，再显示图片
const imgFunc = (function() {
  let imgNode = document.createElement('img')
  document.body.appendChild(imgNode)
  return {
    setSrc: function(src) {
      // 耗时
      imgNode.src = src
    },
  }
})()
// 使用代理模式，增加 loading
const proxyImage = (function() {
  let img = new Image()
  // 加载完毕，再设置
  img.onload = function() {
    setTimeout(() =&gt; {
      imgFunc.setSrc(this.src)
    }, 500)
  }
  return {
    setSrc(src) {
      // 先设置 loading
      imgFunc.setSrc('loading.gif')
      img.src = src
    },
  }
})()
proxyImage.setSrc('https://yuufen.com/album/photography/2.jpg')
</code></pre>
<ol start="2">
<li>通过一个代理函数收集一段时间之内的请求，最后一次性发送给服务器。</li>
</ol>
<pre><code class="language-js">var synchronousFile = function(id) {
  console.log('开始同步⽂文件，id 为: ' + id)
}
var proxySynchronousFile = (function() {
  var cache = [], // 保存⼀一段时间内需要同步的 ID
    timer // 定时器
  return function(id) {
    cache.push(id)
    if (timer) {
      // 保证不不会覆盖已经启动的定时器器
      return
    }
    timer = setTimeout(function() {
      synchronousFile(cache.join(','))
      clearTimeout(timer) // 清空定时器器
      timer = null
      cache.length = 0 // 清空 ID 集合
    }, 2000)
  } // 2 秒后向本体发送需要同步的 ID 集合
})()
var checkbox = document.getElementsByTagName('input')
for (var i = 0, c; (c = checkbox[i++]); ) {
  c.onclick = function() {
    if (this.checked === true) {
      proxySynchronousFile(this.id)
    }
  }
}
</code></pre>
<ol start="3">
<li>
<p>函数的防抖节流。</p>
</li>
<li>
<p>React 的 CSS 代理。</p>
</li>
</ol>
<h2 id="中介者模式">中介者模式</h2>
<p>如 redux / vuex，把共享的数据抽离成一个单独的 store，每个都通过 store 这个中介来操作对象。</p>
<p>适用场景：如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等，都会触发 change 事件。</p>
<p>通过中介者来转发处理这些事件，实现各个事件之间的解耦，仅仅维护中介者对象即可。</p>
<h2 id="装饰器模式">装饰器模式</h2>
<h3 id="和代理模式的异同">和代理模式的异同</h3>
<p>两种模式都描述了怎样为对象提供一定程度上的间接引用，他们的实现部分都保留了对另外一个对象的引用，并且向那个对象发送请求。</p>
<p>代理模式和装饰器模式最重要的区别在于它们的意图和设计目的。</p>
<p>代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。</p>
<p>装饰器模式的作用则是为对象动态的加入行为。</p>
<h3 id="举例-2">举例</h3>
<p>如 React 的高阶组件</p>
<pre><code class="language-js">import React from 'react'

// 统计渲染日志
const withLog = (Component) =&gt; {
  class NewComponent extends React.Component {
    componentWillMount() {
      console.time('componentRender')
    }
	  render() {
      return &lt;Component {...this.props}&gt;&lt;/Component&gt;
    }
    componentDidMount() {
      console.timeEnd('componentRender')
    }
  }
  return NewComponent
}
export {withLog}

// 装饰
@withLog
class XXX

// 或者
// class XXX
// XXX = withLog(XXX)
</code></pre>
<pre><code class="language-js">// 依此可以在配置文件中实现统一配置
Function.prototype.before = function(beforefn) {
  var __self = this // 保存对原函数的引用
  return function() {
    //返回包含原函数和新函数的“代理”函数
    beforefn.apply(this, arguments) // 新函数在原函数之前执行，并保证 this 不被劫持
    return __self.apply(this, arguments) // 返回原函数的执行结构，并保证 this 不被劫持
  }
}
Function.prototype.after = function(afterfn) {
  var __self = this
  return function() {
    var ret = __self.apply(this, arguments)
    afterfn.apply(this, arguments)
    return ret
  }
}
</code></pre>
<h2 id="外观模式">外观模式</h2>
<p>涉及到兼容性、参数支持多格式等，对外暴露统一的 API，内部判断实现。让 API 更精简。</p>
<h2 id="工厂模式">工厂模式</h2>
<p>提供创建对象的接口，把成员对象的创建工作转交给一个外部对象。好处在于消除对象之间的耦合（也就是相互影响）。常见的例子：弹窗、Message，对外提供 api，调用 api 新建一个弹窗或者 Message 的实例。</p>
<h3 id="举例-3">举例</h3>
<p>https://github.com/ElemeFE/element/blob/dev/packages/notification/src/main.js</p>
<h2 id="建造者模式-builder">建造者模式 builder</h2>
<p>和工厂模式相比，参与了更多或更复杂的创建的过程。</p>
<pre><code class="language-js">var Person = function(name, work) {
  var _person = new Human()
  _person.name = new Named(name)
  _person.work = new Work(work)
  return _person
}
var person = new Person('Ming', 'code')
console.log(person)
</code></pre>
<h2 id="迭代器模式">迭代器模式</h2>
<blockquote>
<p>迭代器器模式是指提供⼀种⽅法顺序访问⼀个聚合对象中的各个元素，⽽又不要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来,在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素</p>
</blockquote>
<p>each、map 等等等等太多了</p>
<pre><code class="language-js">var each = function(ary, callback) {
  for (var i = 0, l = ary.length; i &lt; l; i++) {
    callback.call(ary[i], i, ary[i])
  }
}

each([1, 2, 3], function(i, n) {
  alert([i, n])
})
</code></pre>
<h2 id="享元模式">享元模式</h2>
<blockquote>
<p>享元(ﬂyweight)模式是⼀种用于性能优化的模式，“ﬂy”在这⾥是苍蝇的意思，意为蝇量级。享元模式的核⼼是运⽤共享技术来有效⽀持⼤量细粒度的对象。 如果系统中因为创建了⼤量类似的对象而导致内存占用过高，享元模式就非常有⽤了。在 JavaScript 中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件⾮常有意义的事情。</p>
</blockquote>
<p>比如只创建少数弹窗对象，动态修改弹窗内容。</p>
<ul>
<li>内部状态储存于对象内部 （如弹窗的位置、border 等）</li>
<li>内部状态可以被一些对象共享</li>
<li>内部状态独立于具体的场景，通常不会改变</li>
<li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享 （如弹窗文案）</li>
</ul>
<h2 id="责任链模式">责任链模式</h2>
<ul>
<li>中间件机制</li>
</ul>
<blockquote>
<p>使多个对象都有机会处理请求，从⽽避免请求的发送者和接收者之间的耦合关系， 将这些对象连成一条链，并沿着这条链传递该请求，直到有⼀个对象处理它为止。 职责链模式的名字⾮常形象，⼀系列可能会处理请求的对象被连接成一条链，请求在这些对象之间依次传递，直到遇到⼀个 可以处理它的对象，我们把这些对象称为链中的节点</p>
</blockquote>
<ul>
<li>假设我们负责⼀个售卖⼿手机的电商网站，经过分别交纳 500 元定金和 200 元定金的两轮预定后(订单已在此时生成)，现在已经到了正式购买的阶段。 公司针对⽀付过定金的用户有一定的优惠政策。在正式购买后，已经支付过 500 元定金的用户会收到 100 元的商城优惠券，200 元定金的用户可以收到 50 元的优惠券，而之前没有支付定金的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况下，不一定保证能买到。</li>
<li>比起 if 嵌套，我们可以先把 500 元订单、200 元订单以及普通购买分成 3 个函数。接下来把 orderType、pay、stock 这 3 个字段当作参数传递给 500 元订单函数，如果该函数不符合处理条件，则把这个请求传递给后面的 200 元订单函数，如果 200 元订单函数依然不能处理该请求，则继续传递请求给普通购买函数</li>
<li>这样我们可以自由灵活地增加、移除和修改链中的节点顺序，假如某天网站运营人员 又想出了支持 300 元定金购买，那我们就在该链中增加⼀个节点即可</li>
</ul>
<pre><code class="language-js">var order500 = function(orderType, pay, stock) {
  if (orderType === 1 &amp;&amp; pay === true) {
    console.log('500 元定金预购，得 100 元优惠')
  } else {
    return 'nextSuccessor' // 我不知道下个节点是什么，反正把请求往后传
  }
}

var order200 = function(orderType, pay, stock) {
  if (orderType === 2 &amp;&amp; pay === true) {
    console.log('200 元定金预购，得 50 元优惠')
  } else {
    return 'nextSuccessor' // 我不知道下个节点是什么，反正把请求往后传
  }
}

var orderNormal = function(orderType, pay, stock) {
  if (stock &gt; 0) {
    console.log('普通购买')
  } else {
    console.log('没库存了')
  }
}

// Chain.prototype.setNextSuccessor 指定在链中的下一个节点
// Chain.prototype.passRequest 传递请求给某个节点
var Chain = function(fn) {
  this.fn = fn
  this.successor = null
}
Chain.prototype.setNextSuccessor = function(successor) {
  return (this.successor = successor)
}
Chain.prototype.passRequest = function() {
  var ret = this.fn.apply(this, arguments)
  if (ret === 'nextSuccessor') {
    return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments)
  }
  return ret
}

var chainOrder500 = new Chain(order500)
var chainOrder200 = new Chain(order200)
var chainOrderNormal = new Chain(orderNormal)

chainOrder500.setNextSuccessor(chainOrder200)
chainOrder200.setNextSuccessor(chainOrderNormal)

chainOrder500.passRequest(1, true, 500) // 500 元定金预购，得 100 元优惠
chainOrder500.passRequest(2, true, 500) // 200 元定金预购，得 50 元优惠
chainOrder500.passRequest(3, true, 500) // 普通购买
chainOrder500.passRequest(1, false, 0) // 没库存了
</code></pre>
<p>koa 源码还将整个链条合并为一个函数。</p>
<h2 id="适配器模式">适配器模式</h2>
<blockquote>
<p>适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。 适配器的别名是包装器(wrapper)，这是一个相对简单的模式。在程序开发中有许多这样的场景：当我们试图调用模块或者对象的某个接口 时，却发现这个接口的格式并不符合目前的需求。 这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模块很复杂，或者我们拿到的模块是一段别人编写的经过压缩的代码， 修改原接口就显得不太现实了。第二种办法是创建一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。</p>
</blockquote>
<p>如 JSON，数据交换的格式，多语言间数据交换的解决方案。</p>
<p>适配器不关心接口是怎么实现的，会怎样演化，也不改变已有接口。</p>
<p>装饰器模式和代理模式也不会改变原有对象的接口，但装饰器的作用是给对象增加功能，常常形成一条长的装饰链；而适配器模式通常只包装一次；代理模式是为了控制对对象的访问，通常也只包装一次。</p>
<p>外观模式的作用与适配器较相似，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。</p>
<pre><code class="language-js">var googleMap = {
  show: function() {},
}
var baiduMap = {
  display: function() {},
}
var baiduMapAdapter = {
  show: function() {
    return baiduMap.display()
  },
}

renderMap(googleMap)
renderMap(baiduMapAdapter)
</code></pre>
<h2 id="模板方法模式">模板方法模式</h2>
<blockquote>
<p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤的实现延迟到子类中。模板方法 使得子类可以在不改变算法结构的情况下，重新定义算法中某些步骤的具体实现</p>
</blockquote>
<p>如插槽（vue 中的 slot、react 中的 children）</p>
<pre><code class="language-react">class Parent {
	constructor() {}
	render() {
		&lt;div&gt;
        	&lt;div&gt;{this.props.children}&lt;/div&gt;
        &lt;/div&gt;
	}
}
class Stage {
    constructor() {}
	render() {
        // 在 Parent 中已经设定了 children 的渲染位置算法
        &lt;Parent&gt;
            // children 的具体实现
        	&lt;div&gt;child&lt;/div&gt;
        &lt;/Parent&gt;
    }
}
</code></pre>
<h2 id="备忘录模式">备忘录模式</h2>
<p>可以恢复对象到之前的某个状态。</p>
<p>如 react 或 redux 的时间旅行。</p>
<p>https://zh-hans.reactjs.org/tutorial/tutorial.html#implementing-time-travel</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vuex 总结与浅析源码]]></title>
        <id>https://yuufen.com/blog/post/pgLxFgJc5/</id>
        <link href="https://yuufen.com/blog/post/pgLxFgJc5/">
        </link>
        <updated>2020-02-27T06:28:50.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1583426923830.png" alt="" loading="lazy"></figure>
<p><a href="https://github.com/yuuFen/vuex-reimplement">https://github.com/yuuFen/vuex-reimplement</a></p>
<h2 id="基础总结">基础总结</h2>
<h3 id="是什么">是什么</h3>
<p>Vuex 是一个专为 Vue.js 应用开发的<strong>状态管理模式</strong>，集中式存储管理应⽤所有组件的状态。</p>
<p>Vuex遵循“单向数据流”理念，易于问题追踪以及提高代码可维护性。</p>
<p>Vue中多个视图依赖于同一状态时，视图间传参和状态同步比较困难，Vuex能够很好解决该问题。</p>
<h3 id="核心概念">核心概念</h3>
<ul>
<li>state 状态、数据</li>
<li>getters 派生状态 ，从state派生出新状态，类似计算属性</li>
<li>mutations 更改状态的函数</li>
<li>actions 异步操作 ，复杂业务逻辑，类似于controller</li>
<li>store 包含以上概念的容器</li>
</ul>
<h3 id="使用">使用</h3>
<h4 id="普通使用">普通使用</h4>
<pre><code class="language-js">// store
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    count: 0,
  },
  mutations: {
    add(state, num = 1) {
      state.count += num
    },
  },
  getters: {
    // 类似于 computer
    score(state) {
      return 'score: ' + state.count * 2
    },
  },
  actions: {
    // 复杂业务逻辑，类似于 controller
    // 如 ajax 请求、同时调用多次 commit
    asyncAdd({ commit }, num) {
      return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
          commit('add', num)
          resolve({ ok: 1 })
        }, 1000)
      })
    },
  },
  modules: {},
})
</code></pre>
<pre><code class="language-js">// vue
  &lt;h3&gt;{{ $store.state.count }}&lt;/h3&gt;
  &lt;h3&gt;{{ $store.getters.score }}&lt;/h3&gt;

  methods: {
    add() {
      this.$store.commit('add')
    },
    asyncAdd() {
      this.$store.dispatch('asyncAdd').then((res) =&gt; {
        if (res.ok === 1) {
          alert('ok')
        }
      })
    },
</code></pre>
<h4 id="模块化">模块化</h4>
<p>/store/count.js</p>
<pre><code class="language-js">export default {
  namespaced: true, // 单独的命名空间
  state: {
    count: 0,
  },
  mutations: {
    add(state, num = 1) {
      state.count += num
    },
  },
  getters: {
    score(state) {
      return 'score: ' + state.count * 2
    },
  },
  actions: {
    asyncAdd({ commit }, num) {
      return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
          commit('add', num)
          resolve({ ok: 1 })
        }, 1000)
      })
    },
  },
}
</code></pre>
<p>/store/index.js</p>
<pre><code class="language-js">import Vue from 'vue'
import Vuex from 'vuex'
import count from './count'

Vue.use(Vuex)

export default new Vuex.Store({
  modules: {
    c: count,
  },
})
</code></pre>
<p>vue</p>
<pre><code class="language-js">    &lt;h3&gt;{{ $store.state.c.count }}&lt;/h3&gt;
    &lt;h3&gt;{{ $store.getters['c/score'] }}&lt;/h3&gt;
    
  methods: {
    add() {
      this.$store.commit('c/add')
    },
    asyncAdd() {
      this.$store.dispatch('c/asyncAdd').then((res) =&gt; {
        if (res.ok === 1) {
          alert('ok')
        }
      })
    },
  },
</code></pre>
<h2 id="浅析源码">浅析源码</h2>
<h3 id="目标">目标</h3>
<ol>
<li>维护状态 state （响应式）</li>
<li>修改状态 commit</li>
<li>业务逻辑控制 dispatch</li>
<li>状态派发 getter（响应式）</li>
<li>混入</li>
</ol>
<h3 id="实现">实现</h3>
<pre><code class="language-js">let Vue

function install(_Vue) {
  Vue = _Vue

  Vue.mixin({
    beforeCreate() {
      if (this.$options.store) {
        Vue.prototype.$store = this.$options.store
      }
    },
  })
}

class Store {
  constructor(options) {
    this.state = new Vue({
      data: options.state,
    })

    this.mutations = options.mutations || {}
    this.actions = options.actions || {}

    options.getters &amp;&amp; this.handleGetters(options.getters)
  }

  commit = (type, arg) =&gt; {
    // 如果不使用箭头函数，dispatch 中调用时 this 会改变
    // console.log(this)
    const fn = this.mutations[type]
    fn(this.state, arg)
  }

  dispatch(type, arg) {
    const fn = this.actions[type]
    return fn({ commit: this.commit, state: this.state }, arg)
  }

  // {foo(state){},doo(state){}}
  handleGetters(getters) {
    this.getters = {}

    // 定义只读属性和响应式
    Object.keys(getters).forEach((key) =&gt; {
      Object.defineProperty(this.getters, key, {
        get: () =&gt; {
          return getters[key](this.state)
        },
      })
    })
  }
}

export default { Store, install }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-router 扩展 API 与浅析源码]]></title>
        <id>https://yuufen.com/blog/post/8pW7fVIsz/</id>
        <link href="https://yuufen.com/blog/post/8pW7fVIsz/">
        </link>
        <updated>2020-02-26T08:30:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>原版实现更更更更值得学习</p>
<p><a href="https://github.com/vuejs/vue-router">vue-router</a></p>
<p><a href="https://github.com/vuejs/vue-router/blob/dev/src/components/view.js">router-view</a></p>
</blockquote>
<h2 id="扩展">扩展</h2>
<h3 id="懒加载">懒加载</h3>
<pre><code class="language-js">      // 路由层级代码分割，生成分片(about.[hash].js)      
      // 当路由访问时会懒加载.      
      component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ './views/About.vue')
</code></pre>
<h3 id="路由守卫">路由守卫</h3>
<p>全局守卫</p>
<p>路由独享守卫</p>
<p>组件内守卫</p>
<h3 id="动态路由">动态路由</h3>
<p>利用$router.addRoutes()可以实现动态路由添加，常用于用户权限控制。</p>
<pre><code class="language-js">// router.js
// 接口返回数据可能是这样的
// [{
//   path: &quot;/&quot;,
//   name: &quot;home&quot;,
//   component: &quot;Home&quot;, //Home
// }]

// 异步获取路路由
api.getRoutes().then((routes) =&gt; {
  const routeConfig = routes.map((route) =&gt; mapComponent(route))
  router.addRoutes(routeConfig)
})

// 映射关系
const compMap = {
  Home: () =&gt; import('./view/Home.vue'),
}

// 递归替换
function mapComponent(route) {
  route.component = compMap[route.component]
  if (route.children) {
    route.children = route.children.map((child) =&gt; mapComponent(child))
  }
  return route
}
</code></pre>
<h3 id="面包屑">面包屑</h3>
<p>利用$route.matched可得到路由匹配数组，按顺序解析可得路由层次关系。</p>
<pre><code class="language-js">// Breadcrumb.vue
watch: {
  $route: {
    handler(route) {
      // [{name:'home',path:'/'},{name:'list',path:'/list'}]
      console.log(this.$route.matched);
      // ['home','list']
      this.crumbData = this.$route.matched.map(m =&gt; m.name || m.redirect)
    },
    immediate: true // 让它 create 的时候执行一次
  }
}
</code></pre>
<h2 id="简单重现">简单重现</h2>
<p>https://github.com/yuuFen/vue-router-reimplement</p>
<h3 id="通常用法与目标分析">通常用法与目标分析</h3>
<pre><code class="language-js">import Vue from 'vue'
import VueRouter from 'vue-router'

import Home from &quot;./views/Home&quot;
import About from &quot;./views/About&quot;

Vue.use(VueRouter)

export default new VueRouter({
    routes: [
        { path: '/', component: Home },
        { path: '/about', component: About },
    ]
})
</code></pre>
<pre><code class="language-js">import router from './router'

new View({
    router,
    // ...
})
</code></pre>
<p>目标：</p>
<ol>
<li>解析routes，变成一个key为path，value为component的map</li>
<li>监听url变化事件，把最新的hash值保存到current路由</li>
<li>定义两个全局组件：router-view用于显示匹配组件的内容，router-link用于修改hash</li>
<li>current应该是响应式的，这样可以触发router-view的重新渲染</li>
</ol>
<h3 id="实现">实现</h3>
<blockquote>
<p>没有考虑嵌套</p>
</blockquote>
<pre><code class="language-js">// install 时获取
let Vue

// hash 改变 =&gt; current (响应式)改变 =&gt; router-view 的 render 改变
export default class VueRouter {
  constructor(options) {
    this.$options = options

    // 用来保存 path 和 route 的映射
    this.routeMap = {}

    // 利用 Vue 让 current 实现响应式
    this.app = new Vue({
      data: {
        current: '/',
      },
    })
  }

  init() {
    // 绑定浏览器事件
    this.bindEvents()

    // 解析路由配置
    this.createRouteMap(this.$options)

    // 创建 router-link 和 router-view
    this.initComponent()
  }

  bindEvents() {
    window.addEventListener('hashchange', this.onHashChange.bind(this))
    window.addEventListener('load', this.onHashChange.bind(this))
  }
  onHashChange() {
    this.app.current = window.location.hash.slice(1) || '/'
  }
  createRouteMap(options) {
    options.routes.forEach((item) =&gt; {
      this.routeMap[item.path] = item
    })
  }
  initComponent() {
    Vue.component('router-link', {
      props: {
        to: String,
      },
      render(h) {
        // 目标：&lt;a :href=&quot;to&quot;&gt;doooo&lt;/a&gt;
        // 这里 this 指向 router-link 组件实例
        return h('a', { attrs: { href: '#' + this.to } }, this.$slots.default)
        // return &lt;a href={this.to}&gt;{this.$slots.default}&lt;/a&gt;  // 需要 babel-loader
      },
    })
    Vue.component('router-view', {
      // 箭头函数可以保留 this 指向，所以这里指向 VueRouter 实例
      render: (h) =&gt; {
        // console.log(this.app.current)
        // console.log(this.routeMap)
        // console.log(this.routeMap[this.app.current])
        const Comp = this.routeMap[this.app.current].component
        return h(Comp)
      },
    })
  }
}

VueRouter.install = function(_Vue) {
  Vue = _Vue

  Vue.mixin({
    beforeCreate() {
      // 每个组件 beforeCreate 的时候都会执行
      // 但是这里只希望在根组件上执行一次
      // this 指向 Vue 组件实例
      // this.$options.router 就是在 router.js 中 new 的 VueRouter 实例
      if (this.$options.router) {
        Vue.prototype.$router = this.$options.router
        this.$options.router.init()
      }
    },
  })
}
</code></pre>
<h3 id="使用同原版">使用同原版</h3>
<pre><code class="language-js">import Vue from 'vue'
import VueRouter from '../utils/router'

import Home from '../views/Home.vue'
import About from '../views/About.vue'
import Main from '../views/Main.vue'

Vue.use(VueRouter)

export default new VueRouter({
  routes: [
    { path: '/', component: Home },
    { path: '/main', component: Main },
    { path: '/about', component: About },
  ],
})
</code></pre>
<pre><code class="language-js">// ...

import router from './router'

new Vue({
  router,
  render: (h) =&gt; h(App),
}).$mount('#app')
</code></pre>
<pre><code class="language-html">    &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;
    &lt;router-link to=&quot;/main&quot;&gt;Main&lt;/router-link&gt;
    &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 组件化]]></title>
        <id>https://yuufen.com/blog/post/Bpq2VQQen/</id>
        <link href="https://yuufen.com/blog/post/Bpq2VQQen/">
        </link>
        <updated>2020-02-25T09:56:41.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1583424020660.png" alt="" loading="lazy"></figure>
<h2 id="组件间通信">组件间通信</h2>
<h3 id="父组件-子组件">父组件 =&gt; 子组件</h3>
<ul>
<li>属性 props</li>
</ul>
<pre><code class="language-vue">// child 
props: { msg: String } 
// parent 
&lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot; /&gt;
</code></pre>
<ul>
<li>$attrs / $listeners</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>r</mi><mi>s</mi><mi mathvariant="normal">储</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">域</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">被</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">识</mi><mi mathvariant="normal">别</mi><mo>(</mo><mi mathvariant="normal">且</mi><mi mathvariant="normal">获</mi><mi mathvariant="normal">取</mi><mo>)</mo><mi mathvariant="normal">的</mi><mi mathvariant="normal">特</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">绑</mi><mi mathvariant="normal">定</mi><mo>(</mo><mi>c</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mi mathvariant="normal">和</mi><mi>s</mi><mi>t</mi><mi>y</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">除</mi><mi mathvariant="normal">外</mi><mo>)</mo><mi mathvariant="normal">，</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi>v</mi><mo>−</mo><mi>b</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">attrs储存的是父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外) ，使用v-bind=&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">储</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">域</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">被</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">识</span><span class="mord cjk_fallback">别</span><span class="mopen">(</span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">获</span><span class="mord cjk_fallback">取</span><span class="mclose">)</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">绑</span><span class="mord cjk_fallback">定</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">和</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">除</span><span class="mord cjk_fallback">外</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">&quot;</span></span></span></span>attrs&quot;可以实现自动挂载。</p>
<p>默认组件根元素上会自动挂载没有在props声明的属性，配置 inheritAttrs: false 可以关闭。</p>
<ul>
<li>引用 $refs</li>
</ul>
<pre><code class="language-vue">// parent
&lt;HelloWorld ref=&quot;hw&quot; /&gt;

this.$refs.hw.xx = 'xxx'
</code></pre>
<ul>
<li>$children</li>
</ul>
<pre><code>// parent
this.$children[0].xx = 'xxx'
</code></pre>
<blockquote>
<p>不保证顺序</p>
</blockquote>
<h3 id="子组件-父组件">子组件 =&gt; 父组件</h3>
<p>自定义事件：</p>
<pre><code class="language-vue">// child 
this.$emit('add', good) 
// parent 
&lt;Cart @add=&quot;cartAdd($event)&quot;&gt;&lt;/Cart&gt;
</code></pre>
<p>观察者模式，因为是作用域是 this 所以<strong>谁派发谁监听</strong>。</p>
<h3 id="v-model-双向绑定-与-sync-的区别">v-model 双向绑定 / 与 .sync 的区别</h3>
<ul>
<li>
<p>v-model=&quot;bar&quot;是 :value=&quot;bar&quot; @input=&quot;bar=$event&quot; 的语法糖</p>
<p>但是可以在<strong>组件中</strong>设置model选项修改v-model的默认行为</p>
</li>
</ul>
<pre><code class="language-js">// Checkbox.vue
{
  {
    model: {
      prop: 'checked'
      event: 'change'
    }
  }
}
</code></pre>
<ul>
<li>
<p>value.sync=”bar“ 是 :value=&quot;bar&quot; @update:value=&quot;bar=$event&quot; 的语法糖</p>
<p>要更改绑定的属性名称，需要在<strong>父组件</strong>中更改，如：</p>
<pre><code class="language-html">&lt;m-input foo.sync=&quot;bar&quot;&gt;
等效于
&lt;m-input :foo=&quot;bar&quot; @update:foo=&quot;bar=$event&quot;&gt; 
</code></pre>
</li>
</ul>
<h3 id="兄弟组件">兄弟组件</h3>
<p>通过共同的祖辈组件搭桥，$parent 或 $root：</p>
<pre><code class="language-js">// brother1
this.$parent.$on('foo', handle)

// brother2
this.$parent.$emit('foo')
</code></pre>
<h3 id="祖先与后代">祖先与后代</h3>
<ul>
<li>provide / inject 可以实现祖先给后代传值，可以传对象：</li>
</ul>
<pre><code class="language-js">// ancestor
provide() {    
  return {foo: 'foo'}
}

// descendant
inject: ['foo']
</code></pre>
<blockquote>
<p>provide 和 inject 主要为高阶插件/组件库提供用例，并不推荐直接用于应用程序代码中，多会在开源组件库中见到。<br>
后代想给祖先传值这种方案行不通</p>
</blockquote>
<ul>
<li>广播，自上而下</li>
</ul>
<p>https://github.com/ElemeFE/element/blob/dev/src/mixins/emitter.js</p>
<pre><code class="language-js">function broadcast(componentName, eventName, params) {
  this.$children.forEach(child =&gt; {
    var name = child.$options.componentName;

    if (name === componentName) {
      child.$emit.apply(child, [eventName].concat(params));
    } else {
      broadcast.apply(child, [componentName, eventName].concat([params]));
    }
  });
}
</code></pre>
<ul>
<li>自下而上</li>
</ul>
<pre><code class="language-js">dispatch(componentName, eventName, params) {
  var parent = this.$parent || this.$root;
  var name = parent.$options.componentName;

  while (parent &amp;&amp; (!name || name !== componentName)) {
    parent = parent.$parent;

    if (parent) {
      name = parent.$options.componentName;
    }
  }
  if (parent) {
    parent.$emit.apply(parent, [eventName].concat(params));
  }
},
</code></pre>
<h3 id="任意两个组件之间事件总线-vuex">任意两个组件之间：事件总线 / Vuex</h3>
<ul>
<li>事件总线</li>
</ul>
<pre><code class="language-js">// 创建一个Bus类负责事件派发、监听和回调管理
class Bus {
  constructor() {
    this.callbacks = {}
  }
  $on(name, fn) {
    ;(this.callbacks[name] || this.callbacks[name] = []).push(fn)
  }
  $emit(name, ...args) {
    const cbs = this.callback[name]
    if (cbs) {
      cbs.forEach((cb) =&gt; {
        cb.call(this, ...args)
      })
    }
  }
}

// main.js
Vue.prototype.$bus = new Bus()

// child1
this.$bus.$on('foo', handle)
// child2
this.$bus.$emit('foo')
</code></pre>
<pre><code class="language-js">// 或者 main.js 直接
Vue.prototype.$bus = new Vue()
</code></pre>
<ul>
<li>Vuex</li>
</ul>
<p>创建唯一的全局数据管理者 store，通过它管理数据并通知组件状态变更</p>
<h2 id="组件复合-内容分发插槽">组件复合 / 内容分发：插槽</h2>
<p>模板方法模式。匿名插槽、具名插槽、作用域插槽。</p>
<blockquote>
<p>Vue 2.6.0之后采用全新的v-slot语法取代之前的slot、slot-scope</p>
</blockquote>
<pre><code class="language-vue">// comp2 
&lt;div&gt;
  &lt;slot&gt;&lt;/slot&gt;
  &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;
  &lt;slot name=&quot;bar&quot; foo=&quot;foooooooo&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;

// parent 
&lt;Comp2&gt;
  &lt;!-- 匿名插槽用default做参数 --&gt;
  &lt;template v-slot:default&gt;具名插槽&lt;/template&gt;
  &lt;!-- 具名插槽用插槽名做参数 --&gt;
  &lt;template v-slot:content&gt;内容...&lt;/template&gt;
  &lt;!-- 作用域插槽获取子组件传来的数据 --&gt;
  &lt;template v-slot:content=&quot;ctx&quot;&gt;来自子组件数据：{{ctx.foo}}&lt;/template&gt;
&lt;/Comp2&gt;
</code></pre>
<h2 id="弹窗组件">弹窗组件</h2>
<p>弹窗这类组件的特点是它们在当前vue实例例之外独⽴立存在，通常挂载于body（所以需要 new 一个 Vue 实例）；它们是通过JS动态创建 的，不需要在任何组件中声明。</p>
<p>create.js</p>
<pre><code class="language-js">import Vue from 'vue'
export default function create(Component, props) {
  const vm = new Vue({
    render(h) {
      // render 方法提供 h 函数，用来渲染 VNode
      return h(Component, { props })
    },
  }).$mount() // 做好挂载准备(生成DOM)但暂不挂载（因为不支持直接挂载到body），为下面 $el 做准备

  // 1. vm 创建组件实例
  // 2. 通过 $children 获取创建好的传入组件的实例
  const comp = vm.$children[0]

  // 3. 追加至body
  document.body.appendChild(vm.$el)

  // 4. 给组件直接挂载上清理函数
  comp.remove = function(){
    document.body.removeChild(vm.$el)
    vm.$destroy()
  }

  // 5. 返回组件实例
  return comp
}
</code></pre>
<p>notice.vue</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div v-if=&quot;iShow&quot;&gt;
    &lt;h3&gt;title&lt;/h3&gt;
    &lt;div&gt;message&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: {
    title: { type: String, default: '' },
    message: { type: String, default: '' },
    duration: { type: Number, default: 1000 },
  },
  data() {
    return {
      isShow: false,
    }
  },
  methods: {
    show() {
      this.isShow = true
      setTimeout(() =&gt; {
        this.hide()
      }, this.duration)
    },
    hide() {
      this.isShow = false
      this.remove() // 来自 create.js
    },
  },
}
&lt;/script&gt;
</code></pre>
<p>Father.vue</p>
<pre><code class="language-js">import create from '...' // 或者直接挂在 Vue.prototype 上，能在任何地方 Create
import Notice from '...'

  const notice = create(Notice, {
    title: 'Title',
    message: 'Message',
    duration: 2000
  })
  notice.show()

</code></pre>
<h2 id="递归组件">递归组件</h2>
<pre><code class="language-vue">// Node.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;{{ data.title }}&lt;/h3&gt;
    &lt;!-- 必须有结束条件 --&gt;
    &lt;Node v-for=&quot;d in data.children&quot; :key=&quot;d.id&quot; :data=&quot;d&quot;&gt;&lt;/Node&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: 'Node', // name对递归组件是必要的
  props: {
    data: {
      type: Object,
      require: true,
    },
  },
}
&lt;/script&gt;

// 使用 
&lt;Node :data=&quot;{id:'1',title:'递归组件',children:[{...}]}&quot;&gt;&lt;/Node&gt;
</code></pre>
<h3 id="tree-组件">Tree 组件</h3>
<p>Father.vue</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;ul&gt;
      &lt;item :model=&quot;treeData&quot;&gt;&lt;/item&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>item.vue</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;li&gt;
    &lt;div @click=&quot;toggle&quot;&gt;
        {{model.title}}
        &lt;span v-if=&quot;haveChild&quot;&gt;{{open ? '-' : '+'}}&lt;/span&gt;
    &lt;/div&gt;
    &lt;ul&gt;
        &lt;item v-for=&quot;model in model.children&quot; :model=&quot;model&quot; :key=&quot;model.title&quot;&gt;&lt;/item&gt;  
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/template&gt;

// 懒加载：传入标识符 =&gt; 判断标识符 true =&gt; show loading、请求数据
</code></pre>
<h2 id="plugins">plugins</h2>
<pre><code class="language-js">// 插件定义 
MyPlugin.install = function (Vue, options) {  
  // 1. 添加全局方法或属性  
  Vue.myGlobalMethod = function () {    
    // 逻辑...  
  }
  // 2. 添加全局资源  
  Vue.directive('my-directive', {    
    bind (el, binding, vnode, oldVnode) {     
      // 逻辑...    
    }  
    ...  
  })
  // 3. 注⼊组件选项
  Vue.mixin({  
    created: function () {   
      // 逻辑...  
    } 
    ... 
  })
  // 4. 添加实例方法 
  Vue.prototype.$myMethod = function (methodOptions) {
    // 逻辑... 
  }
}

// 插件使用
Vue.use(MyPlugin)
</code></pre>
<h2 id="mixins">mixins</h2>
<pre><code class="language-js">// 定义一个混入对象
var myMixin = {
  created: function() {
    this.hello()
  },
  methods: {
    hello: function() {
      console.log('hello from mixin!')
    },
  },
}
// 定义一个使用混入对象的组件
var Component = Vue.extend({
  mixins: [myMixin],
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数柯里化]]></title>
        <id>https://yuufen.com/blog/post/gxNr15aBN/</id>
        <link href="https://yuufen.com/blog/post/gxNr15aBN/">
        </link>
        <updated>2020-02-24T04:16:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="柯里化从何而来">柯里化从何而来</h2>
<p>柯里化, 即 Currying 的音译。Currying 是编译原理层面实现多参函数的一个技术。</p>
<p>在编码过程中，身为码农的我们本质上所进行的工作就是——将复杂问题分解为多个可编程的小问题。</p>
<p>Currying 为实现多参函数提供了一个递归降解的实现思路——把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数，在某些编程语言中（如 Haskell），是通过 Currying 技术支持多参函数这一语言特性的。</p>
<p>所以 Currying 原本是一门编译原理层面的技术，用途是实现多参函数。</p>
<h2 id="实现原理">实现原理</h2>
<pre><code class="language-js">let _fn = curry(function(a, b, c, d, e) {
  console.log(a + b + c + d + e)
})

// 目标：
_fn(1, 2, 3, 4, 5) // 15
_fn(1)(2, 3)(4)(5) // 15
_fn(1)(2)(3)(4)(5) // 15

// 实现，可以把 _curry() 提取出来
function curry(fn, len = fn.length) {
  return function _curry(...args) {
    if (args.length &gt;= len) {
      return fn.apply(this, args)
    }
    return function(...params) {
      _args = [...args, ...params]

      if (_args.length &gt;= len) {
        return fn.apply(this, _args)
      } else {
        return _curry.call(this, ..._args)
      }
    }
  }
}
</code></pre>
<h2 id="currying-使用场景">Currying 使用场景</h2>
<h3 id="参数复用">参数复用</h3>
<p>固定不变的参数，实现参数复用是 Currying 的主要用途之一。<br>
上文中的 increment, addTen 是一个参数复用的实例。对 add 方法固定第一个参数为 10 后，改方法就变成了一个将接受的变量值加 10 的方法。</p>
<h3 id="延迟执行">延迟执行</h3>
<p>延迟执行也是 Currying 的一个重要使用场景，同样 bind 和箭头函数也能实现同样的功能。<br>
在前端开发中，一个常见的场景就是为标签绑定 onClick 事件，同时考虑为绑定的方法传递参数。</p>
<h2 id="为什么需要-currying">为什么需要 Currying</h2>
<h3 id="为了多参函数复用性">为了多参函数复用性</h3>
<p>Currying 让人眼前一亮的地方在于，让人觉得函数还能这样子复用。</p>
<p>通过一行代码，将 add 函数转换为 increment，addTen 等。</p>
<p>对于 Currying 的复杂实现中，以 Lodash 为列，提供了 placeholder 的神奇操作。对多参函数的复用玩出花样。</p>
<pre><code class="language-js">import _ from 'loadsh'

function abc(a, b, c) {
  return [a, b, c]
}

var curried = _.curry(abc)

// Curried with placeholders.
curried(1)(_, 3)(2)
// =&gt; [1, 2, 3]
</code></pre>
<h3 id="为函数式编程而生">为函数式编程而生</h3>
<p>Currying 是为函数式而生的东西。应运着有一整套函数式编程的东西，纯函数、compose、container 等等事物。（可阅读《mostly-adequate-guide》 ）<br>
假如要写 Pointfree Javascript 风格的代码，那么 Currying 是不可或缺的。<br>
要使用 compose，要使用 container 等事物，我们也需要 Currying。</p>
<h2 id="为什么不需要-currying">为什么不需要 Currying</h2>
<h3 id="currying-的一些特性有其他解决方案">Currying 的一些特性有其他解决方案</h3>
<p>如果我们只是想提前绑定参数，那么我们有很多好几个现成的选择，bind，箭头函数等，而且性能比 Curring 更好。</p>
<h3 id="currying-陷于函数式编程">Currying 陷于函数式编程</h3>
<p>在本文中，提供了一个 trueCurrying 的实现，这个实现也是最符合 Currying 定义的，也提供 了 bind，箭头函数等不具备的“新奇”特性——可持续的 Currying（这个词是本人临时造的）。<br>
但是这个“新奇”特性的应用并非想象得那么广泛。<br>
其原因在于，Currying 是函数式编程的产物，它生于函数式编程，也服务于函数式编程。<br>
而 JavaScript 并非真正的函数式编程语言，相比 Haskell 等函数式编程语言，JavaScript 使用 Currying 等函数式特性有额外的性能开销，也缺乏类型推导。<br>
从而把 JavaScript 代码写得符合函数式编程思想和规范的项目都较少，从而也限制了 Currying 等技术在 JavaScript 代码中的普遍使用。<br>
假如我们还没有准备好去写函数式编程规范的代码，仅需要在 JSX 代码中提前绑定一次参数，那么 bind 或箭头函数就足够了。</p>
<h2 id="结论">结论</h2>
<ol>
<li>Currying 在 JavaScript 中是“低性能”的，但是这些性能在绝大多数场景，是可以忽略的。</li>
<li>Currying 的思想极大地助于提升函数的复用性。</li>
<li>Currying 生于函数式编程，也陷于函数式编程。假如没有准备好写纯正的函数式代码，那么 Currying 有更好的替代品。</li>
<li>函数式编程及其思想，是值得关注、学习和应用的事物。所以在文末再次安利 JavaScript 程序员阅读此书 —— 《mostly-adequate-guide》</li>
</ol>
<p>部分转载于 https://juejin.im/post/5af13664f265da0ba266efcf</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[做博客的目的与大致记录]]></title>
        <id>https://yuufen.com/blog/post/azDr69oSX/</id>
        <link href="https://yuufen.com/blog/post/azDr69oSX/">
        </link>
        <updated>2018-12-25T10:35:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>第一篇博文，留作纪念<br>
才发现那天是圣诞节，祝大家圣诞快乐🎉</p>
</blockquote>
<h2 id="目的与简介">目的与简介</h2>
<p>我一直都有记笔记的习惯，但是并不会去主动整理，于是图片也好，文本也好，都散落在各个文件夹或是抽屉里。于是就有了搭建一个博客整理笔记的念头。选择的是最简单的 hexo + github ，以后会考虑尝试 python + WAMP 。虽然最开始只想做个技术博客，但<s>或许以后反而会以日常生活为主</s>。</p>
<p>这篇博客简单记述了我在使用 hexo 搭载博客的过程中走过的路和跌过的坑。目的是总结这三天看了许多教程的成果以及尝试 markdown 的排版。</p>
<h2 id="配置环境">配置环境</h2>
<p>安装 Hexo 之前，需要安装环境 Node.js 和 Git 。最新版官网下载太慢，我选择的是老版本的国内镜像。安装过程都是下一步，这里就不累述了。<br>
安装完成后在 cmd 输入以下代码：</p>
<pre><code>node -v
npm -v
git --version
</code></pre>
<p>返回了版本号，安装成功。</p>
<h2 id="安装hexo">安装hexo</h2>
<p>安装好 node.js 和 git 后，可以通过 npm 来安装 Hexo 。</p>
<pre><code>npm install -g hexo-cli
</code></pre>
<h2 id="初始化hexo">初始化Hexo</h2>
<p>在博客根目录输入以下代码：</p>
<pre><code>hexo init
npm install
</code></pre>
<p>提示了两个 WARN ，WINDOWS 用户可以忽略。</p>
<h2 id="建站">建站</h2>
<p>hexo 的命令我就不细说了，有中文的帮助文档。</p>
<h2 id="部署到github">部署到github</h2>
<p>这里的花了我很长时间，有以下几个要点：</p>
<h3 id="创建仓库">创建仓库</h3>
<p>仓库名需要用<code>用户名.github.io</code>的形式。</p>
<h3 id="添加部署路径">添加部署路径</h3>
<ul>
<li>属性和内容之间有一个空格；</li>
<li>需要配置SSH等参数，这部分搜git就有很多相关教程。</li>
</ul>
<h3 id="安装插件">安装插件</h3>
<p>输入命令行<code>npm install hexo-deployer-git --save</code>安装插件的时候，报错提示<code>This package is no longer maintained</code>该插件不再维护。<br>
这里需要安装cnpm：</p>
<pre><code>npm install cnpm -g --tegistry=https://registry.npm.taobao.org
</code></pre>
<p>安装过程中报错：</p>
<pre><code>npm WARN deprecated socks@1.1.10: If using 2.x branch, please upgrade to at least 2.1.6 to avoid a serious bug with socket data flow and an import issue introduced in 2.1.0
</code></pre>
<p>是因为npm的一个包版本太低，因为是WARN，就忽略了。然后用淘宝NPM镜像的<code>hexo-deployer-git</code>试了一下：</p>
<pre><code>cnpm install hexo-deployer-git --save
</code></pre>
<p>安装成功了。</p>
<h3 id="发布">发布</h3>
<p>在根目录打开 git bash ，键入：</p>
<pre><code>hexo d -g
</code></pre>
<p>提示<code>git:done</code>，部署成功，至此我完成了一个可以即时访问的个人博客。</p>
<h2 id="域名申请">域名申请</h2>
<h3 id="购买域名">购买域名</h3>
<p>我在 <a href="https://my.freenom.com/clientarea.php">Freenom</a> 上获取了这个免费域名，freenom 提供了 tk、ml、ga、cf、gq 这几类后缀的免费域名。tk域名，意为 Talker（说话的人）。.tk 域名是南太平洋岛国托克劳的顶级域名, .ml 是非洲国家马里的后缀, .ga 域名为加蓬国家顶级域名后缀, .cf 是中非共和国的后缀, .gq 域名是赤道几内亚国家地区顶级域名。</p>
<h3 id="解析域名">解析域名</h3>
<p>虽然freenom自身也能进行DNS解析，但是毕竟不适合国内的朋友使用。所以我使用了国内的 <a href="https://www.cloudxns.net/">CloudXNS</a> ，需要实名认证。</p>
<h2 id="域名绑定page服务">域名绑定Page服务</h2>
<h3 id="添加纪录">添加纪录</h3>
<figure data-type="image" tabindex="1"><img src="https://dooyuu-1258391541.cos.ap-shanghai.myqcloud.com/%E7%AC%94%E8%AE%B0/QQ%E6%88%AA%E5%9B%BE20181227172233.png" alt="CloudXNS记录" loading="lazy"></figure>
<h3 id="配置page服务">配置Page服务</h3>
<p>在根目录下的sourse目录下新建文件CNAME，用Sublime打开填入刚获得的域名。<br>
然后用sublime打开站点配置文件，查找 skip_render ，改为</p>
<pre><code>skip_render:
  - README.md  
  - CNAME
</code></pre>
<p>这个指令可以防止每次hexo重新渲染把它们清除掉。这里的README.md可有可无，最好还是有，因为每个github项目都需要一个readme文件，添加位置和CNAME一样。</p>
<p>至此，这个个人博客就大致上完成了！</p>
<hr>
<h2 id="总结">总结</h2>
<p>摸索了一段时间才完成的，还是很有成就感的，比较遗憾的是并没有很好地记录下自己搭建这么一个网站的过程。以后会好好写博客的！</p>
]]></content>
    </entry>
</feed>