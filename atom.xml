<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yuufen.com/blog</id>
    <title>YuuFen</title>
    <updated>2020-06-26T14:05:04.369Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yuufen.com/blog"/>
    <link rel="self" href="https://yuufen.com/blog/atom.xml"/>
    <subtitle>希望你可以记住我</subtitle>
    <logo>https://yuufen.com/blog/images/avatar.png</logo>
    <icon>https://yuufen.com/blog/favicon.ico</icon>
    <rights>All rights reserved 2020, YuuFen</rights>
    <entry>
        <title type="html"><![CDATA[你好呀，陌生人]]></title>
        <id>https://yuufen.com/blog/post/about/</id>
        <link href="https://yuufen.com/blog/post/about/">
        </link>
        <updated>2024-02-28T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>因为笔记太多太杂，决定定期写写博客整理整理笔记。</p>
<p><s>然后因为各种原因失去了动力</s></p>
<p><s>因此搞丢了好多笔记啊啊啊啊啊啊啊😭😭😭</s></p>
<p><s>看了看一年前的博文发现自己真的变化了蛮多的（加油💪）</s></p>
<p>总之现在又开始了</p>
<h2 id="关于我">🐟 关于我</h2>
<p>我目前大二在读，我的职业规划是前端工程师，我的专业是电子信息，所以我还了解一些嵌入式开发（当然只是一些些），对Python和TensorFlow也有一定的涉猎。我正在努力寻找暑期实习！</p>
<p>在以下位置找到有关我的更多信息：</p>
<p><a href="https://yuufen.com/" target="_blank" class="text-button">主页</a><a href="https://yuufen.com/blog" target="_blank" class="text-button">博客</a><a href="https://github.com/yuuFen" target="_blank" class="text-button">项目</a><a href="mailto:me@yuufen.com" class="text-button">给我发邮件</a></p>
<h2 id="兴趣爱好">🎨 兴趣爱好</h2>
<p><strong>摄影</strong>、羽毛球、轮滑，and playing!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用户鉴权的四种方式]]></title>
        <id>https://yuufen.com/blog/post/g--Ijm-z9/</id>
        <link href="https://yuufen.com/blog/post/g--Ijm-z9/">
        </link>
        <updated>2020-06-25T22:57:16.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>常用鉴权方式</p>
<ul>
<li>Session / Cookie</li>
<li>Token</li>
<li>OAuth</li>
<li>SSO</li>
</ul>
</blockquote>
<h2 id="session-cookie">Session - Cookie</h2>
<h3 id="原理">原理</h3>
<blockquote>
<p>实现原理：</p>
<ol>
<li>服务器在接受客户端首次访问时在服务器端创建并储存 seesion (我们可以将 seesion 保存在内存中，也可以保存在 <strong>redis</strong> 中，推荐使用后者)，然后给这个 session 生成一个唯一的标识字符串sid,并在响应头中种下这个唯一标识字符串。</li>
<li>签名。通过秘钥对sid进行签名处理，避免客户端修改sid。（非必需步骤）
<ol>
<li>哈希 Hash - SHA MD5 HMAC</li>
<li>摘要</li>
<li>对称 DES</li>
<li>非对称 - RSA</li>
</ol>
</li>
<li>浏览器中收到请求响应的时候会解析响应头，将sid保存在本地cookie中，浏览器在下次 http请求的请求头中会带上该域名下的cookie信息，</li>
<li>服务器在接受客户端请求时会解析请求头cookie中的sid，根据sid去找服务器端保存的该客户端的session，以此判断该请求是否合法</li>
</ol>
<p>不足：</p>
<ol>
<li>服务端保存有状态</li>
<li>APP 没有 cookie，跨域不好解决</li>
</ol>
</blockquote>
<pre><code class="language-js">const http = require('http')

const session = {} // 用来保存用户信息
const sessionKey = 'sid'
http
  .createServer((req, res) =&gt; {
    if (req.url === '/favicon.ico') {
      res.end('')
    }

    const cookie = req.headers.cookie

    if (cookie &amp;&amp; cookie.indexOf(sessionKey) &gt; -1) {
      // 如果 cookie 中存在 sessionKey
      res.end('come back')
      // 取得 sid
      const pattern = new RegExp(`${sessionKey}=([^;]+);?\s*`)
      const sid = pattern.exec(cookie)[1]
      // 取得用户信息（保存在服务器）
      console.log('get session', session[sid])
    } else {
      // 如果 cookie 中不存在 sessionKey
      // 设置 sid，保存在 cookie 中
      const sid = Math.random() * 99999999
      res.setHeader('Set-Cookie', `${sessionKey}=${sid}`)
      res.end('Hi Jerry')
      // 在服务器中保存 sid 与 用户信息
      session[sid] = { name: 'Jerry' }
      console.log('set session', session[sid])
    }
  })
  .listen(3000)
</code></pre>
<h3 id="koa-中的实现-使用中间件-koa-session">koa 中的实现 - 使用中间件 koa-session</h3>
<pre><code class="language-js">const Koa = require('koa')
const session = require('koa-session')

const app = new Koa()
app.keys = ['SUOIJIHIJO#U$()_IKRJIW!Q']

const SESS_CONFIG = {
  key: 'test:sess',
  maxAge: 3600000, // ms
  httpOnly: true,
  // 签名，对 session ID 的值进行一次 hash 加密
  // 来防止伪造 cookie
  signed: true, 
}

app.use(session(SESS_CONFIG, app))

app.use((ctx) =&gt; {
  if (ctx.path === '/favicon.ico') return
  // 从 session 中取数据
  const n = ctx.session.count || 1
  // 往 session 中存数据
  ctx.session.count = n + 1

  ctx.body = JSON.stringify(ctx.session) + '\n第' + n + '次访问'
})

app.listen(3000)
</code></pre>
<h3 id="使用-redis-存储-session">使用 redis 存储 session</h3>
<h4 id="基本使用">基本使用</h4>
<pre><code class="language-js">const redis = require('redis')

const client = redis.createClient(6379, 'localhost')

client.set('hello', 'Hello, world!')

client.get('hello', (err, v) =&gt; {
  console.log('hello: ', v)
})
</code></pre>
<h4 id="在-koa-中引入">在 koa 中引入</h4>
<blockquote>
<p><a href="https://github.com/NodeRedis/node_redis">node-redis 文档</a></p>
</blockquote>
<pre><code class="language-js">const Koa = require('koa')
const session = require('koa-session')

const app = new Koa()
app.keys = ['SUOIJIHIJO#U$()_IKRJIW!Q']

// 使用 redis 存储 session
const redis = require('redis')
const redisClient = redis.createClient(6379, 'localhost')
// 包装为 Promise 
const wrapper = require('co-redis')
const client = wrapper(redisClient)

const redisStore = require('koa-redis')

const SESS_CONFIG = {
  key: 'test:sess',
  maxAge: 3600000, // ms
  httpOnly: true,
  signed: true,
  // 配置 store
  store: redisStore({ client }),
}

app.use(session(SESS_CONFIG, app))

// 读取 redis
app.use(async (ctx, next) =&gt; {
  const keys = await client.keys('*')
  console.log('---------------------')
  keys.forEach(async (key) =&gt; {
    console.log(await client.get(key))
  })
  await next()
})
</code></pre>
<h2 id="token">Token</h2>
<blockquote>
<ul>
<li>与 session 的区别</li>
</ul>
<p>服务器是无状态的。Token 通过密码学来解决用户认证，不需要在服务端保存状态，状态加密后保存在客户端的 token 中。服务端接收到 token 后，解密即可获得状态。</p>
<ul>
<li>过程</li>
</ul>
<ol>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，验证用户名与密码</li>
<li>验证成功后，服务端会签发一个令牌(Token)，再把这个 Token 发送给客户端</li>
<li>客户端收到 Token 以后可以把它存储起来，如放在 Cookie 里或者 Local Storage 里</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li>
<li>服务端收到请求后，验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li>
</ol>
</blockquote>
<h3 id="jwtjson-web-token-原理">JWT(JSON WEB TOKEN) 原理</h3>
<blockquote>
<p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7InVzZXJuYW1lIjoiYWRtaW4ifSwiZXhwIjoxNTkzMTczMjgwLCJpYXQiOjE1OTMxNjk2ODB9.MFAhKWPaQMdB3BjY_USoZxiB_1h72x9bjjoa0CfpkC8</p>
<ul>
<li>包含（解密后）：</li>
<li>令牌头：{&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;}</li>
<li>payload：{&quot;data&quot;:{&quot;username&quot;:&quot;admin&quot;},&quot;exp&quot;:1593173280,&quot;iat&quot;:1593169680}</li>
<li>哈希：MFAhKWPaQMdB3BjY_USoZxiB_1h72x9bjjoa0CfpkC8</li>
</ul>
</blockquote>
<p>Bearer Token 包含 <strong>令牌头</strong>、<strong>payload</strong>、<strong>哈希</strong></p>
<ul>
<li>签名：</li>
</ul>
<p>默认使用 base64（可逆）对<strong>令牌头</strong>和 <strong>payload</strong> 进行编码，使用 hs256 算法对<strong>令牌头</strong>、<strong>payload</strong>和<strong>密钥</strong>进行签名，生成哈希</p>
<ul>
<li>验证：</li>
</ul>
<p>默认使用 hs256 算法对令牌中数据再次进行签名，并将结果与令牌中<strong>哈希</strong>比对</p>
<pre><code class="language-js">const jwt = require('jsonwebtoken')

const secret = 'PiohOJHU)#@()UJIQ@F'

const token = jwt.sign(
  {
    data: { userid: '324fw23rfwea234' },
    exp: Math.floor(Date.now() / 1000) + 60 * 60,
  },
  secret,
)

console.log('token: ', token)
console.log('解码后: ', jwt.verify(token, secret))

// token:  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7InVzZXJpZCI6IjMyNGZ3MjNyZndlYTIzNCJ9LCJleHAiOjE1OTMxNzQ1NTcsImlhdCI6MTU5MzE3MDk1N30.ckdTTAhj88JE0N_Z8XouZd6YPneD4hJIGqVuR3c9LAU
// 解码后:  {
//   data: { userid: '324fw23rfwea234' },
//   exp: 1593174557,
//   iat: 1593170957
// }
</code></pre>
<h3 id="加密算法简介">加密算法简介</h3>
<h4 id="hmac-sha256">HMAC SHA256</h4>
<p>HMAC(Hash Message Authentication Code)，散列消息鉴别码，基于密钥的 Hash 算法的认证协议。消息鉴别码实现鉴别的原理理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即 MAC ，并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。</p>
<h4 id="base64">BASE64</h4>
<p>按照 RFC2045 的定义，Base64 内容传送编码被设计用来把任意序列的 8 位字节描述为一种不易被人直接识别的形式。（The Base64 Content-Transfer-Encoding is designed to represent arbitrary sequences of octets in a form that need not be humanly readable.） 常见于邮件、http加密，截取http信息，你就会发现登录操作的用户名、密码字段是通过BASE64编码的</p>
<h4 id="beare">Beare</h4>
<p>Beare作为一种认证类型(基于OAuth 2.0)，使用&quot;Bearer&quot;关键词进行定义</p>
<blockquote>
<p>参考文档：</p>
<p><a href="https://www.npmjs.com/package/jsonwebtoken">jsonwebtoken</a>、<a href="https://www.npmjs.com/package/koa-jwt">koa-jwt</a></p>
<p>阮一峰 JWT解释</p>
<p>http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</p>
</blockquote>
<h2 id="oauth2开放授权">OAuth2（开放授权）</h2>
<p>三方登入主要基于 OAuth 2.0 。OAuth 协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是 OAuth 的授权不会使第三方触及到用户的帐号信息 （如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权， 因此 OAuth 是安全的</p>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1593174881084.png" alt="OAuth" loading="lazy"></figure>
<h2 id="sso">SSO</h2>
<blockquote>
<p>图中每个服务端都有对应客户端。应用 B 转跳认证页时，进入认证服务器对应客户端的域，此时可访问到本地的用户令牌。将用户令牌发送至认证服务器，可验证用户是否已登录。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1593176304739.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://yuufen.com/blog/post-images/1593176308834.png" alt="" loading="lazy"></figure>
<h2 id="demo">DEMO</h2>
<h3 id="session-cookie-2">Session - Cookie</h3>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
      &lt;div&gt;
        &lt;input v-model=&quot;username&quot; /&gt;
        &lt;input v-model=&quot;password&quot; /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;button v-on:click=&quot;login&quot;&gt;Login&lt;/button&gt;
        &lt;button v-on:click=&quot;logout&quot;&gt;Logout&lt;/button&gt;
        &lt;button v-on:click=&quot;getUser&quot;&gt;GetUser&lt;/button&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;button onclick=&quot;document.getElementById('log').innerHTML = ''&quot;&gt;Clear Log&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;h6 id=&quot;log&quot;&gt;&lt;/h6&gt;
    &lt;script&gt;
      // axios.defaults.baseURL = 'http://localhost:3000'
      axios.defaults.withCredentials = true
      axios.interceptors.response.use((response) =&gt; {
        document.getElementById('log').append(JSON.stringify(response.data))
        return response
      })
      var app = new Vue({
        el: '#app',
        data: { username: 'test', password: 'test' },
        methods: {
          async login() {
            await axios.post('/users/login', {
              username: this.username,

              password: this.password,
            })
          },
          async logout() {
            await axios.post('/users/logout')
          },
          async getUser() {
            await axios.get('/users/getUser')
          },
        },
      })
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-js">const Koa = require('koa')
const router = require('koa-router')()
const session = require('koa-session')
const cors = require('koa2-cors')
const bodyParser = require('koa-bodyparser')
const static = require('koa-static')

const app = new Koa()
app.keys = ['F#ERF#!RQAWDQKLTJ#@QOP']

app.use(cors({ credentials: true }))
app.use(static(__dirname + '/'))
app.use(bodyParser())

app.use(session(app)) // 这里给 ctx 挂上了 session 属性

app.use((ctx, next) =&gt; {
  if (ctx.url.indexOf('login') &gt; -1) {
    next()
  } else {
    if (ctx.session.userinfo) {
      next()
    } else {
      ctx.body = { message: '未登录' }
    }
  }
})

router.post('/users/login', async (ctx) =&gt; {
  const { body } = ctx.request
  // 忽略了认证过程
  // 设置 session
  ctx.session.userinfo = body.username
  ctx.body = { message: '登录成功' }
})

router.post('/users/logout', async (ctx) =&gt; {
  // 设置 session
  delete ctx.session.userinfo
  ctx.body = { message: '登出成功' }
})

router.get('/users/getUser', async (ctx) =&gt; {
  ctx.body = {
    message:'获取数据成功',
    userinfo: ctx.session.userinfo
  }
})

app.use(router.routes())
app.use(router.allowedMethods())

app.listen(3000)
</code></pre>
<h3 id="token-2">Token</h3>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
      &lt;div&gt;&lt;input v-model=&quot;username&quot; /&gt; &lt;input v-model=&quot;password&quot; /&gt;&lt;/div&gt;
      &lt;div&gt;
        &lt;button v-on:click=&quot;login&quot;&gt;Login&lt;/button&gt; &lt;button v-on:click=&quot;logout&quot;&gt;Logout&lt;/button&gt;
        &lt;button v-on:click=&quot;getUser&quot;&gt;GetUser&lt;/button&gt;
      &lt;/div&gt;
      &lt;div&gt;&lt;button @click=&quot;logs=[]&quot;&gt;Clear Log&lt;/button&gt;&lt;/div&gt;
      &lt;!-- 日志 --&gt;
      &lt;ul&gt;
        &lt;li v-for=&quot;(log,idx) in logs&quot; :key=&quot;idx&quot;&gt;{{ log }}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;

    &lt;script&gt;
      axios.interceptors.request.use(
        (config) =&gt; {
          const token = window.localStorage.getItem('token')
          if (token) {
            // 判断是否存在token，如果存在的话，则每个http header都加上token
            // Bearer是JWT的认证头部信息
            config.headers.common['Authorization'] = 'Bearer ' + token
          }
          return config
        },
        (err) =&gt; {
          return Promise.reject(err)
        },
      )
      axios.interceptors.response.use(
        (response) =&gt; {
          app.logs.push(JSON.stringify(response.data))
          return response
        },
        (err) =&gt; {
          app.logs.push(JSON.stringify(response.data))
          return Promise.reject(err)
        },
      )
      var app = new Vue({
        el: '#app',
        data: { username: 'test', password: 'test', logs: [] },
        methods: {
          login: async function () {
            const res = await axios.post('/users/login-token', { username: this.username, password: this.password })
            localStorage.setItem('token', res.data.token)
          },
          logout: async function () {
            localStorage.removeItem('token')
          },
          getUser: async function () {
            await axios.get('/users/getUser-token')
          },
        },
      })
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-js">const Koa = require('koa')
const router = require('koa-router')()
const jwt = require('jsonwebtoken')
const jwtAuth = require('koa-jwt')
const secret = &quot;it's a secret&quot;
const cors = require('koa2-cors')
const bodyParser = require('koa-bodyparser')
const static = require('koa-static')

const app = new Koa()
app.keys = ['ROI#HRF)PQHAYR@!()U!Q']

app.use(static(__dirname + '/'))
app.use(bodyParser())

router.post('/users/login-token', async (ctx) =&gt; {
  const { body } = ctx.request //登录逻辑，略略
  // 一般 username 也不能暴露在 token 中
  const userinfo = body.username
  ctx.body = {
    message: '登录成功',
    user: userinfo,
    // 生成 token 返回给客户端
    token: jwt.sign(
      {
        data: userinfo,
        // 设置 token 过期时间，一小时后，秒为单位
        exp: Math.floor(Date.now() / 1000) + 60 * 60,
      },
      secret,
    ),
  }
})

router.get(
  '/users/getUser-token',
  // 鉴权中间件。验证 hash 以及是否过期
  // 会将 token 中 payload 挂载在 ctx.state.user 上
  jwtAuth({
    secret,
  }),
  async (ctx) =&gt; {
    // 验证通过，state.user
    console.log(ctx.state.user)
    ctx.body = {
      message: '获取数据成功',
      userinfo: ctx.state.user.data,
    }
  },
)

app.use(router.routes())
app.use(router.allowedMethods())

app.listen(3000)
</code></pre>
<h3 id="oauth2">OAuth2</h3>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;a href=&quot;/github/login&quot;&gt;login with github&lt;/a&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-js">const Koa = require('koa')
const router = require('koa-router')()
const static = require('koa-static')

const app = new Koa()
const axios = require('axios')
const querystring = require('querystring')

app.use(static(__dirname + '/'))

// GitHub App 信息
const config = {
  client_id: '73a4f730f2e8cf7d5fcf',
  client_secret: '74bde1aec977bd93ac4eb8f7ab63352dbe03ce48',
}

router.get('/github/login', async (ctx) =&gt; {
  const dataStr = new Date().valueOf()

  //重定向到认证接口,并配置参数
  let path = 'https://github.com/login/oauth/authorize'
  path += '?client_id=' + config.client_id

  //转发到授权服务器
  ctx.redirect(path)
})

// 回调，传入认证 code
router.get('/github/callback', async (ctx) =&gt; {
  console.log('callback..')

  const code = ctx.query.code

  const params = {
    client_id: config.client_id,
    client_secret: config.client_secret,
    code: code,
  }
  // 用 code 申请 token 令牌
  let res = await axios.post('https://github.com/login/oauth/access_token', params)
  const access_token = querystring.parse(res.data).access_token

  // 用 token 令牌请求用户信息
  res = await axios.get('https://api.github.com/user?access_token=' + access_token)
  console.log('userAccess:', res.data)
  ctx.body = `
    &lt;h1&gt;Hello ${res.data.login}&lt;/h1&gt;
    &lt;img src=&quot;${res.data.avatar_url}&quot; alt=&quot;&quot;/&gt;    
  `
})

app.use(router.routes())
app.use(router.allowedMethods())
app.listen(3000)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MongoDB 数据库设计中 6 条重要的经验法则]]></title>
        <id>https://yuufen.com/blog/post/fRNVUf6Jn/</id>
        <link href="https://yuufen.com/blog/post/fRNVUf6Jn/">
        </link>
        <updated>2020-06-25T09:49:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="part-1">Part 1</h2>
<p>原文：<a href="http://blog.mongodb.org/post/87200945828/6-rules-of-thumb-for-mongodb-schema-design-part-1">6 Rules of Thumb for MongoDB Schema Design: Part 1</a></p>
<p><em>By William Zola, Lead Technical Support Engineer at MongoDB</em></p>
<p>“我有丰富的sql使用经验，但是我是个MongoDB的初学者。我应该如何在MongoDB中针对一对多关系进行建模？”这是我被问及最多的问题之一。</p>
<p>我没法简单的给出答案，因为这有很多方案去实现。接下来我会教导你如何针对一对多进行建模。</p>
<p>这个话题有很多内容需要讨论，我会用三个部分进行说明。在第一部分，我会讨论针对一对多关系建模的三种基础方案。在第二部分我将会覆盖更多高级内容，包括反范式化和双向引用。在最后一部分，我将会回顾各种选择，并给出做决定时需要考虑的因素。</p>
<p>很多初学者认为在MongoDB中针对一对多建模唯一的方案就是在父文档中内嵌一个数组子文档，但是这是不准确的。因为你可以在MongoDB内嵌一个文档不代表你就必须这么做。</p>
<p>当你设计一个MongoDB数据库结构，你需要先问自己一个在使用关系型数据库时不会考虑的问题：这个关系中集合的大小是什么样的规模？你需要意识到一对很少，一对许多，一对非常多，这些细微的区别。不同的情况下你的建模也将不同。</p>
<p><em>Basics: Modeling One-to-Few</em></p>
<h3 id="一对很少">一对很少</h3>
<p>针对个人需要保存多个地址进行建模的场景下使用内嵌文档是很合适，可以在person文档中嵌入addresses数组文档：</p>
<figure data-type="image" tabindex="1"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229110634292-485259216.png" alt="img" loading="lazy"></figure>
<p>这种设计具有内嵌文档设计中所有的优缺点。最主要的优点就是不需要单独执行一条语句去获取内嵌的内容。最主要的缺点是你无法把这些内嵌文档当做单独的实体去访问。</p>
<p>例如，如果你是在对一个任务跟踪系统进行建模，每个用户将会被分配若干个任务。内嵌这些任务到用户文档在遇到“查询昨天所有的任务”这样的问题时将会非常困难。我会在下一篇文章针对这个用例提供一些适当的设计。</p>
<p><em>Basics: One-to-Many</em></p>
<h3 id="一对许多">一对许多</h3>
<p>以产品零件订货系统为例。每个商品有数百个可替换的零件，但是不会超过数千个。这个用例很适合使用间接引用---将零件的objectid作为数组存放在商品文档中(在这个例子中的ObjectID我使用更加易读的2字节，现实世界中他们可能是由12个字节组成的)。</p>
<p>每个零件都将有他们自己的文档对象</p>
<figure data-type="image" tabindex="2"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229110759823-711319082.png" alt="img" loading="lazy"></figure>
<p>每个产品的文档对象中parts数组中将会存放多个零件的ObjectID ：</p>
<figure data-type="image" tabindex="3"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229110817167-843655174.png" alt="img" loading="lazy"></figure>
<p>在获取特定产品中所有零件，需要一个应用层级别的join</p>
<p>为了能快速的执行查询，必须确保products.catalog_number有索引。当然由于零件中parts._id一定是有索引的，所以这也会很高效。</p>
<p>这种引用的方式是对内嵌优缺点的补充。每个零件是个单独的文档，可以很容易的独立去搜索和更新他们。需要一条单独的语句去获取零件的具体内容是使用这种建模方式需要考虑的一个问题（请仔细思考这个问题，在第二章反反范式化中，我们还会讨论这个问题）</p>
<p>这种建模方式中的零件部分可以被多个产品使用，所以在多对多时不需要一张单独的连接表。</p>
<p><em>Basics: One-to-Squillions</em></p>
<h3 id="一对非常多">一对非常多</h3>
<p>我们用一个收集各种机器日志的例子来讨论一对非常多的问题。由于每个mongodb的文档有16M的大小限制，所以即使你是存储ObjectID也是不够的。我们可以使用很经典的处理方法“父级引用”---用一个文档存储主机，在每个日志文档中保存这个主机的ObjectID。</p>
<figure data-type="image" tabindex="4"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111030651-395125605.png" alt="img" loading="lazy"></figure>
<p>以下是个和第二中方案稍微不同的应用级别的join用来查找一台主机最近5000条的日志信息</p>
<figure data-type="image" tabindex="5"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111059635-1509238621.png" alt="img" loading="lazy"></figure>
<p>所以，即使这种简单的讨论也有能察觉出mongobd的建模和关系模型建模的不同之处。你必须要注意一下两个因素：</p>
<p><em>Will the entities on the “N” side of the One-to-N ever need to stand alone?</em></p>
<p>一对多中的多是否需要一个单独的实体。</p>
<p><em>What is the cardinality of the relationship: is it one-to-few; one-to-many; or one-to-squillions?</em></p>
<p>这个关系中集合的规模是一对很少，很多，还是非常多。</p>
<p><em>Based on these factors, you can pick one of the three basic One-to-N schema designs:</em></p>
<p>基于以上因素来决定采取一下三种建模的方式</p>
<p><em><strong>一对很少且不需要单独访问内嵌内容的情况下可以使用内嵌多的一方。</strong></em></p>
<p><em><strong>一对多且多的一端内容因为各种理由需要单独存在的情况下可以通过数组的方式引用多的一方的。</strong></em></p>
<p><em><strong>一对非常多的情况下，请将一的那端引用嵌入进多的一端对象中。</strong></em></p>
<h2 id="part-2">Part 2</h2>
<p><strong>原文：<a href="http://blog.mongodb.org/post/87892923503/6-rules-of-thumb-for-mongodb-schema-design-part-2">6 Rules of Thumb for MongoDB Schema Design: Part 2</a></strong></p>
<p><em>By William Zola, Lead Technical Support Engineer at MongoDB</em></p>
<p>在上一篇文章中我介绍了三种基本的设计方案：内嵌，子引用，父引用，同时说明了在选择方案时需要考虑的两个关键因素。</p>
<p>一对多中的多是否需要一个单独的实体。</p>
<p>这个关系中集合的规模是一对很少，很多，还是非常多。</p>
<p>在掌握了以上基础技术后，我将会介绍更为高级的主题：<strong>双向关联</strong>和<strong>反范式化</strong>。</p>
<h3 id="双向关联">双向关联</h3>
<p>如果你想让你的设计更酷，你可以让引用的“one”端和“many”端同时保存对方的引用。</p>
<p>以上一篇文章讨论过的任务跟踪系统为例。有person和task两个集合，one-to-n的关系是从person端到task端。在需要获取person所有的task这个场景下需要在person这个对象中保存有task的id数组，如下面代码所示。</p>
<figure data-type="image" tabindex="6"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111342276-1359236117.png" alt="img" loading="lazy"></figure>
<p>在某些场景中这个应用需要显示任务的列表（例如显示一个多人协作项目中所有的任务），为了能够快速的获取某个用户负责的项目可以在task对象中嵌入附加的person引用关系。</p>
<figure data-type="image" tabindex="7"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111408260-7741794.png" alt="img" loading="lazy"></figure>
<p>这个方案具有所有的一对多方案的优缺点，但是通过添加附加的引用关系。在task文档对象中添加额外的“owner”引用可以很快的找到某个task的所有者，但是如果想将一个task分配给其他person就需要更新引用中的person和task这两个对象（熟悉关系数据库的童鞋会发现这样就没法保证操作的原子性。当然，这对任务跟踪系统来说并没有什么问题，但是你必须考虑你的用例是否能够容忍）</p>
<h3 id="在一对多关系中应用反范式">在一对多关系中应用反范式</h3>
<p>在你的设计中加入反范式，可以使你避免应用层级别的join读取，当然，代价是这也会让你在更新是需要操作更多数据。下面我会举个例子来进行说明</p>
<h4 id="反范式many-one">反范式Many -&lt; One</h4>
<p>以产品和零件为例，你可以在parts数组中冗余存储零件的名字。以下是没有加入反范式设计的结构。</p>
<figure data-type="image" tabindex="8"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111528198-444946874.png" alt="img" loading="lazy"></figure>
<p>反范式化意味着你不需要执行一个应用层级别的join去显示一个产品所有的零件名字，当然如果你同时还需要其他零件信息那这个应用层的join是避免不了的。</p>
<figure data-type="image" tabindex="9"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111545745-1028760979.png" alt="img" loading="lazy"></figure>
<p>在使得获取零件名字简单的同时，执行一个应用层级别的join会和之前的代码有些区别，具体如下：</p>
<figure data-type="image" tabindex="10"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111606089-1707374442.png" alt="img" loading="lazy"></figure>
<p>反范式化在节省你读的代价的同时会带来更新的代价：如果你将零件的名字冗余到产品的文档对象中，那么你想更改某个零件的名字你就必须同时更新所有包含这个零件的产品对象。</p>
<p>在一个读比写频率高的多的系统里，反范式是有使用的意义的。如果你很经常的需要高效的读取冗余的数据，但是几乎不去变更他d话，那么付出更新上的代价还是值得的。更新的频率越高，这种设计方案的带来的好处越少。</p>
<p>例如：假设零件的名字变化的频率很低，但是零件的库存变化很频繁，那么你可以冗余零件的名字到产品对象中，但是别冗余零件的库存。</p>
<p>需要注意的是，一旦你冗余了一个字段，那么对于这个字段的更新将不在是原子的。和上面双向引用的例子一样，如果你在零件对象中更新了零件的名字，那么更新产品对象中保存的名字字段前将会存在短时间的不一致。</p>
<h4 id="反范式one-many">反范式One -&lt; Many</h4>
<p>你也可以冗余one端的数据到many端：</p>
<figure data-type="image" tabindex="11"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111806776-268124956.png" alt="img" loading="lazy"></figure>
<p>如果你冗余产品的名字到零件表中，那么一旦更新产品的名字就必须更新所有和这个产品有关的零件，这比起只更新一个产品对象来说代价明显更大。这种情况下，更应该慎重的考虑读写频率。</p>
<h3 id="在一对很多的关系中应用反范式">在一对很多的关系中应用反范式</h3>
<p>在日志系统这个一对许多的例子中也可以应用反范式化的技术。你可以将one端（主机对象）冗余到日志对象中，或者反之。</p>
<p>下面的例子将主机中的IP地址冗余到日志对象中。</p>
<figure data-type="image" tabindex="12"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229112008651-1284597916.png" alt="img" loading="lazy"></figure>
<p>如果想获取最近某个ip地址的日志信息就变的很简单，只需要一条语句而不是之前的两条就能完成。</p>
<figure data-type="image" tabindex="13"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229112027260-1706832046.png" alt="img" loading="lazy"></figure>
<p>事实上，如果one端只有少量的信息存储，你甚至可以全部冗余存储到多端上，合并两个对象。</p>
<figure data-type="image" tabindex="14"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229112042307-1115685169.png" alt="img" loading="lazy"></figure>
<p>另一方面，也可以冗余数据到one端。比如说你想在主机文档中保存最近的1000条日志，可以使用mongodb 2.4中新加入的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">eache/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord">/</span></span></span></span>slice功能来保证list有序而且只保存1000条。</p>
<p>日志对象保存在logmsg集合中，同时冗余到hosts对象中。这样即使hosts对象中超过1000条的数据也不会导致日志对象丢失。</p>
<figure data-type="image" tabindex="15"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229112101370-2067503669.png" alt="img" loading="lazy"></figure>
<p>通过在查询中使用投影参数 （类似{_id:1}）的方式在不需要使用logmsgs数组的情况下避免获取整个mongodb对象，1000个日志信息带来的网络开销是很大的。</p>
<p>在一对多的情况下，需要慎重的考虑读和更新的频率。冗余日志信息到主机文档对象中只有在日志对象几乎不会发生更新的情况下才是个好的决定。</p>
<h3 id="总结">总结</h3>
<p>在这篇文章里，我介绍了对三种基础方案：内嵌文档，子引用，父引用的补充选择。</p>
<p>使用双向引用来优化你的数据库架构，前提是你能接受无法原子更新的代价。</p>
<p>可以在引用关系中冗余数据到one端或者N端。</p>
<p>在决定是否采用反范式化时需要考虑下面的因素：</p>
<p><strong>你将无法对冗余的数据进行原子更新。</strong></p>
<p><strong>只有读写比较高的情况下才应该采取反范式化的设计。</strong></p>
<h2 id="part-3">Part 3</h2>
<p>*原文：<a href="http://blog.mongodb.org/post/88473035333/6-rules-of-thumb-for-mongodb-schema-design-part-3">6 Rules of Thumb for MongoDB Schema Design: Part 3</a><br>
*</p>
<p><em>By William Zola, Lead Technical Support Engineer at MongoDB</em></p>
<p>这篇文章是系列的最后一篇。在第一篇文章里，我介绍了三种针对“一对多 ”关系建模的基础方案。在第二篇文章中，我介绍了对基础方案的扩展：双向关联和反范式化。</p>
<p>反范式可以让你避免一些应用层级别的join，但是这也会让更新变的更复杂，开销更大。不过冗余那些读取频率远远大于更新频率的字段还是值得的。</p>
<p>如果你还没有读过前两篇文章，欢迎一览。</p>
<p>让我们回顾下这些方案</p>
<p>你可以采取内嵌，或者建立one端或者N端的引用，也可以三者兼而有之。</p>
<p>你可以在one端或者N端冗余多个字段</p>
<p>下面这些是你需要谨记的：</p>
<p>1、优先考虑内嵌，除非有什么迫不得已的原因。</p>
<p>2、需要单独访问一个对象，那这个对象就不适合被内嵌到其他对象中。</p>
<p>3、数组不应该无限制增长。如果many端有数百个文档对象就不要去内嵌他们可以采用引用ObjectID的方案；如果有数千个文档对象，那么就不要内嵌ObjectID的数组。该采取哪些方案取决于数组的大小。</p>
<p>4、不要害怕应用层级别的join：如果索引建的正确并且通过投影条件（第二章提及）限制返回的结果，那么应用层级别的join并不会比关系数据库中join开销大多少。</p>
<p>5、在进行反范式设计时请先确认读写比。一个几乎不更改只是读取的字段才适合冗余到其他对象中。</p>
<p>6、在mongodb中如何对你的数据建模，取决于你的应用程序如何去访问它们。数据的结构要去适应你的程序的读写场景。</p>
<h3 id="设计指南">设计指南</h3>
<p>当你在MongoDB中对“一对多”关系进行建模，你有很多的方案可供选择，所以你必须很谨慎的去考虑数据的结构。下面这些问题是你必须认真思考的：</p>
<p>关系中集合的规模有多大：是一对很少，很多，还是非常多？</p>
<p>对于一对多中”多“的那一端，是否需要单独的访问它们，还是说它们只会在父对象的上下文中被访问。</p>
<p>被冗余的字段的读写的比例是多少？</p>
<h3 id="数据建模设计指南">数据建模设计指南</h3>
<p>在一对很少的情况下，你可以在父文档中内嵌数组。</p>
<p>在一对很多或者需要单独访问“N”端的数据时，你可以采用数组引用ObjectID的方式。如果可以加速你的访问也可以在“N”端使用父引用。</p>
<p>在一对非常多的情况下，可以在“N”端使用父引用。</p>
<p>如果你打算在你的设计中引入冗余等反范式设计，那么你必须确保那些冗余的数据读取的频率远远大于更新的频率。而且你也不需要很强的一致性。因为反范式化的设计会让你在更新冗余字段时付出一定的代价（更慢，非原子化）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node 数据持久化 - mongodb / ODM - mongoose]]></title>
        <id>https://yuufen.com/blog/post/WrIu1P8Tl/</id>
        <link href="https://yuufen.com/blog/post/WrIu1P8Tl/">
        </link>
        <updated>2020-06-24T15:09:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="mongodb-命令行操作"><a href="https://docs.mongodb.com/manual/reference/method/">mongodb 命令行操作</a></h2>
<pre><code class="language-js">// 查询所有数据库
show dbs
// 切换/创建数据库,当创建一个集合(table)的时候会自动创建当前数据库 
use test
// 插入一条数据 
db.fruits.save({name:'苹果',price:5})
// 条件查询 
db.fruits.find({price:5})
// 得到当前db的所有聚集集合 
db.getCollectionNames()
// 查询
db.fruits.find()
</code></pre>
<h2 id="mongodb-原生驱动"><a href="http://mongodb.github.io/node-mongodb-native/3.1/quick-start/quick-start/">mongodb 原生驱动</a></h2>
<h3 id="demo">Demo</h3>
<ul>
<li>数据库配置 model/conf.js</li>
</ul>
<pre><code class="language-js">module.exports = {
  url: 'mongodb://localhost:27017',
  dbName: 'test',
}
</code></pre>
<ul>
<li>封装数据库连接 model/db.js</li>
</ul>
<pre><code class="language-js">const conf = require('./conf')
const { MongoClient } = require('mongodb')
const { EventEmitter } = require('events')

class Mongo {
  constructor(conf) {
    this.conf = conf
    this.emitter = new EventEmitter()
    this.client = new MongoClient(conf.url, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    })
    // 连接 Server
    this.client.connect((err) =&gt; {
      if (err) throw err
      console.log('连接成功')
      this.emitter.emit('connect')
    })
  }

  // 创建/获取集合
  col(colName, dbName = this.conf.dbName) {
    return this.client.db(dbName).collection(colName)
  }

  // 创建 once 事件监听
  once(event, cb) {
    this.emitter.once(event, cb)
  }
}

// 创建并导出 Mongo 实例
module.exports = new Mongo(conf)
</code></pre>
<ul>
<li>添加测试数据 initData.js</li>
</ul>
<pre><code class="language-js">const mongo = require('./models/db')

mongo.once('connect', async () =&gt; {
  const col_fruits = mongo.col('fruits')
  await col_fruits.deleteMany() // 清空集合

  const data = new Array(100).fill().map((v, i) =&gt; {
    return {
      name: '水果' + i,
      price: i,
      category: Math.random() &gt; 0.5 ? '蔬菜' : '水果',
    }
  })

  await col_fruits.insertMany(data)
  console.log('初始化成功')
})
</code></pre>
<ul>
<li>接口编写 index.js</li>
</ul>
<pre><code class="language-js">const path = require('path')
const mongo = require('./models/db')
const express = require('express')

const app = express()

app.get('/', (req, res) =&gt; {
  res.sendFile(path.resolve('./index.html'))
})

app.get('/api/list', async (req, res) =&gt; {
  const col_fruits = mongo.col('fruits')
  
  // 查找条件
  const { page, category, keyword } = req.query
  const condition = {}
  if (category) {
    condition.category = category
  }
  if (keyword) {
    condition.name = { $regex: new RegExp(keyword) }
  }
  
  const total = await col_fruits.find(condition).count()
  const fruits = await col_fruits
  .find(condition)
  .skip((page - 1) * 6)
  .limit(6)
  .toArray()
  
  res.json({
    ok: 1,
    data: {
      fruits,
      pagination: { total, page },
    },
  })
})

app.get('/api/category', async (req, res) =&gt; {
  const col_fruits = mongo.col('fruits')
  const data = await col_fruits.distinct('category')
  res.json({ ok: 1, data })
})

app.listen(3000)
</code></pre>
<h3 id="操作符"><a href="https://docs.mongodb.com/manual/reference/operator/query/">操作符</a></h3>
<h4 id="查询操作符">查询操作符</h4>
<pre><code class="language-js">// 比较 $eq, $gt, $gte, $in 等
await col.find({ price: { $gt: 10 } }).toArray()

// 逻辑 $and, $not, $nor, $or
// price &gt; 10 或 price &lt; 5
await col.find({ $or: [{ price: { $gt: 10 } }, { price: { $lt: 5 } }] })
// price 不大于 10 且 price 不小于 5
await col.find({ $nor: [{ price: { $gt: 10 } }, { price: { $lt: 5 } }] })

// 元素 $exists, $type
await col.insertOne({ name: '芒果', price: 20.0, stack: true })
await col.find({ stack: { $exists: true } })

// 模拟 $regex, $text, $expr
await col.find({ name: { $regex: /芒/ } })
await col.createIndex({ name: 'text' }) // 验证文本搜索需首先对字段加索引
await col.find({ $text: { $search: '芒果' } }) // 按词搜索，单独字查询不出结果

// 数组 $all, $elemMatch, $size
col.insertOne({ name: '芒果', tags: ['热带', '甜'] }) // 插入带标签数据
// $all：查询指定字段包含所有指定内容的文档
await col.find({ tags: { $all: ['热带', '甜'] } })
// $elemMatch: 指定字段数组中⾄至少有一个元素满⾜足所有查询规则
col.insertOne({ hisPrice: [20, 25, 30] }) // 数据准备
col.find({ hisPrice: { $elemMatch: { $gt: 24, $lt: 26 } } }) // 历史价位 有没有出现在24~26之间

// 地理空间 $geoIntersects, $geoWithin, $near, $nearSphere
// 创建 stations 集合
const stations = db.collection('stations') // 添加测试数据，执行一次即可
await stations.insertMany([
  { name: '天安⻔门东', loc: [116.407851, 39.91408] },
  { name: '天安⻔门⻄西', loc: [116.398056, 39.913723] },
  { name: '王府井', loc: [116.417809, 39.91435] },
])
await stations.createIndex({ loc: '2dsphere' })
r = await stations
  .find({
    loc: {
      $nearSphere: {
        $geometry: {
          type: 'Point',
          coordinates: [116.403847, 39.915526],
        },
        $maxDistance: 1000,
      },
    },
  })
  .toArray()
console.log('天安门附近地铁站', r)
</code></pre>
<h4 id="更新操作符">更新操作符</h4>
<pre><code class="language-js">// 字段相关：$set,$unset,$setOnInsert,$rename,$inc,$min,$max,$mul
// 更新多个字段
await fruitsColl.updateOne({ name: '芒果' }, { $set: { price: 19.8, category: '热带⽔水果' } })
// 更新内嵌字段
{ $set: { area: { city: '三亚' } } }

/* ------------- */

// 数组相关：$,$[],$addToSet,$pull,$pop,$push,$pullAll
// $push用于新增
insertOne({ name: '芒果', tags: ['热带', '甜'] })
//添加tags数组字段
fruitsColl.updateMany({ name: '芒果' }, { $push: { tags: '上火' } })

// $pull,$pullAll用于删除符合条件项，$pop删除首项-1或尾项1
fruitsColl.updateMany({ name: '芒果' }, { $pop: { tags: 1 } })
// $，$[]用于修改
fruitsColl.updateMany({ name: '芒果', tags: '甜' }, { $set: { 'tags.$': '香甜' } })

// 修改器，常结合数组操作符使用：$each,$position,$slice,$sort
{ $push: { tags: { $each: [&quot;上火&quot;, &quot;真香&quot;], $slice: -3 } } }
</code></pre>
<h4 id="聚合操作符">聚合操作符</h4>
<p>使用 aggregate 方法，使文档顺序通过管道阶段从而得到最终结果</p>
<pre><code class="language-js">// 聚合管道阶段：$group,$count,$sort,$skip,$limit,$project等
// 分页查询
r = await fruitsColl
  .aggregate([
    {
      $sort: { price: -1 },
    },
    { $skip: 0 },
    { $limit: 2 },
  ])
  .toArray()

// 投射:只选择name,price并排除_id
fruitsColl
  .aggregate([
    {
      $project: { name: 1, price: 1, _id: 0 },
    },
  ])
  .toArray()

// 聚合管道操作符：$add,$avg,$sum等
// 按name字段分组，统计组内price总和
fruitsColl
  .aggregate([
    {
      $group: { _id: '$name', total: { $sum: '$price' } },
    },
  ])
  .toArray()
</code></pre>
<h2 id="odm-mongoose">ODM - mongoose</h2>
<h3 id="基本使用">基本使用</h3>
<h4 id="mongoose">mongoose</h4>
<pre><code class="language-js">const mongoose = require('mongoose')

// 1.连接
mongoose.connect('mongodb://localhost:27017/test', {
  useNewUrlParser: true,
})

const conn = mongoose.connection

conn.on('error', () =&gt; console.error('连接数据库失败'))
conn.once('open', async () =&gt; {
  // 2.定义一个Schema
  const Schema = mongoose.Schema({ category: String, name: String })

  // 3.编译一个Model
  const Model = mongoose.model('fruit', Schema)

  try {
    // 4.创建，create返回Promise
    let r = await Model.create({
      category: '温带水果',
      name: '苹果',
      price: 5,
    })
    console.log('插入数据:', r)
    
    // 通过实例创建
    const fruit = new Model({
      category: '温带水果',
      name: '苹果',
      price: 5,
    })
    const r = await fruit.save()
    console.log('新增fruit:', r)

    // 5.查询，find返回Query，它实现了then和catch，可以当Promise使用
    // 如果需要返回Promise，调用其exec()
    r = await Model.find({ name: '苹果' })
    console.log('查询结果:', r)

    // 6.更新，updateOne返回Query
    r = await Model.updateOne({ name: '苹果' }, { $set: { name: '芒果' } })
    console.log('更新结果：', r)

    // 7.删除，deleteOne返回Query
    r = await Model.deleteOne({ name: '苹果' })
    console.log('删除结果：', r)
  } catch (error) {
    console.log(error)
  }
})
</code></pre>
<h4 id="schema">Schema</h4>
<h5 id="字段定义">字段定义</h5>
<blockquote>
<p>字段类型：String / Number / Date / Buﬀer / Boolean / Mixed / ObjectId / Array</p>
<p>关联：categories: [{ type: mongoose.SchemaTypes.ObjectId, ref: 'Category' }]</p>
</blockquote>
<pre><code class="language-js">const blogSchema = mongoose.Schema({
  title: { type: String, required: [true, '标题为必填项'] }, // 定义校验规则
  author: String,
  body: String,
  comments: [{ body: String, date: Date }], // 定义对象数组
  date: { type: Date, default: Date.now }, // 指定默认值
  hidden: Boolean,
  meta: {
    // 定义对象
    votes: Number,
    favs: Number,
  },
})
// 定义多个索引
blogSchema.index({ title: 1, author: 1, date: -1 })
</code></pre>
<h5 id="定义实例方法">定义实例方法</h5>
<pre><code class="language-js">// 定义实例方法
blogSchema.methods.findByAuthor = function () {
  return this.model('blog').find({ author: this.author }).exec()
}
// 获得模型实例
const BlogModel = mongoose.model('blog', blogSchema)

const blog = new BlogModel({
  title: 'nodejs持久化',
  author: 'jerry',
  body: '....',
})
// 调用实例方法
r = await blog.findByAuthor()
console.log('findByAuthor', r)
</code></pre>
<h5 id="静态方法">静态方法</h5>
<pre><code class="language-js">blogSchema.statics.findByAuthor = function (author) {
  return this.model('blog').find({ author }).exec()
}
// ...
r = await BlogModel.findByAuthor('jerry')
console.log('findByAuthor', r)
</code></pre>
<h5 id="虚拟属性">虚拟属性</h5>
<pre><code class="language-js">blogSchema.virtual('commentsCount'/*, { options } */).get(function () {
  return this.comments.length
})

r = await BlogModel.findOne({ author: 'jerry' })
console.log('blog留言数：', r.commentsCount)
</code></pre>
<h2 id="一个自动化生成-restful-api-的框架">一个自动化生成 Restful API 的框架</h2>
<pre><code class="language-js">// index.js
const Koa = require('koa')
const app = new Koa()

// 连接数据库以及加载模型
const config = require('./conf')
const { loadModel } = require('./framework/loader')
loadModel(config)(app)

const router = require('./framework/router')
app.use(router)

const bodyParser = require('koa-bodyparser')
app.use(bodyParser())

const port = 3000
app.listen(port, () =&gt; {
  console.log(`App started at port ${port}`)
})
</code></pre>
<pre><code class="language-js">// config.js
module.exports = {
  db: {
    url: 'mongodb://localhost:27017/test',
    options: {
      useUnifiedTopology: true,
      useNewUrlParser: true,
    },
  },
}
</code></pre>
<pre><code class="language-js">// framework/loader.js
// 连接数据库，加载模型
const fs = require('fs')
const path = require('path')
const mongoose = require('mongoose')

function load(dir, cb) {
  const url = path.resolve(__dirname, dir)
  const files = fs.readdirSync(url)
  files.forEach((filename) =&gt; {
    filename = filename.replace('.js', '')
    const file = require(url + '/' + filename)
    cb(filename, file)
  })
}

const loadModel = (config) =&gt; (app) =&gt; {
  mongoose.connect(config.db.url, config.db.options)
  const conn = mongoose.connection
  conn.on('error', () =&gt; console.log('连接失败'))

  app.$model = {}
  load('../model', (filename, { schema }) =&gt; {
    console.log('Load model:' + filename)
    app.$model[filename] = mongoose.model(filename, schema)
  })
}

module.exports = {
  loadModel,
}
</code></pre>
<pre><code class="language-js">// framework/router.js
const router = require('koa-router')()

const { init, get, create, update, del } = require('./api')

router.get('/api/:list', init, get)
router.post('/api/:list', init, create)
router.put('/api/:list/:id', init, update)
router.delete('/api/:list/:id', init, del)

module.exports = router.routes()
</code></pre>
<pre><code class="language-js">// framework/api.js
module.exports = {
  async init(ctx, next) {
    const model = ctx.app.$model[ctx.params.list]
    if (model) {
      ctx.list = model
      await next()
    } else {
      ctx.body = `Can't find model ${ctx.params.list}`
    }
  },
  async get(ctx) {
    const res = await ctx.list.find({})
    ctx.body = res
  },
  async create(ctx) {
    const res = await ctx.list.create(ctx.request.body)
    ctx.body = res
  },
  async update(ctx) {
    const res = await ctx.list.updateOne({ _id: ctx.params.id }, ctx.request.body)
    ctx.body = res
  },
  async del(ctx) {
    const res = await ctx.list.deleteOne({ _id: ctx.params.id })
    ctx.body = res
  },
}
</code></pre>
<pre><code class="language-js">// model/user.js
const Mongoose = require('mongoose')

module.exports = {
  schema: new Mongoose.schema({
    mobile: { type: String, required: true },
    realName: { type: String, required: true },
  }),
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node 数据持久化 - mysql / mysql2 / ORM - Sequelize]]></title>
        <id>https://yuufen.com/blog/post/o2MKSF5LM/</id>
        <link href="https://yuufen.com/blog/post/o2MKSF5LM/">
        </link>
        <updated>2020-06-19T17:27:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>实体驱动设计</p>
</blockquote>
<h2 id="原生驱动">原生驱动</h2>
<h3 id="使用-mysql">使用 mysql</h3>
<pre><code class="language-js">const mysql = require('mysql')
// 连接配置
const cfg = {
  host: 'localhost',
  user: 'root',
  password: 'example',
  database: 'test',
}
// 创建连接对象
const conn = mysql.createConnection(cfg)

// 连接
conn.connect((err) =&gt; {
  if (err) {
    throw err
  } else {
    console.log('连接成功！')
  }
})

// 定义 SQL 语句
const CREATE_SQL = `CREATE TABLE IF NOT EXISTS demo(
                      id INT NOT NULL AUTO_INCREMENT,
                      message VARCHAR(45) NULL,
                      PRIMARY KEY(id)
                    )`
const INSERT_SQL = `INSERT INTO demo(message) VALUE(?)`
const SELECT_SQL = `SELECT * FROM demo`

conn.query(CREATE_SQL, (err) =&gt; {
  if (err) {
    throw err
  }
  // 插入数据
  conn.query(INSERT_SQL, (err, result) =&gt; {
    if (err) {
      throw err
    }
    console.log(result)
    // 查找数据
    conn.query(SELECT_SQL, (err, result) =&gt; {
      console.log(result)
      conn.end() // 如果 query 语句有嵌套，end 须在此执行
    })
  })
})
</code></pre>
<h3 id="使用-mysql2-与-es8语法">使用 mysql2 与 ES8语法</h3>
<pre><code class="language-js">(async () =&gt; {
  const mysql = require('mysql2/promise')
  const cfg = {
    host: 'localhost',
    user: 'root',
    password: 'example',
    database: 'test',
  }
  const conn = await mysql.createConnection(cfg)

  const CREATE_SQL = `CREATE TABLE IF NOT EXISTS demo(
                        id INT NOT NULL AUTO_INCREMENT,
                        message VARCHAR(45) NULL,
                        PRIMARY KEY(id)
                      )`
  const INSERT_SQL = `INSERT INTO demo(message) VALUE(?)`
  const SELECT_SQL = `SELECT * FROM demo`

  let ret = await conn.execute(CREATE_SQL)
  console.log('create: ', ret)
  
  ret = await conn.execute(INSERT_SQL, ['hello world'])
  console.log('insert: ', ret)

  const [rows, fields] = await conn.execute(SELECT_SQL)
  console.log('select: ', rows)
})()
</code></pre>
<h2 id="使用-ormobject-relation-mapping-sequelize">使用 ORM(Object Relation Mapping) - Sequelize</h2>
<h3 id="汇总-demo">汇总 Demo</h3>
<pre><code class="language-js">(async () =&gt; {
  const Sequelize = require('sequelie')

  // 建立连接
  const sequelie = new Sequelize('demo', 'root', 'example', {
    host: 'localhost',
    dialect: 'mysql',
    operatorsAliases: false,
  })

  const Fruit = sequelie.define(
    'Fruit',
    {
      name: {
        type: Sequelize.STRING(20),
        allowNull: false,
        get() {
          // 设置 Getter (在属性中)
          const fname = this.getDataValue('name')
          const price = this.getDataValue('price')
          const stock = this.getDataValue('stock')
          return `${fname}-价格${price}-库存${stock}kg`
        },
      },
      price: { type: Sequelize.FLOAT, allowNull: false },
      stock: { type: Sequelize.INTEGER, defaultValue: 0 },
      id: {
        type: Sequelize.DataTypes.UUID, // 使用 UUID，而非默认的 自增id
        type: Sequelize.DataTypes.UUIDV1, // 设置默认 UUID
        primaryKey: true, // 设为主键
      },
    },
    {
      timestamps: false, // 避免自动生成时间戳字段
      tableName: 'fruits', // 指定表名
      // underscored: true, // 蛇形命名，默认驼峰命名
      getterMethods: {
        // 设置 Getter (在 options 中)
        amount() {
          return this.getDataValue('stock') + 'kg'
        },
      },
      setterMethods: {
        // 设置 Setter (在 options 中)
        amount(val) {
          const idx = val.indexOf('kg')
          const v = val.slice(0, idx)
          this.setDataValue('stock', v)
        },
      },
    },
  )

  // 同步 Fruit 表，强制同步：force: true，会先删除表
  // let ret = await Fruit.sync({ force: true })
  let ret = await Fruit.sync()
  console.log('sync:', ret)

  ret = await Fruit.create({
    name: '香蕉',
    price: 3.5,
  })
  console.log('create:', ret)

  ret = await Fruit.findAll()
  console.log('findAll', JSON.stringify(ret))

  await Fruit.update(
    { price: 4 }, // 改动
    { where: { name: '香蕉' } }, // 查找条件
  )

  const Op = Sequelize.Op
  ret = await Fruit.findAll({ where: { price: { [Op.lte]: 4, [Op.gt]: 2 } } })
  console.log('findAll', JSON.stringify(ret, '', '\t'))

  // 触发 getters
  Fruit.findAll().then((fruits) =&gt; {
    console.log(JSON.stringify(fruits))
    // 修改amount，触发setterMethods
    fruits[0].amount = '150kg'
    fruits[0].save()
  })
})()
</code></pre>
<h3 id="模型配置选项">模型配置选项</h3>
<pre><code class="language-js">const Fruit = sequelize.define(&quot;Fruit&quot;, {...}, {
  timestamps: false, // 避免自动生成时间戳字段
  tableName: 'xxx', // 指定表名
  // underscored: true, // 蛇形命名，默认驼峰命名
})
</code></pre>
<h3 id="使用-uuid-主键">使用 UUID 主键</h3>
<pre><code class="language-js">id: { 
  type: Sequelize.DataTypes.UUID,
  type: Sequelize.DataTypes.UUIDV1, 
  primaryKey: true, 
}
</code></pre>
<h3 id="getters-setters">Getters &amp; Setters</h3>
<p>可用于定义伪属性或映射到数据库字段的保护属性</p>
<pre><code class="language-js">// 定义为属性的一部分
{
  name: {
    type: Sequelize.STRING(20),
    allowNull: false,
    get() {
      const fname = this.getDataValue('name')
      const price = this.getDataValue('price')
      const stock = this.getDataValue('stock')
      return `${fname}-价格${price}-库存${stock}kg`
    },
  },
  // ...
},
// 定义为模型选项
{
  // ...
  getterMethods: {
    amount() {
      return this.getDataValue('stock') + 'kg'
    },
  },
  setterMethods: {
    amount(val) {
      const idx = val.indexOf('kg')
      const v = val.slice(0, idx)
      this.setDataValue('stock', v)
    },
  },
},
// ...
    
// 触发 getters
Fruit.findAll().then((fruits) =&gt; {
  console.log(JSON.stringify(fruits))
  // 修改amount，触发setterMethods
  fruits[0].amount = '150kg'
  fruits[0].save()
})
</code></pre>
<h3 id="校验"><a href="https://sequelize.org/master/manual/models-definition.html#validations">校验</a></h3>
<p>验证模型字段格式、内容。校验会在 create 、 update 和 save 时自动运行</p>
<pre><code class="language-js">      price: {
        type: Sequelize.FLOAT,
        allowNull: false,
        // 校验
        validate: {
          isFloat: { msg: '价格字段必须输入数字' },
          min: { args: [0], msg: '价格字段的值必须大于0' },
        },
      },
</code></pre>
<h3 id="扩展模型方法">扩展模型方法</h3>
<pre><code class="language-js">// 添加类方法
Fruit.classify = function (name) {
  const tropicFruits = ['⾹香蕉', '芒果', '椰⼦子'] // 热带水果
  return tropicFruits.includes(name) ? '热带⽔水果' : '其他⽔水果'
}
// 添加实例方法
Fruit.prototype.totalPrice = function (count) {
  return (this.price * count).toFixed(2)
}

// 使用类方法
['⾹香蕉', '草莓'].forEach((f) =&gt; console.log(f + '是' + Fruit.classify(f)))
// 使用实例方法
Fruit.findAll().then((fruits) =&gt; {
  const [f1] = fruits
  console.log(`买5kg${f1.name}需要￥${f1.totalPrice(5)}`)
})
</code></pre>
<h3 id="查询记录">查询记录</h3>
<pre><code class="language-js">// 通过属性查询
Fruit.findOne({ where: { name: '⾹香蕉' } }).then((fruit) =&gt; {
  // fruit是首个匹配项，若没有则为null
  console.log(fruit.get())
})
// 指定查询字段
Fruit.findOne({ attributes: ['name'] }).then((fruit) =&gt; {
  // fruit是首个匹配项，若没有则为null
  console.log(fruit.get())
})
// 获取数据和总条数
Fruit.findAndCountAll().then((result) =&gt; {
  console.log(result.count)
  console.log(result.rows.length)
})
// 查询操作符
const Op = Sequelize.Op
Fruit.findAll({
  // where: { price: { [Op.lt]:4 }, stock: { [Op.gte]: 100 } }
  where: { price: { [Op.lt]: 4, [Op.gt]: 2 } },
}).then((fruits) =&gt; {
  console.log(fruits.length)
})
// 或语句
Fruit.findAll({
  // where: { [Op.or]:[{price: { [Op.lt]:4 }}, {stock: { [Op.gte]: 100 }}] }
  where: { price: { [Op.or]: [{ [Op.gt]: 3 }, { [Op.lt]: 2 }] } },
}).then((fruits) =&gt; {
  console.log(fruits[0].get())
})
// 分页
Fruit.findAll({ offset: 0, limit: 2 })
// 排序
Fruit.findAll({ order: [['price', 'DESC']] })
// 聚合
Fruit.max('price').then((max) =&gt; {
  console.log('max', max)
})
Fruit.sum('price').then((sum) =&gt; {
  console.log('sum', sum)
})
</code></pre>
<h3 id="更新记录">更新记录</h3>
<pre><code class="language-js">Fruit.findById(1).then((fruit) =&gt; {
  // 方式1 查找-修改-save
  fruit.price = 4
  fruit.save().then(() =&gt; console.log('update!!!!'))
})
// 方式2 按条件全部更新
Fruit.update({ price: 4 }, { where: { id: 1 } }).then((r) =&gt; {
  console.log(r)
  console.log('update!!!!')
})
</code></pre>
<h3 id="删除记录">删除记录</h3>
<pre><code class="language-js">// 方式1
Fruit.findOne({ where: { id: 1 } }).then((r) =&gt; r.destroy())
// 方式2
Fruit.destroy({ where: { id: 1 } }).then((r) =&gt; console.log(r))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node 数据持久化 - fs]]></title>
        <id>https://yuufen.com/blog/post/19YqgYL76/</id>
        <link href="https://yuufen.com/blog/post/19YqgYL76/">
        </link>
        <updated>2020-06-19T16:31:52.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">const fs = require('fs')

function get(key) {
  fs.readFile('./db.json', (err, data) =&gt; {
    const json = JSON.parse(data)
    console.log(json[key])
  })
}

function set(key, value) {
  fs.readFile('./db.json', (err, data) =&gt; {
    // 可能是空文件
    const json = data ? JSON.parse(data) : {}
    json[key] = value
    fs.writeFile('./db.json', JSON.stringify(json), (err) =&gt; {
      if (err) {
        console.log(err)
      } else {
        console.log('写入成功')
      }
    })
  })
}

/**
 * 命令行接口
 * set foo doo
 * get foo
 * quit
 */
const readline = require('readline')
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

rl.on('line', function (input) {
  const [op, key, value] = input.split(' ')
  if (op === 'get') {
    get(key)
  } else if (op === 'set') {
    set(key, value)
  } else if (op === 'quit') {
    rl.close()
  } else {
    console.log('无效指令')
  }
})

rl.on('close', function () {
  console.log('程序结束')
  process.exit(0)
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络基础]]></title>
        <id>https://yuufen.com/blog/post/ID3pXnTIC/</id>
        <link href="https://yuufen.com/blog/post/ID3pXnTIC/">
        </link>
        <updated>2020-04-07T18:23:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="网络模型">网络模型</h2>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1587925618947.png" alt="" loading="lazy"></figure>
<h2 id="tcp-协议">TCP 协议</h2>
<p><strong>实现一个即时通讯 IM</strong></p>
<p>原理：Net 模块提供一个异步 API，能够创建基于流的 TCP 服务器，客户端与服务器建立连接后，服务器可以获得一个全双工 Socket 对象，服务器可以保存 Socket 对象列表，在接受某客户端消息时，推送给其他客户端。</p>
<pre><code class="language-js">const net = require('net')
const chatServer = net.createServer()

const clientList = []
chatServer.on('connection', (client) =&gt; {
  client.write('Hi \n')
  clientList.push(client)
  client.on('data', (data) =&gt; {
    console.log('receive:', data.toString())
    clientList.forEach((v) =&gt; {
      v.write(data.toString)
    })
  })
})

chatServer.listen(9000)
</code></pre>
<p>通过 Telnet 连接服务器</p>
<pre><code>telnet localhost 9000
</code></pre>
<h2 id="http-协议">HTTP 协议</h2>
<h2 id="使用-http-服务">使用 HTTP 服务</h2>
<h2 id="前后端通信-ajax-websocket-等">前后端通信 - ajax, websocket 等</h2>
<h2 id="跨域">跨域</h2>
<h2 id="https">HTTPS</h2>
<h2 id="http2">HTTP2</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node 简介与基础 API]]></title>
        <id>https://yuufen.com/blog/post/jAmCPqVpt/</id>
        <link href="https://yuufen.com/blog/post/jAmCPqVpt/">
        </link>
        <updated>2020-04-03T19:35:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="nodejs-是什么">NodeJS 是什么</h2>
<h3 id="nodejs-是一个异步的事件驱动的-javascript-运行时">node.js 是一个异步的事件驱动的 JavaScript 运行时。</h3>
<blockquote>
<ul>
<li>JRE 是 java 运行时环境</li>
<li>C Runtime</li>
<li>.NET Common Language Runtime</li>
</ul>
<p>运行时 runtime 就是程序运行过程中，</p>
<p>指的是指令加载到内存并由 CPU 执行的时候。</p>
<p>运行时库就是程序运行过程中所需要依赖的库。</p>
<p>C 代码编译成可执行文件的时候，指令没有被 CPU 执行，这个时候算是<strong>编译时</strong>。</p>
</blockquote>
<h3 id="nodejs-特性其实就是-js-特性">node.js 特性其实就是 JS 特性：</h3>
<ul>
<li>非阻塞 I/O</li>
<li>事件驱动</li>
</ul>
<h3 id="node-历史-为性能而生">node 历史 — 为性能而生</h3>
<blockquote>
<p>Ryan Dahl(Google Brain)，他的工作是用 C/C++ 写高性能 Web 服务。对于高性能，异步 IO、事件驱动是基本原则，但是用 C/C++ 来写就太痛苦了。于是他开始设想用高级语言开发 Web 服务。他评估了很多种高级原因，还想很多语言虽然同时提供了同步 IO 和异步 IO，但是开发人员一旦用了同步 IO，他们就再也懒得写异步 IO，所以最终 Ryan 瞄向了 JavaScript。</p>
<p>因为 JavaScript 是单线程执行，根本不能进行同步 IO 操作，所以 JavaScript 的这一&quot;缺陷&quot;导致了它只能使用异步IO。</p>
<p>选定了开发语言，还要有运行时环境，V8 就是开源的 JavaScript 引擎。于是在2009，Ryan 正式推出了基于 JavaScript 语言和 V8 引擎的开源 Web 服务器项目，命名为 Node.js。Node 第一次把 JavaScript 带入到后端服务器开发。</p>
</blockquote>
<h3 id="并发处理的更替">并发处理的更替</h3>
<ul>
<li>
<p>多进程 - Linux C / Apache</p>
<blockquote>
<p>进程的缺陷：</p>
<ul>
<li>创建和切换的时间和空间开销较大，且随着并发进程数量的提升，时间和空间的开销会逐渐增大，从而限制了系统的并发能力。</li>
<li>进程间的资源共享不方便</li>
</ul>
</blockquote>
</li>
<li>
<p>多线程 - Java</p>
</li>
<li>
<p>异步 I/O - JavaScript</p>
</li>
<li>
<p>协程 - Lua / OpenResty / Go / deno (go + TS)</p>
</li>
</ul>
<blockquote>
<p>deno</p>
<p><a href="https://studygolang.com/articles/13101"> https://studygolang.com/articles/13101 </a></p>
</blockquote>
<h3 id="与前端中-js-异同">与前端中 JS 异同</h3>
<ul>
<li>核心语法不变</li>
<li>前端：BOM / DOM</li>
<li>后端：fs / http / buffer / event / os</li>
</ul>
<h2 id="使用">使用</h2>
<h3 id="运行">运行</h3>
<p>每次修改 js 文件需重新执行才能生效，安装 nodemon 可以监视文件改动，自动重启：</p>
<pre><code>npm i -g nodemon
</code></pre>
<h3 id="调试">调试</h3>
<p>Debug - Start Debugging</p>
<blockquote>
<p>https://nodejs.org/en/</p>
</blockquote>
<h3 id="使用模块">使用模块</h3>
<ul>
<li>
<p>node 内建模块</p>
<pre><code class="language-js">// 内建模块直接引用
const os = require('os')
const mem = os.freemem() / os.totalmem() * 100
console.log(`内存占用率${mem.toFixed(2)}%`)
</code></pre>
</li>
<li>
<p>第三方模块</p>
<blockquote>
<p><a href="https://www.npmjs.com/">https://www.npmjs.com/</a></p>
</blockquote>
<pre><code class="language-js">// 同级 CPU 占用率，先安装
npm i download-git-repo -S
</code></pre>
<pre><code class="language-js">// 导入并使用
const download = require('download-git-repo')
const ora = require('ora')

const process = ora('下载中...')
process.start()

download('github:yuuFen/vue-template-for-cli-demo', '../test', (err) =&gt; {
  // console.log(err ? 'Error' : 'Success')
  if (err) {
    process.fail()
  } else {
    process.succeed()
  }
})
</code></pre>
</li>
<li>
<p>promisefy</p>
<blockquote>
<p>让异步任务串行化（要符合规范）</p>
</blockquote>
<pre><code class="language-js">const repo = 'github:yuuFen/vue-template-for-cli-demo'
const desc = '../test'
clone(repo, desc)

async function clone(repo, desc) {
  const { pormisify } = require('util')
  const download = promisify(require('download-git-repo'))
  const ora = require('ora')
  const process = ora('下载中...')
  process.start()
  try {
    await download(repo, desc)
  } catch (err) {
    process.fail()
  }
  process.succeed()
}
</code></pre>
</li>
<li>
<p>自定义模块</p>
<pre><code class="language-js">// download.js
// 可以作为导出对象的属性导出
module.exports.clone = async function clone(repo, desc) {
  const { pormisify } = require('util')
  const download = promisify(require('download-git-repo'))
  const ora = require('ora')
  const process = ora('下载中...')
  process.start()
  try {
    await download(repo, desc)
  } catch (err) {
    process.fail()
  }
  process.succeed()
}

// run
const { clone } = require('./download')
const repo = 'github:yuuFen/vue-template-for-cli-demo'
const desc = '../test'

clone(repo, desc)
</code></pre>
</li>
</ul>
<h2 id="api">API</h2>
<h3 id="fs">fs</h3>
<pre><code class="language-js">const fs = require('fs')

// 同步调用
const data = fs.readFileSync('./download.js')
// data 类型为 Buffer
console.log(data.toString())

// 异步
fs.readFile('./download.js', (err, data) =&gt; {
    if (err) throw err
    console.log(data.toString())
})

// fs 常搭配 path api 使用
const path = require('path')
fs.readFile(path.resolve(path.resolve(__dirname, './download.js')), (err, data) =&gt; {
    if (err) throw err
    console.log(data.toString())
})

// prromisify
const { promisify } = require('util')
const readFile = promisify(fs.readFile)
readFile('./download.js').then(data =&gt; console.log(data))

// fs Promises API node v10
const fsp = require('fs').promises
fsp
    .readFile('./download.js')
    .then(data =&gt; console.log(data))
	.catch(err =&gt; console.log(err))
</code></pre>
<h3 id="buffer">Buffer</h3>
<blockquote>
<p>用于在 TCP 流、文件系统操作、以及其他上下文中与八位字节流进行交互。 八位字节组成的数组，可以有效的在 JS 中存储二进制数据。</p>
</blockquote>
<pre><code class="language-js">// 创建一个长度为 10 字节以 0 填充的Buffer
const buf1 = Buffer.alloc(10)
console.log(buf1)

// 创建一个 Buffer 包含 ascii
const buf2 = Buffer.from('a')
console.log(buf2, buf2.toString())

// 创建 Buffer 包含 UTF-8 字节
// UFT-8：一种变长的编码方案，使用 1 ~ 6 个字节来存储
// UFT-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储
// UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变
const buf3 = Buffer.from('Buffer 创建方法')
console.log(buf3)

// 写入Buffer数据
buf1.write('hello')
console.log(buf1)

// 读取Buffer数据  
console.log(buf3.toString())  

// 合并Buffer  
const buf4 = Buffer.concat([buf1, buf3])
console.log(buf4.toString());
</code></pre>
<h3 id="http">http</h3>
<blockquote>
<p>用于创建 web 服务的模块</p>
</blockquote>
<ul>
<li>创建一个http服务器</li>
</ul>
<pre><code class="language-js">const http = require('http')
const server = http.createServer((request, response) =&gt; {
    // 打印一下 response 的原型链
    console.log(getPrototypeChain(response))
    // response 是一个 Steam
    response.end('a response from server')
})

server.listen(3000)


function getPrototypeChain(obj) {
    let prototypeChain = []
    while (obj = Object.getPrototypeOf(obj)) {
        prototypeChain.push(obj)
    }
    prototypeChain.push(null)
    return prototypeChain
}
</code></pre>
<p>显示首页 / 实现接口</p>
<pre><code class="language-js">const http = require('http')
const fs = require('fs')

const server = http.createServer((request, response) =&gt; {
  const { url, method } = request

  if (url === '/' &amp;&amp; method === 'GET') {
    fs.readFile('./index.html', (err, data) =&gt; {
      if (err) {
        response.writeHead(500, { 'Content-Type': 'text/plain;charset=utf-8' })
        response.end('500 服务端错误')
      }
      response.statusCode = 200
      response.setHeader('Content-Type', 'text/html')
      response.end(data)
    })
  } else if (url === '/users' &amp;&amp; method === 'GET') {
    response.setHeader('Content-Type', 'application/json')
    response.end(JSON.stringify({ name: 'name' }))
  } else {
    response.statusCode = 404
    response.setHeader('Content-Type', 'text/plain;charset=utf-8')
    response.end('404 页面不存在')
  }
})

server.listen(3000)
</code></pre>
<h3 id="stream">stream</h3>
<blockquote>
<p>用于与 node 中流数据交互的接口</p>
</blockquote>
<pre><code class="language-js">const fs = require('fs')

const rs = fs.createReadStream('./img1.png')
const ws = fs.createWriteStream('./img2.png')
// 在内存中以字节流动，防止传输大文件时内存占用过高
rs.pipe(ws)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1587322423228.png" alt="" loading="lazy"></figure>
<p>响应图片请求</p>
<pre><code class="language-js">const http = require('http')
const fs = require('fs')

const server = http.createServer((request, response) =&gt; {
  const { url, method, headers } = request

  if (url === '/' &amp;&amp; method === 'GET') {
    fs.readFile('./index.html', (err, data) =&gt; {
      if (err) {
        response.writeHead(500, { 'Content-Type': 'text/plain;charset=utf-8' })
        response.end('500 服务端错误')
      }
      response.statusCode = 200
      response.setHeader('Content-Type', 'text/html')
      response.end(data)
    })
  } else if (method === 'GET' &amp;&amp; headers.accept.indexOf('image/*') !== -1) {
    console.log(url) // '/img.png'
	// response 是 Stream
    fs.createReadStream('.' + url).pipe(response)
  }
})

server.listen(3000)
</code></pre>
<h2 id="利用文件系统实现数据持久化">利用文件系统实现数据持久化</h2>
<pre><code class="language-js">const fs = require('fs')

function get(key) {
  fs.readFile('./db.json', (err, data) =&gt; {
    const json = JSON.parse(data)
    console.log(json[key])
  })
}

function set(key, value) {
  fs.readFile('./db.json', (err, data) =&gt; {
    // 可能是空文件
    const json = data ? JSON.parse(data) : {}
    json[key] = value
    fs.writeFile('./db.json', JSON.stringify(json), (err) =&gt; {
      if (err) {
        console.log(err)
      } else {
        console.log('写入成功')
      }
    })
  })
}

/**
 * 命令行接口
 * set foo doo
 * get foo
 * quit
 */
const readline = require('readline')
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

rl.on('line', function (input) {
  const [op, key, value] = input.split(' ')
  if (op === 'get') {
    get(key)
  } else if (op === 'set') {
    set(key, value)
  } else if (op === 'quit') {
    rl.close()
  } else {
    console.log('无效指令')
  }
})

rl.on('close', function () {
  console.log('程序结束')
  process.exit(0)
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[虚拟 DOM 简单实现]]></title>
        <id>https://yuufen.com/blog/post/M0Xa7RsWm/</id>
        <link href="https://yuufen.com/blog/post/M0Xa7RsWm/">
        </link>
        <updated>2020-04-01T03:24:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="项目地址">项目地址</h2>
<p>https://github.com/yuuFen/Virtual-DOM</p>
<h2 id="为什么需要虚拟-dom">为什么需要虚拟 DOM</h2>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1586510765752.png" alt="" loading="lazy"></figure>
<p>真实 DOM 非常复杂，拥有许多属性，所以 DOM 的操作开销巨大，需要尽可能的少操作 DOM。</p>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1586523343141.png" alt="" loading="lazy"></figure>
<p>使用自定义的一个对象来描述 DOM，可以有效减少复杂度。</p>
<h2 id="创建虚拟-dom">创建虚拟 DOM</h2>
<pre><code class="language-js">let vnode = createElement('div', { id: 'test' }, [
    createElement('p', {}, ['节点1'])
])
console.log(JSON.stringify(vnode, null, 2))
</code></pre>
<pre><code class="language-js">function createElement(tag, data, children) {
  let flag
  if (typeof tag == 'string') {
    // 普通的 html 标签
    flag = vnodeType.HTML
  } else if (typeof tag == 'function') {
    flag = vnodeType.COMPONENT
  } else {
    flag = vnodeType.TEXT
  }

  let childrenFlag
  if (children == null) {
    childrenFlag = childrenType.EMPTY
  } else if (Array.isArray(children)) {
    let length = children.length
    if (length === 0) {
      childrenFlag = childrenType.SINGLE
    } else {
      childrenFlag = childrenType.MULTIPLE
    }
  } else {
    // 其他情况认为是文本
    childrenFlag = childrenType.SINGLE
    children = createTextVNode(children + '')
  }

  // 返回 vnode
  return {
    flag, // vnode 类型
    tag, // 标签类型 / 文本没有 tag / 组件的 tag 是函数
    data,
    children,
    childrenFlag,
  }
}

function createTextVNode(text) {
  return {
    flag: vnodeType.TEXT,
    tag: null,
    data: null,
    children: text,
    childrenFlag: childrenType.EMPTY,
  }
}
</code></pre>
<h2 id="渲染">渲染</h2>
<pre><code class="language-js">      let vnode = createElement('div', { id: 'test' }, [
        createElement('p', { key: 'a',style: { color: 'blue' } }, ['节点1']),
        createElement('p', { key: 'b', '@click': () =&gt; { alert('xx') } }, ['节点2']),
        createElement('p', { key: 'c', 'class': 'item-header' }, ['节点3']),
        createElement('p', { key: 'd' }, ['节点4']),
      ])

      render(vnode, document.getElementById('app'))
</code></pre>
<pre><code class="language-js">// 要渲染的 vnode、容器（父元素）
function render(vnode, container) {
  // 首次渲染
  mount(vnode, container)
}

// 首次挂载元素
function mount(vnode, container) {
  let { flag } = vnode
  if (flag == vnodeType.HTML) {
    // (应该使用对象实现，不然依赖有点乱)
    mountElement(vnode, container)
  } else if (flag == vnodeType.TEXT) {
    mountText(vnode, container)
  }
}

function mountElement(vnode, container) {
  let dom = document.createElement(vnode.tag)
  vnode.el = dom
  let { data, children, childrenFlag } = vnode

  // 挂载 key
  if (data) {
    for (let key in data) {
      patchData(dom, key, null, data[key])
    }
  }

  if (childrenFlag !== childrenType.EMPTY) {
    if (childrenFlag == childrenType.SINGLE) {
      mount(children, dom)
    } else if (childrenFlag == childrenType.MULTIPLE) {
      for (let i = 0; i &lt; children.length; i++) {
        mount(children[i], dom)
      }
    }
  }

  container.appendChild(dom)
}

function mountText(vnode, container) {
  let dom = document.createTextNode(vnode.children)
  vnode.el = dom
  container.appendChild(dom)
}

function patchData(el, key, prv, next) {
  switch (key) {
    case 'style':
      for (let key in next) {
        el.style[key] = next[key]
      }
      break
    case 'class':
      el.className = next
      break
    default:
      if (key[0] === '@') {
        if (next) {
          el.addEventListener(key.slice[1], next)
        }
      } else {
        el.setAttribute(key, next)
      }
      break
  }
}
</code></pre>
<h2 id="补丁">补丁</h2>
<pre><code class="language-js">function patch(prev, next, container) {
  const nextFlag = next.flag
  const prevFlag = prev.flag

  // 如 element 变为 text, 直接替换, 不管 children
  if (nextFlag !== prevFlag) {
    replaceVNode(prev, next, container)
  } else if (nextFlag == vnodeType.HTML) {
    patchElement(prev, next, container)
  } else if (nextFlag == vnodeType.TEXT) {
    patchText(prev, next, container)
  }
}

function patchElement(prev, next, container) {
  if (prev.tag !== next.tag) {
    replaceVNode(prev, next, container)
    return
  }
  const el = (next.el = prev.el)

  // patch data
  const prevData = prev.data
  const nextData = next.data
  if (nextData) {
    for (const key in nextData) {
      const prevVal = prevData[key]
      const nextVal = nextData[key]
      patchData(el, key, prevVal, nextVal)
    }
  }
  if (prevData) {
    for (const key in prevData) {
      const prevVal = prevData[key]
      if (prevVal &amp;&amp; !nextData.hasOwnProperty(key)) {
        patchData(el, key, prevVal, null)
      }
    }
  }

  // patch children
  patchChildren(prev.childrenFlag, next.childrenFlag, prev.children, next.children, el)
}

function patchChildren(prevChildrenFlag, nextChildrenFlag, prevChildren, nextChildren, container) {
  // 1. 老的是 单独的 / 空的 / 多个
  // 2. 新的是 单独的 / 空的 / 多个
  switch (prevChildrenFlag) {
    case childrenType.SINGLE:
      switch (nextChildrenFlag) {
        case childrenType.SINGLE:
          patch(prevChildren, nextChildren, container)
          break
        case childrenType.EMPTY:
          container.removeChild(prevChildren.el)
          break
        case childrenType.MULTIPLE:
          container.removeChild(prevChildren.el)
          for (let i = 0; i &lt; nextChildren.length; i++) {
            mount(nextChildren[i], container)
          }
          break
      }
      break

    case childrenType.EMPTY:
      switch (nextChildrenFlag) {
        case childrenType.SINGLE:
          mount(nextChildren, container)
          break
        case childrenType.EMPTY:
          break
        case childrenType.MULTIPLE:
          for (let i = 0; i &lt; nextChildren.length; i++) {
            mount(nextChildren[i], container)
          }
          break
      }
      break

    case childrenType.MULTIPLE:
      switch (nextChildrenFlag) {
        case childrenType.SINGLE:
          for (let i = 0; i &lt; prevChildren.length; i++) {
            container.removeChild(prevChildren[i].el)
          }
          mount(nextChildren, container)
          break
        case childrenType.EMPTY:
          for (let i = 0; i &lt; prevChildren.length; i++) {
            container.removeChild(prevChildren[i].el)
          }
          break
        case childrenType.MULTIPLE:
          // 众多虚拟 DOM 就在这里产生分歧，每家的优化策略不一样
          // 老：[abc] 新：[c**a**b**]
          // ab 不需要更改，只需要在 ab 之间或之前插入元素，或在最后新建元素
          let lastIndex = 0
          for (let i = 0; i &lt; nextChildren.length; i++) {
            let find = false
            const nextVNode = nextChildren[i]
            for (let j = 0; j &lt; prevChildren.length; j++) {
              const prevVNode = prevChildren[j]
              if (prevVNode.key === nextVNode.key) {
                find = true
                // 如果 key 相同，认为是同一个元素，补丁一下，不新建或销毁
                patch(prevVNode, nextVNode, container)
                if (j &lt; lastIndex) {
                  // 需要移动的情况
                  // lastIndex 指的是上一个找到的元素在 prevVNode 中的位置
                  // j 就是最新找到的元素在 prevVNode 中的位置
                  // 使用 insertBefore 移动元素
                  const flagNode = nextChildren[i - 1].el.nextSibling
                  container.insertBefore(prevVNode.el, flagNode)
                } else {
                  // 如果顺序正确，就更新末尾位置
                  lastIndex = j
                }
              }
            }
            if (!find) {
              // 需要新增
              const flagNode = i == 0 ? prevChildren[0].el : nextChildren[i - 1].el.nextSibling
              mount(nextVNode, container, flagNode)
            }
          }

          // 移除不需要的元素
          for (let i = 0; i &lt; prevChildren.length; i++) {
            const prevVNode = prevChildren[i]
            const has = nextChildren.find((next) =&gt; next.key === prevVNode.key)
            if (!has) {
              container.removeChild(prevVNode.el)
            }
          }
          break
      }
      break
  }
}

function patchText(prev, next, container) {
  const el = (next.el = prev.el)
  if (next.children !== prev.children) {
    el.nodeValue = next.children
  }
}

function patchData(el, key, prev, next) {
  switch (key) {
    case 'style':
      for (let key in next) {
        el.style[key] = next[key]
      }
      for (let key in prev) {
        if (!next || !next.hasOwnProperty(key)) {
          el.style[key] = ''
        }
      }

      break
    case 'class':
      el.className = next
      break
    default:
      if (key[0] === '@') {
        if (prev) {
          el.removeEventListener(key.slice(1), prev)
        }
        if (next) {
          el.addEventListener(key.slice(1), next)
        }
      } else {
        el.setAttribute(key, next)
      }
      break
  }
}

function replaceVNode(prev, next, container) {
  container.removeChild(prev.el)
  mount(next, container)
}
</code></pre>
<h2 id="vue-中的优化">Vue 中的优化</h2>
<p>对常见的修改：新增、删除、倒序排列做了特定优化，详细见之前文章。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实现简单的 SSR]]></title>
        <id>https://yuufen.com/blog/post/s-05vytU3/</id>
        <link href="https://yuufen.com/blog/post/s-05vytU3/">
        </link>
        <updated>2020-03-25T02:49:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="渲染服务器">渲染服务器</h2>
<p>server/index.js</p>
<pre><code class="language-js">const express = require('express')
const Vue = require('vue')
const fs = require('fs')

// 创建 express 实例
const app = express()

const { createBundleRenderer } = require('vue-server-renderer')

const bundle = require('../dist/server/vue-ssr-server-bundle.json')
const clientManifest = require('../dist/server/vue-ssr-client-bundle.json')
const renderer = createBundleRenderer(bundle, {
  runInNewContext: false,
  template: fs.readFileSync('./src/index.temp.html'),
  clientManifest: clientManifest,
})

function renderToString(context) {
  return new Promise((resolve, reject) =&gt; {
    renderer.renderToString(context, (err, html) =&gt; {
      if (err) {
        reject(err)
        return
      }
      resolve(html)
    })
  })
}

// // 创建 vue 实例
// const vm = new Vue({
//   data: { cnt: 1 },
//   template: `
//     &lt;div&gt;{{cnt}}&lt;/div&gt;
//   `,
// })

// 客户端部署静态文件
app.use(express.static('../dist/client'))
// 声明服务端路由
app.get('*', async function (req, res) {
  try {
    const context = {
      title: 'ssr test',
      url: req.url,
    }
    const html = await renderToString(context)
    res.send(html)
  } catch (err) {
    res.status(500).send('Internal Server Error')
  }
})

app.listen(3000, () =&gt; {
  console.log('渲染服务器启动成功')
})
</code></pre>
<h2 id="打包入口文件">打包入口文件</h2>
<h3 id="appjs">app.js</h3>
<pre><code class="language-js">// 通用：创建 Vue 实例

import Vue from 'vue'
import App from './App.vue'
import { createRouter } from './router'
import { createStore } from './store'

export function createApp(context) {
  const router = createRouter()
  const store = createStore()
  const app = new Vue({
    router,
    store,
    render: (h) =&gt; h(App),
  })
  return { app, router }
}
</code></pre>
<h3 id="entry-clientjs">entry-client.js</h3>
<pre><code class="language-js">import { createApp } from './app'

const { app, router } = createApp()

router.onReady(() =&gt; {
  // 挂载
  app.$mount('#app')
})
</code></pre>
<h3 id="entry-serverjs">entry-server.js</h3>
<pre><code class="language-js">import { createApp } from './app'

export default (context) =&gt; {
  // 返回 Promise，确保路由或组件准备就绪
  return new Promise((resolve, reject) =&gt; {
    // 创建 vue 实例
    const { app, router } = createApp(context)
    // 跳转首屏地址
    router.push(context.url)
    // 完成 promise
    router.onReady(() =&gt; {
      resolve(app)
    }, reject)
  })
}
</code></pre>
]]></content>
    </entry>
</feed>