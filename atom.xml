<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yuufen.com/blog</id>
    <title>YuuFen</title>
    <updated>2020-06-25T09:53:26.386Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yuufen.com/blog"/>
    <link rel="self" href="https://yuufen.com/blog/atom.xml"/>
    <subtitle>希望你可以记住我</subtitle>
    <logo>https://yuufen.com/blog/images/avatar.png</logo>
    <icon>https://yuufen.com/blog/favicon.ico</icon>
    <rights>All rights reserved 2020, YuuFen</rights>
    <entry>
        <title type="html"><![CDATA[你好呀，陌生人]]></title>
        <id>https://yuufen.com/blog/post/about/</id>
        <link href="https://yuufen.com/blog/post/about/">
        </link>
        <updated>2024-02-28T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>因为笔记太多太杂，决定定期写写博客整理整理笔记。</p>
<p><s>然后因为各种原因失去了动力</s></p>
<p><s>因此搞丢了好多笔记啊啊啊啊啊啊啊😭😭😭</s></p>
<p><s>看了看一年前的博文发现自己真的变化了蛮多的（加油💪）</s></p>
<p>总之现在又开始了</p>
<h2 id="关于我">🐟 关于我</h2>
<p>我目前大二在读，我的职业规划是前端工程师，我的专业是电子信息，所以我还了解一些嵌入式开发（当然只是一些些），对Python和TensorFlow也有一定的涉猎。我正在努力寻找暑期实习！</p>
<p>在以下位置找到有关我的更多信息：</p>
<p><a href="https://yuufen.com/" target="_blank" class="text-button">主页</a><a href="https://yuufen.com/blog" target="_blank" class="text-button">博客</a><a href="https://github.com/yuuFen" target="_blank" class="text-button">项目</a><a href="mailto:me@yuufen.com" class="text-button">给我发邮件</a></p>
<h2 id="兴趣爱好">🎨 兴趣爱好</h2>
<p><strong>摄影</strong>、羽毛球、轮滑，and playing!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MongoDB数据库设计中6条重要的经验法则]]></title>
        <id>https://yuufen.com/blog/post/fRNVUf6Jn/</id>
        <link href="https://yuufen.com/blog/post/fRNVUf6Jn/">
        </link>
        <updated>2020-06-25T09:49:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="part-1">Part 1</h1>
<p>原文：<a href="http://blog.mongodb.org/post/87200945828/6-rules-of-thumb-for-mongodb-schema-design-part-1">6 Rules of Thumb for MongoDB Schema Design: Part 1</a></p>
<p><em>By William Zola, Lead Technical Support Engineer at MongoDB</em></p>
<p>“我有丰富的sql使用经验，但是我是个MongoDB的初学者。我应该如何在MongoDB中针对一对多关系进行建模？”这是我被问及最多的问题之一。</p>
<p>我没法简单的给出答案，因为这有很多方案去实现。接下来我会教导你如何针对一对多进行建模。</p>
<p>这个话题有很多内容需要讨论，我会用三个部分进行说明。在第一部分，我会讨论针对一对多关系建模的三种基础方案。在第二部分我将会覆盖更多高级内容，包括反范式化和双向引用。在最后一部分，我将会回顾各种选择，并给出做决定时需要考虑的因素。</p>
<p>很多初学者认为在MongoDB中针对一对多建模唯一的方案就是在父文档中内嵌一个数组子文档，但是这是不准确的。因为你可以在MongoDB内嵌一个文档不代表你就必须这么做。</p>
<p>当你设计一个MongoDB数据库结构，你需要先问自己一个在使用关系型数据库时不会考虑的问题：这个关系中集合的大小是什么样的规模？你需要意识到一对很少，一对许多，一对非常多，这些细微的区别。不同的情况下你的建模也将不同。</p>
<p><em>Basics: Modeling One-to-Few</em></p>
<h3 id="一对很少">一对很少</h3>
<p>针对个人需要保存多个地址进行建模的场景下使用内嵌文档是很合适，可以在person文档中嵌入addresses数组文档：</p>
<figure data-type="image" tabindex="1"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229110634292-485259216.png" alt="img" loading="lazy"></figure>
<p>这种设计具有内嵌文档设计中所有的优缺点。最主要的优点就是不需要单独执行一条语句去获取内嵌的内容。最主要的缺点是你无法把这些内嵌文档当做单独的实体去访问。</p>
<p>例如，如果你是在对一个任务跟踪系统进行建模，每个用户将会被分配若干个任务。内嵌这些任务到用户文档在遇到“查询昨天所有的任务”这样的问题时将会非常困难。我会在下一篇文章针对这个用例提供一些适当的设计。</p>
<p><em>Basics: One-to-Many</em></p>
<h3 id="一对许多">一对许多</h3>
<p>以产品零件订货系统为例。每个商品有数百个可替换的零件，但是不会超过数千个。这个用例很适合使用间接引用---将零件的objectid作为数组存放在商品文档中(在这个例子中的ObjectID我使用更加易读的2字节，现实世界中他们可能是由12个字节组成的)。</p>
<p>每个零件都将有他们自己的文档对象</p>
<figure data-type="image" tabindex="2"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229110759823-711319082.png" alt="img" loading="lazy"></figure>
<p>每个产品的文档对象中parts数组中将会存放多个零件的ObjectID ：</p>
<figure data-type="image" tabindex="3"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229110817167-843655174.png" alt="img" loading="lazy"></figure>
<p>在获取特定产品中所有零件，需要一个应用层级别的join</p>
<p>为了能快速的执行查询，必须确保products.catalog_number有索引。当然由于零件中parts._id一定是有索引的，所以这也会很高效。</p>
<p>这种引用的方式是对内嵌优缺点的补充。每个零件是个单独的文档，可以很容易的独立去搜索和更新他们。需要一条单独的语句去获取零件的具体内容是使用这种建模方式需要考虑的一个问题（请仔细思考这个问题，在第二章反反范式化中，我们还会讨论这个问题）</p>
<p>这种建模方式中的零件部分可以被多个产品使用，所以在多对多时不需要一张单独的连接表。</p>
<p><em>Basics: One-to-Squillions</em></p>
<h3 id="一对非常多">一对非常多</h3>
<p>我们用一个收集各种机器日志的例子来讨论一对非常多的问题。由于每个mongodb的文档有16M的大小限制，所以即使你是存储ObjectID也是不够的。我们可以使用很经典的处理方法“父级引用”---用一个文档存储主机，在每个日志文档中保存这个主机的ObjectID。</p>
<figure data-type="image" tabindex="4"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111030651-395125605.png" alt="img" loading="lazy"></figure>
<p>以下是个和第二中方案稍微不同的应用级别的join用来查找一台主机最近5000条的日志信息</p>
<figure data-type="image" tabindex="5"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111059635-1509238621.png" alt="img" loading="lazy"></figure>
<p>所以，即使这种简单的讨论也有能察觉出mongobd的建模和关系模型建模的不同之处。你必须要注意一下两个因素：</p>
<p><em>Will the entities on the “N” side of the One-to-N ever need to stand alone?</em></p>
<p>一对多中的多是否需要一个单独的实体。</p>
<p><em>What is the cardinality of the relationship: is it one-to-few; one-to-many; or one-to-squillions?</em></p>
<p>这个关系中集合的规模是一对很少，很多，还是非常多。</p>
<p><em>Based on these factors, you can pick one of the three basic One-to-N schema designs:</em></p>
<p>基于以上因素来决定采取一下三种建模的方式</p>
<p><em><strong>一对很少且不需要单独访问内嵌内容的情况下可以使用内嵌多的一方。</strong></em></p>
<p><em><strong>一对多且多的一端内容因为各种理由需要单独存在的情况下可以通过数组的方式引用多的一方的。</strong></em></p>
<p><em><strong>一对非常多的情况下，请将一的那端引用嵌入进多的一端对象中。</strong></em></p>
<h1 id="part-2">Part 2</h1>
<p><strong>原文：<a href="http://blog.mongodb.org/post/87892923503/6-rules-of-thumb-for-mongodb-schema-design-part-2">6 Rules of Thumb for MongoDB Schema Design: Part 2</a></strong></p>
<p><em>By William Zola, Lead Technical Support Engineer at MongoDB</em></p>
<p>在上一篇文章中我介绍了三种基本的设计方案：内嵌，子引用，父引用，同时说明了在选择方案时需要考虑的两个关键因素。</p>
<p>一对多中的多是否需要一个单独的实体。</p>
<p>这个关系中集合的规模是一对很少，很多，还是非常多。</p>
<p>在掌握了以上基础技术后，我将会介绍更为高级的主题：<strong>双向关联</strong>和<strong>反范式化</strong>。</p>
<h3 id="双向关联">双向关联</h3>
<p>如果你想让你的设计更酷，你可以让引用的“one”端和“many”端同时保存对方的引用。</p>
<p>以上一篇文章讨论过的任务跟踪系统为例。有person和task两个集合，one-to-n的关系是从person端到task端。在需要获取person所有的task这个场景下需要在person这个对象中保存有task的id数组，如下面代码所示。</p>
<figure data-type="image" tabindex="6"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111342276-1359236117.png" alt="img" loading="lazy"></figure>
<p>在某些场景中这个应用需要显示任务的列表（例如显示一个多人协作项目中所有的任务），为了能够快速的获取某个用户负责的项目可以在task对象中嵌入附加的person引用关系。</p>
<figure data-type="image" tabindex="7"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111408260-7741794.png" alt="img" loading="lazy"></figure>
<p>这个方案具有所有的一对多方案的优缺点，但是通过添加附加的引用关系。在task文档对象中添加额外的“owner”引用可以很快的找到某个task的所有者，但是如果想将一个task分配给其他person就需要更新引用中的person和task这两个对象（熟悉关系数据库的童鞋会发现这样就没法保证操作的原子性。当然，这对任务跟踪系统来说并没有什么问题，但是你必须考虑你的用例是否能够容忍）</p>
<h3 id="在一对多关系中应用反范式">在一对多关系中应用反范式</h3>
<p>在你的设计中加入反范式，可以使你避免应用层级别的join读取，当然，代价是这也会让你在更新是需要操作更多数据。下面我会举个例子来进行说明</p>
<h4 id="反范式many-one">反范式Many -&lt; One</h4>
<p>以产品和零件为例，你可以在parts数组中冗余存储零件的名字。以下是没有加入反范式设计的结构。</p>
<figure data-type="image" tabindex="8"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111528198-444946874.png" alt="img" loading="lazy"></figure>
<p>反范式化意味着你不需要执行一个应用层级别的join去显示一个产品所有的零件名字，当然如果你同时还需要其他零件信息那这个应用层的join是避免不了的。</p>
<figure data-type="image" tabindex="9"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111545745-1028760979.png" alt="img" loading="lazy"></figure>
<p>在使得获取零件名字简单的同时，执行一个应用层级别的join会和之前的代码有些区别，具体如下：</p>
<figure data-type="image" tabindex="10"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111606089-1707374442.png" alt="img" loading="lazy"></figure>
<p>反范式化在节省你读的代价的同时会带来更新的代价：如果你将零件的名字冗余到产品的文档对象中，那么你想更改某个零件的名字你就必须同时更新所有包含这个零件的产品对象。</p>
<p>在一个读比写频率高的多的系统里，反范式是有使用的意义的。如果你很经常的需要高效的读取冗余的数据，但是几乎不去变更他d话，那么付出更新上的代价还是值得的。更新的频率越高，这种设计方案的带来的好处越少。</p>
<p>例如：假设零件的名字变化的频率很低，但是零件的库存变化很频繁，那么你可以冗余零件的名字到产品对象中，但是别冗余零件的库存。</p>
<p>需要注意的是，一旦你冗余了一个字段，那么对于这个字段的更新将不在是原子的。和上面双向引用的例子一样，如果你在零件对象中更新了零件的名字，那么更新产品对象中保存的名字字段前将会存在短时间的不一致。</p>
<h4 id="反范式one-many">反范式One -&lt; Many</h4>
<p>你也可以冗余one端的数据到many端：</p>
<figure data-type="image" tabindex="11"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229111806776-268124956.png" alt="img" loading="lazy"></figure>
<p>如果你冗余产品的名字到零件表中，那么一旦更新产品的名字就必须更新所有和这个产品有关的零件，这比起只更新一个产品对象来说代价明显更大。这种情况下，更应该慎重的考虑读写频率。</p>
<h3 id="在一对很多的关系中应用反范式">在一对很多的关系中应用反范式</h3>
<p>在日志系统这个一对许多的例子中也可以应用反范式化的技术。你可以将one端（主机对象）冗余到日志对象中，或者反之。</p>
<p>下面的例子将主机中的IP地址冗余到日志对象中。</p>
<figure data-type="image" tabindex="12"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229112008651-1284597916.png" alt="img" loading="lazy"></figure>
<p>如果想获取最近某个ip地址的日志信息就变的很简单，只需要一条语句而不是之前的两条就能完成。</p>
<figure data-type="image" tabindex="13"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229112027260-1706832046.png" alt="img" loading="lazy"></figure>
<p>事实上，如果one端只有少量的信息存储，你甚至可以全部冗余存储到多端上，合并两个对象。</p>
<figure data-type="image" tabindex="14"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229112042307-1115685169.png" alt="img" loading="lazy"></figure>
<p>另一方面，也可以冗余数据到one端。比如说你想在主机文档中保存最近的1000条日志，可以使用mongodb 2.4中新加入的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">eache/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord">/</span></span></span></span>slice功能来保证list有序而且只保存1000条。</p>
<p>日志对象保存在logmsg集合中，同时冗余到hosts对象中。这样即使hosts对象中超过1000条的数据也不会导致日志对象丢失。</p>
<figure data-type="image" tabindex="15"><img src="https://images2015.cnblogs.com/blog/298288/201512/298288-20151229112101370-2067503669.png" alt="img" loading="lazy"></figure>
<p>通过在查询中使用投影参数 （类似{_id:1}）的方式在不需要使用logmsgs数组的情况下避免获取整个mongodb对象，1000个日志信息带来的网络开销是很大的。</p>
<p>在一对多的情况下，需要慎重的考虑读和更新的频率。冗余日志信息到主机文档对象中只有在日志对象几乎不会发生更新的情况下才是个好的决定。</p>
<h3 id="总结">总结</h3>
<p>在这篇文章里，我介绍了对三种基础方案：内嵌文档，子引用，父引用的补充选择。</p>
<p>使用双向引用来优化你的数据库架构，前提是你能接受无法原子更新的代价。</p>
<p>可以在引用关系中冗余数据到one端或者N端。</p>
<p>在决定是否采用反范式化时需要考虑下面的因素：</p>
<p><strong>你将无法对冗余的数据进行原子更新。</strong></p>
<p><strong>只有读写比较高的情况下才应该采取反范式化的设计。</strong></p>
<h1 id="part-3">Part 3</h1>
<p>*原文：<a href="http://blog.mongodb.org/post/88473035333/6-rules-of-thumb-for-mongodb-schema-design-part-3">6 Rules of Thumb for MongoDB Schema Design: Part 3</a><br>
*</p>
<p><em>By William Zola, Lead Technical Support Engineer at MongoDB</em></p>
<p>这篇文章是系列的最后一篇。在第一篇文章里，我介绍了三种针对“一对多 ”关系建模的基础方案。在第二篇文章中，我介绍了对基础方案的扩展：双向关联和反范式化。</p>
<p>反范式可以让你避免一些应用层级别的join，但是这也会让更新变的更复杂，开销更大。不过冗余那些读取频率远远大于更新频率的字段还是值得的。</p>
<p>如果你还没有读过前两篇文章，欢迎一览。</p>
<p>让我们回顾下这些方案</p>
<p>你可以采取内嵌，或者建立one端或者N端的引用，也可以三者兼而有之。</p>
<p>你可以在one端或者N端冗余多个字段</p>
<p>下面这些是你需要谨记的：</p>
<p>1、优先考虑内嵌，除非有什么迫不得已的原因。</p>
<p>2、需要单独访问一个对象，那这个对象就不适合被内嵌到其他对象中。</p>
<p>3、数组不应该无限制增长。如果many端有数百个文档对象就不要去内嵌他们可以采用引用ObjectID的方案；如果有数千个文档对象，那么就不要内嵌ObjectID的数组。该采取哪些方案取决于数组的大小。</p>
<p>4、不要害怕应用层级别的join：如果索引建的正确并且通过投影条件（第二章提及）限制返回的结果，那么应用层级别的join并不会比关系数据库中join开销大多少。</p>
<p>5、在进行反范式设计时请先确认读写比。一个几乎不更改只是读取的字段才适合冗余到其他对象中。</p>
<p>6、在mongodb中如何对你的数据建模，取决于你的应用程序如何去访问它们。数据的结构要去适应你的程序的读写场景。</p>
<h3 id="设计指南">设计指南</h3>
<p>当你在MongoDB中对“一对多”关系进行建模，你有很多的方案可供选择，所以你必须很谨慎的去考虑数据的结构。下面这些问题是你必须认真思考的：</p>
<p>关系中集合的规模有多大：是一对很少，很多，还是非常多？</p>
<p>对于一对多中”多“的那一端，是否需要单独的访问它们，还是说它们只会在父对象的上下文中被访问。</p>
<p>被冗余的字段的读写的比例是多少？</p>
<h3 id="数据建模设计指南">数据建模设计指南</h3>
<p>在一对很少的情况下，你可以在父文档中内嵌数组。</p>
<p>在一对很多或者需要单独访问“N”端的数据时，你可以采用数组引用ObjectID的方式。如果可以加速你的访问也可以在“N”端使用父引用。</p>
<p>在一对非常多的情况下，可以在“N”端使用父引用。</p>
<p>如果你打算在你的设计中引入冗余等反范式设计，那么你必须确保那些冗余的数据读取的频率远远大于更新的频率。而且你也不需要很强的一致性。因为反范式化的设计会让你在更新冗余字段时付出一定的代价（更慢，非原子化）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node 数据持久化 - mongodb / ODM - mongoose]]></title>
        <id>https://yuufen.com/blog/post/WrIu1P8Tl/</id>
        <link href="https://yuufen.com/blog/post/WrIu1P8Tl/">
        </link>
        <updated>2020-06-24T15:09:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="mongodb-命令行操作"><a href="https://docs.mongodb.com/manual/reference/method/">mongodb 命令行操作</a></h2>
<pre><code class="language-js">// 查询所有数据库
show dbs
// 切换/创建数据库,当创建一个集合(table)的时候会自动创建当前数据库 
use test
// 插入一条数据 
db.fruits.save({name:'苹果',price:5})
// 条件查询 
db.fruits.find({price:5})
// 得到当前db的所有聚集集合 
db.getCollectionNames()
// 查询
db.fruits.find()
</code></pre>
<h2 id="mongodb-原生驱动"><a href="http://mongodb.github.io/node-mongodb-native/3.1/quick-start/quick-start/">mongodb 原生驱动</a></h2>
<h3 id="demo">Demo</h3>
<ul>
<li>数据库配置 model/conf.js</li>
</ul>
<pre><code class="language-js">module.exports = {
  url: 'mongodb://localhost:27017',
  dbName: 'test',
}
</code></pre>
<ul>
<li>封装数据库连接 model/db.js</li>
</ul>
<pre><code class="language-js">const conf = require('./conf')
const { MongoClient } = require('mongodb')
const { EventEmitter } = require('events')

class Mongo {
  constructor(conf) {
    this.conf = conf
    this.emitter = new EventEmitter()
    this.client = new MongoClient(conf.url, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    })
    // 连接 Server
    this.client.connect((err) =&gt; {
      if (err) throw err
      console.log('连接成功')
      this.emitter.emit('connect')
    })
  }

  // 创建/获取集合
  col(colName, dbName = this.conf.dbName) {
    return this.client.db(dbName).collection(colName)
  }

  // 创建 once 事件监听
  once(event, cb) {
    this.emitter.once(event, cb)
  }
}

// 创建并导出 Mongo 实例
module.exports = new Mongo(conf)
</code></pre>
<ul>
<li>添加测试数据 initData.js</li>
</ul>
<pre><code class="language-js">const mongo = require('./models/db')

mongo.once('connect', async () =&gt; {
  const col_fruits = mongo.col('fruits')
  await col_fruits.deleteMany() // 清空集合

  const data = new Array(100).fill().map((v, i) =&gt; {
    return {
      name: '水果' + i,
      price: i,
      category: Math.random() &gt; 0.5 ? '蔬菜' : '水果',
    }
  })

  await col_fruits.insertMany(data)
  console.log('初始化成功')
})
</code></pre>
<ul>
<li>接口编写 index.js</li>
</ul>
<pre><code class="language-js">const path = require('path')
const mongo = require('./models/db')
const express = require('express')

const app = express()

app.get('/', (req, res) =&gt; {
  res.sendFile(path.resolve('./index.html'))
})

app.get('/api/list', async (req, res) =&gt; {
  const col_fruits = mongo.col('fruits')
  
  // 查找条件
  const { page, category, keyword } = req.query
  const condition = {}
  if (category) {
    condition.category = category
  }
  if (keyword) {
    condition.name = { $regex: new RegExp(keyword) }
  }
  
  const total = await col_fruits.find(condition).count()
  const fruits = await col_fruits
  .find(condition)
  .skip((page - 1) * 6)
  .limit(6)
  .toArray()
  
  res.json({
    ok: 1,
    data: {
      fruits,
      pagination: { total, page },
    },
  })
})

app.get('/api/category', async (req, res) =&gt; {
  const col_fruits = mongo.col('fruits')
  const data = await col_fruits.distinct('category')
  res.json({ ok: 1, data })
})

app.listen(3000)
</code></pre>
<h3 id="操作符"><a href="https://docs.mongodb.com/manual/reference/operator/query/">操作符</a></h3>
<h4 id="查询操作符">查询操作符</h4>
<pre><code class="language-js">// 比较 $eq, $gt, $gte, $in 等
await col.find({ price: { $gt: 10 } }).toArray()

// 逻辑 $and, $not, $nor, $or
// price &gt; 10 或 price &lt; 5
await col.find({ $or: [{ price: { $gt: 10 } }, { price: { $lt: 5 } }] })
// price 不大于 10 且 price 不小于 5
await col.find({ $nor: [{ price: { $gt: 10 } }, { price: { $lt: 5 } }] })

// 元素 $exists, $type
await col.insertOne({ name: '芒果', price: 20.0, stack: true })
await col.find({ stack: { $exists: true } })

// 模拟 $regex, $text, $expr
await col.find({ name: { $regex: /芒/ } })
await col.createIndex({ name: 'text' }) // 验证文本搜索需首先对字段加索引
await col.find({ $text: { $search: '芒果' } }) // 按词搜索，单独字查询不出结果

// 数组 $all, $elemMatch, $size
col.insertOne({ name: '芒果', tags: ['热带', '甜'] }) // 插入带标签数据
// $all：查询指定字段包含所有指定内容的文档
await col.find({ tags: { $all: ['热带', '甜'] } })
// $elemMatch: 指定字段数组中⾄至少有一个元素满⾜足所有查询规则
col.insertOne({ hisPrice: [20, 25, 30] }) // 数据准备
col.find({ hisPrice: { $elemMatch: { $gt: 24, $lt: 26 } } }) // 历史价位 有没有出现在24~26之间

// 地理空间 $geoIntersects, $geoWithin, $near, $nearSphere
// 创建 stations 集合
const stations = db.collection('stations') // 添加测试数据，执行一次即可
await stations.insertMany([
  { name: '天安⻔门东', loc: [116.407851, 39.91408] },
  { name: '天安⻔门⻄西', loc: [116.398056, 39.913723] },
  { name: '王府井', loc: [116.417809, 39.91435] },
])
await stations.createIndex({ loc: '2dsphere' })
r = await stations
  .find({
    loc: {
      $nearSphere: {
        $geometry: {
          type: 'Point',
          coordinates: [116.403847, 39.915526],
        },
        $maxDistance: 1000,
      },
    },
  })
  .toArray()
console.log('天安门附近地铁站', r)
</code></pre>
<h4 id="更新操作符">更新操作符</h4>
<pre><code class="language-js">// 字段相关：$set,$unset,$setOnInsert,$rename,$inc,$min,$max,$mul
// 更新多个字段
await fruitsColl.updateOne({ name: '芒果' }, { $set: { price: 19.8, category: '热带⽔水果' } })
// 更新内嵌字段
{ $set: { area: { city: '三亚' } } }

/* ------------- */

// 数组相关：$,$[],$addToSet,$pull,$pop,$push,$pullAll
// $push用于新增
insertOne({ name: '芒果', tags: ['热带', '甜'] })
//添加tags数组字段
fruitsColl.updateMany({ name: '芒果' }, { $push: { tags: '上火' } })

// $pull,$pullAll用于删除符合条件项，$pop删除首项-1或尾项1
fruitsColl.updateMany({ name: '芒果' }, { $pop: { tags: 1 } })
// $，$[]用于修改
fruitsColl.updateMany({ name: '芒果', tags: '甜' }, { $set: { 'tags.$': '香甜' } })

// 修改器，常结合数组操作符使用：$each,$position,$slice,$sort
{ $push: { tags: { $each: [&quot;上火&quot;, &quot;真香&quot;], $slice: -3 } } }
</code></pre>
<h4 id="聚合操作符">聚合操作符</h4>
<p>使用 aggregate 方法，使文档顺序通过管道阶段从而得到最终结果</p>
<pre><code class="language-js">// 聚合管道阶段：$group,$count,$sort,$skip,$limit,$project等
// 分页查询
r = await fruitsColl
  .aggregate([
    {
      $sort: { price: -1 },
    },
    { $skip: 0 },
    { $limit: 2 },
  ])
  .toArray()

// 投射:只选择name,price并排除_id
fruitsColl
  .aggregate([
    {
      $project: { name: 1, price: 1, _id: 0 },
    },
  ])
  .toArray()

// 聚合管道操作符：$add,$avg,$sum等
// 按name字段分组，统计组内price总和
fruitsColl
  .aggregate([
    {
      $group: { _id: '$name', total: { $sum: '$price' } },
    },
  ])
  .toArray()
</code></pre>
<h2 id="odm-mongoose">ODM - mongoose</h2>
<h3 id="基本使用">基本使用</h3>
<h4 id="mongoose">mongoose</h4>
<pre><code class="language-js">const mongoose = require('mongoose')

// 1.连接
mongoose.connect('mongodb://localhost:27017/test', {
  useNewUrlParser: true,
})

const conn = mongoose.connection

conn.on('error', () =&gt; console.error('连接数据库失败'))
conn.once('open', async () =&gt; {
  // 2.定义一个Schema
  const Schema = mongoose.Schema({ category: String, name: String })

  // 3.编译一个Model
  const Model = mongoose.model('fruit', Schema)

  try {
    // 4.创建，create返回Promise
    let r = await Model.create({
      category: '温带水果',
      name: '苹果',
      price: 5,
    })
    console.log('插入数据:', r)
    
    // 通过实例创建
    const fruit = new Model({
      category: '温带水果',
      name: '苹果',
      price: 5,
    })
    const r = await fruit.save()
    console.log('新增fruit:', r)

    // 5.查询，find返回Query，它实现了then和catch，可以当Promise使用
    // 如果需要返回Promise，调用其exec()
    r = await Model.find({ name: '苹果' })
    console.log('查询结果:', r)

    // 6.更新，updateOne返回Query
    r = await Model.updateOne({ name: '苹果' }, { $set: { name: '芒果' } })
    console.log('更新结果：', r)

    // 7.删除，deleteOne返回Query
    r = await Model.deleteOne({ name: '苹果' })
    console.log('删除结果：', r)
  } catch (error) {
    console.log(error)
  }
})
</code></pre>
<h4 id="schema">Schema</h4>
<h5 id="字段定义">字段定义</h5>
<blockquote>
<p>字段类型：String / Number / Date / Buﬀer / Boolean / Mixed / ObjectId / Array</p>
<p>关联：categories: [{ type: mongoose.SchemaTypes.ObjectId, ref: 'Category' }]</p>
</blockquote>
<pre><code class="language-js">const blogSchema = mongoose.Schema({
  title: { type: String, required: [true, '标题为必填项'] }, // 定义校验规则
  author: String,
  body: String,
  comments: [{ body: String, date: Date }], // 定义对象数组
  date: { type: Date, default: Date.now }, // 指定默认值
  hidden: Boolean,
  meta: {
    // 定义对象
    votes: Number,
    favs: Number,
  },
})
// 定义多个索引
blogSchema.index({ title: 1, author: 1, date: -1 })
</code></pre>
<h5 id="定义实例方法">定义实例方法</h5>
<pre><code class="language-js">// 定义实例方法
blogSchema.methods.findByAuthor = function () {
  return this.model('blog').find({ author: this.author }).exec()
}
// 获得模型实例
const BlogModel = mongoose.model('blog', blogSchema)

const blog = new BlogModel({
  title: 'nodejs持久化',
  author: 'jerry',
  body: '....',
})
// 调用实例方法
r = await blog.findByAuthor()
console.log('findByAuthor', r)
</code></pre>
<h5 id="静态方法">静态方法</h5>
<pre><code class="language-js">blogSchema.statics.findByAuthor = function (author) {
  return this.model('blog').find({ author }).exec()
}
// ...
r = await BlogModel.findByAuthor('jerry')
console.log('findByAuthor', r)
</code></pre>
<h5 id="虚拟属性">虚拟属性</h5>
<pre><code class="language-js">blogSchema.virtual('commentsCount'/*, { options } */).get(function () {
  return this.comments.length
})

r = await BlogModel.findOne({ author: 'jerry' })
console.log('blog留言数：', r.commentsCount)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node 数据持久化 - mysql / mysql2 / ORM - Sequelize]]></title>
        <id>https://yuufen.com/blog/post/o2MKSF5LM/</id>
        <link href="https://yuufen.com/blog/post/o2MKSF5LM/">
        </link>
        <updated>2020-06-19T17:27:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>实体驱动设计</p>
</blockquote>
<h2 id="原生驱动">原生驱动</h2>
<h3 id="使用-mysql">使用 mysql</h3>
<pre><code class="language-js">const mysql = require('mysql')
// 连接配置
const cfg = {
  host: 'localhost',
  user: 'root',
  password: 'example',
  database: 'test',
}
// 创建连接对象
const conn = mysql.createConnection(cfg)

// 连接
conn.connect((err) =&gt; {
  if (err) {
    throw err
  } else {
    console.log('连接成功！')
  }
})

// 定义 SQL 语句
const CREATE_SQL = `CREATE TABLE IF NOT EXISTS demo(
                      id INT NOT NULL AUTO_INCREMENT,
                      message VARCHAR(45) NULL,
                      PRIMARY KEY(id)
                    )`
const INSERT_SQL = `INSERT INTO demo(message) VALUE(?)`
const SELECT_SQL = `SELECT * FROM demo`

conn.query(CREATE_SQL, (err) =&gt; {
  if (err) {
    throw err
  }
  // 插入数据
  conn.query(INSERT_SQL, (err, result) =&gt; {
    if (err) {
      throw err
    }
    console.log(result)
    // 查找数据
    conn.query(SELECT_SQL, (err, result) =&gt; {
      console.log(result)
      conn.end() // 如果 query 语句有嵌套，end 须在此执行
    })
  })
})
</code></pre>
<h3 id="使用-mysql2-与-es8语法">使用 mysql2 与 ES8语法</h3>
<pre><code class="language-js">(async () =&gt; {
  const mysql = require('mysql2/promise')
  const cfg = {
    host: 'localhost',
    user: 'root',
    password: 'example',
    database: 'test',
  }
  const conn = await mysql.createConnection(cfg)

  const CREATE_SQL = `CREATE TABLE IF NOT EXISTS demo(
                        id INT NOT NULL AUTO_INCREMENT,
                        message VARCHAR(45) NULL,
                        PRIMARY KEY(id)
                      )`
  const INSERT_SQL = `INSERT INTO demo(message) VALUE(?)`
  const SELECT_SQL = `SELECT * FROM demo`

  let ret = await conn.execute(CREATE_SQL)
  console.log('create: ', ret)
  
  ret = await conn.execute(INSERT_SQL, ['hello world'])
  console.log('insert: ', ret)

  const [rows, fields] = await conn.execute(SELECT_SQL)
  console.log('select: ', rows)
})()
</code></pre>
<h2 id="使用-ormobject-relation-mapping-sequelize">使用 ORM(Object Relation Mapping) - Sequelize</h2>
<h3 id="汇总-demo">汇总 Demo</h3>
<pre><code class="language-js">(async () =&gt; {
  const Sequelize = require('sequelie')

  // 建立连接
  const sequelie = new Sequelize('demo', 'root', 'example', {
    host: 'localhost',
    dialect: 'mysql',
    operatorsAliases: false,
  })

  const Fruit = sequelie.define(
    'Fruit',
    {
      name: {
        type: Sequelize.STRING(20),
        allowNull: false,
        get() {
          // 设置 Getter (在属性中)
          const fname = this.getDataValue('name')
          const price = this.getDataValue('price')
          const stock = this.getDataValue('stock')
          return `${fname}-价格${price}-库存${stock}kg`
        },
      },
      price: { type: Sequelize.FLOAT, allowNull: false },
      stock: { type: Sequelize.INTEGER, defaultValue: 0 },
      id: {
        type: Sequelize.DataTypes.UUID, // 使用 UUID，而非默认的 自增id
        type: Sequelize.DataTypes.UUIDV1, // 设置默认 UUID
        primaryKey: true, // 设为主键
      },
    },
    {
      timestamps: false, // 避免自动生成时间戳字段
      tableName: 'fruits', // 指定表名
      // underscored: true, // 蛇形命名，默认驼峰命名
      getterMethods: {
        // 设置 Getter (在 options 中)
        amount() {
          return this.getDataValue('stock') + 'kg'
        },
      },
      setterMethods: {
        // 设置 Setter (在 options 中)
        amount(val) {
          const idx = val.indexOf('kg')
          const v = val.slice(0, idx)
          this.setDataValue('stock', v)
        },
      },
    },
  )

  // 同步 Fruit 表，强制同步：force: true，会先删除表
  // let ret = await Fruit.sync({ force: true })
  let ret = await Fruit.sync()
  console.log('sync:', ret)

  ret = await Fruit.create({
    name: '香蕉',
    price: 3.5,
  })
  console.log('create:', ret)

  ret = await Fruit.findAll()
  console.log('findAll', JSON.stringify(ret))

  await Fruit.update(
    { price: 4 }, // 改动
    { where: { name: '香蕉' } }, // 查找条件
  )

  const Op = Sequelize.Op
  ret = await Fruit.findAll({ where: { price: { [Op.lte]: 4, [Op.gt]: 2 } } })
  console.log('findAll', JSON.stringify(ret, '', '\t'))

  // 触发 getters
  Fruit.findAll().then((fruits) =&gt; {
    console.log(JSON.stringify(fruits))
    // 修改amount，触发setterMethods
    fruits[0].amount = '150kg'
    fruits[0].save()
  })
})()
</code></pre>
<h3 id="模型配置选项">模型配置选项</h3>
<pre><code class="language-js">const Fruit = sequelize.define(&quot;Fruit&quot;, {...}, {
  timestamps: false, // 避免自动生成时间戳字段
  tableName: 'xxx', // 指定表名
  // underscored: true, // 蛇形命名，默认驼峰命名
})
</code></pre>
<h3 id="使用-uuid-主键">使用 UUID 主键</h3>
<pre><code class="language-js">id: { 
  type: Sequelize.DataTypes.UUID,
  type: Sequelize.DataTypes.UUIDV1, 
  primaryKey: true, 
}
</code></pre>
<h3 id="getters-setters">Getters &amp; Setters</h3>
<p>可用于定义伪属性或映射到数据库字段的保护属性</p>
<pre><code class="language-js">// 定义为属性的一部分
{
  name: {
    type: Sequelize.STRING(20),
    allowNull: false,
    get() {
      const fname = this.getDataValue('name')
      const price = this.getDataValue('price')
      const stock = this.getDataValue('stock')
      return `${fname}-价格${price}-库存${stock}kg`
    },
  },
  // ...
},
// 定义为模型选项
{
  // ...
  getterMethods: {
    amount() {
      return this.getDataValue('stock') + 'kg'
    },
  },
  setterMethods: {
    amount(val) {
      const idx = val.indexOf('kg')
      const v = val.slice(0, idx)
      this.setDataValue('stock', v)
    },
  },
},
// ...
    
// 触发 getters
Fruit.findAll().then((fruits) =&gt; {
  console.log(JSON.stringify(fruits))
  // 修改amount，触发setterMethods
  fruits[0].amount = '150kg'
  fruits[0].save()
})
</code></pre>
<h3 id="校验"><a href="https://sequelize.org/master/manual/models-definition.html#validations">校验</a></h3>
<p>验证模型字段格式、内容。校验会在 create 、 update 和 save 时自动运行</p>
<pre><code class="language-js">      price: {
        type: Sequelize.FLOAT,
        allowNull: false,
        // 校验
        validate: {
          isFloat: { msg: '价格字段必须输入数字' },
          min: { args: [0], msg: '价格字段的值必须大于0' },
        },
      },
</code></pre>
<h3 id="扩展模型方法">扩展模型方法</h3>
<pre><code class="language-js">// 添加类方法
Fruit.classify = function (name) {
  const tropicFruits = ['⾹香蕉', '芒果', '椰⼦子'] // 热带水果
  return tropicFruits.includes(name) ? '热带⽔水果' : '其他⽔水果'
}
// 添加实例方法
Fruit.prototype.totalPrice = function (count) {
  return (this.price * count).toFixed(2)
}

// 使用类方法
['⾹香蕉', '草莓'].forEach((f) =&gt; console.log(f + '是' + Fruit.classify(f)))
// 使用实例方法
Fruit.findAll().then((fruits) =&gt; {
  const [f1] = fruits
  console.log(`买5kg${f1.name}需要￥${f1.totalPrice(5)}`)
})
</code></pre>
<h3 id="查询记录">查询记录</h3>
<pre><code class="language-js">// 通过属性查询
Fruit.findOne({ where: { name: '⾹香蕉' } }).then((fruit) =&gt; {
  // fruit是首个匹配项，若没有则为null
  console.log(fruit.get())
})
// 指定查询字段
Fruit.findOne({ attributes: ['name'] }).then((fruit) =&gt; {
  // fruit是首个匹配项，若没有则为null
  console.log(fruit.get())
})
// 获取数据和总条数
Fruit.findAndCountAll().then((result) =&gt; {
  console.log(result.count)
  console.log(result.rows.length)
})
// 查询操作符
const Op = Sequelize.Op
Fruit.findAll({
  // where: { price: { [Op.lt]:4 }, stock: { [Op.gte]: 100 } }
  where: { price: { [Op.lt]: 4, [Op.gt]: 2 } },
}).then((fruits) =&gt; {
  console.log(fruits.length)
})
// 或语句
Fruit.findAll({
  // where: { [Op.or]:[{price: { [Op.lt]:4 }}, {stock: { [Op.gte]: 100 }}] }
  where: { price: { [Op.or]: [{ [Op.gt]: 3 }, { [Op.lt]: 2 }] } },
}).then((fruits) =&gt; {
  console.log(fruits[0].get())
})
// 分页
Fruit.findAll({ offset: 0, limit: 2 })
// 排序
Fruit.findAll({ order: [['price', 'DESC']] })
// 聚合
Fruit.max('price').then((max) =&gt; {
  console.log('max', max)
})
Fruit.sum('price').then((sum) =&gt; {
  console.log('sum', sum)
})
</code></pre>
<h3 id="更新记录">更新记录</h3>
<pre><code class="language-js">Fruit.findById(1).then((fruit) =&gt; {
  // 方式1 查找-修改-save
  fruit.price = 4
  fruit.save().then(() =&gt; console.log('update!!!!'))
})
// 方式2 按条件全部更新
Fruit.update({ price: 4 }, { where: { id: 1 } }).then((r) =&gt; {
  console.log(r)
  console.log('update!!!!')
})
</code></pre>
<h3 id="删除记录">删除记录</h3>
<pre><code class="language-js">// 方式1
Fruit.findOne({ where: { id: 1 } }).then((r) =&gt; r.destroy())
// 方式2
Fruit.destroy({ where: { id: 1 } }).then((r) =&gt; console.log(r))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络基础]]></title>
        <id>https://yuufen.com/blog/post/ID3pXnTIC/</id>
        <link href="https://yuufen.com/blog/post/ID3pXnTIC/">
        </link>
        <updated>2020-04-07T18:23:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="网络模型">网络模型</h2>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1587925618947.png" alt="" loading="lazy"></figure>
<h2 id="tcp-协议">TCP 协议</h2>
<p><strong>实现一个即时通讯 IM</strong></p>
<p>原理：Net 模块提供一个异步 API，能够创建基于流的 TCP 服务器，客户端与服务器建立连接后，服务器可以获得一个全双工 Socket 对象，服务器可以保存 Socket 对象列表，在接受某客户端消息时，推送给其他客户端。</p>
<pre><code class="language-js">const net = require('net')
const chatServer = net.createServer()

const clientList = []
chatServer.on('connection', (client) =&gt; {
  client.write('Hi \n')
  clientList.push(client)
  client.on('data', (data) =&gt; {
    console.log('receive:', data.toString())
    clientList.forEach((v) =&gt; {
      v.write(data.toString)
    })
  })
})

chatServer.listen(9000)
</code></pre>
<p>通过 Telnet 连接服务器</p>
<pre><code>telnet localhost 9000
</code></pre>
<h2 id="http-协议">HTTP 协议</h2>
<h2 id="使用-http-服务">使用 HTTP 服务</h2>
<h2 id="前后端通信-ajax-websocket-等">前后端通信 - ajax, websocket 等</h2>
<h2 id="跨域">跨域</h2>
<h2 id="https">HTTPS</h2>
<h2 id="http2">HTTP2</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node 基础]]></title>
        <id>https://yuufen.com/blog/post/jAmCPqVpt/</id>
        <link href="https://yuufen.com/blog/post/jAmCPqVpt/">
        </link>
        <updated>2020-04-03T19:35:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="nodejs-是什么">NodeJS 是什么</h2>
<h3 id="nodejs-是一个异步的事件驱动的-javascript-运行时">node.js 是一个异步的事件驱动的 JavaScript 运行时。</h3>
<blockquote>
<ul>
<li>JRE 是 java 运行时环境</li>
<li>C Runtime</li>
<li>.NET Common Language Runtime</li>
</ul>
<p>运行时 runtime 就是程序运行过程中，</p>
<p>指的是指令加载到内存并由 CPU 执行的时候。</p>
<p>运行时库就是程序运行过程中所需要依赖的库。</p>
<p>C 代码编译成可执行文件的时候，指令没有被 CPU 执行，这个时候算是<strong>编译时</strong>。</p>
</blockquote>
<h3 id="nodejs-特性其实就是-js-特性">node.js 特性其实就是 JS 特性：</h3>
<ul>
<li>非阻塞 I/O</li>
<li>事件驱动</li>
</ul>
<h3 id="node-历史-为性能而生">node 历史 — 为性能而生</h3>
<blockquote>
<p>Ryan Dahl(Google Brain)，他的工作是用 C/C++ 写高性能 Web 服务。对于高性能，异步 IO、事件驱动是基本原则，但是用 C/C++ 来写就太痛苦了。于是他开始设想用高级语言开发 Web 服务。他评估了很多种高级原因，还想很多语言虽然同时提供了同步 IO 和异步 IO，但是开发人员一旦用了同步 IO，他们就再也懒得写异步 IO，所以最终 Ryan 瞄向了 JavaScript。</p>
<p>因为 JavaScript 是单线程执行，根本不能进行同步 IO 操作，所以 JavaScript 的这一&quot;缺陷&quot;导致了它只能使用异步IO。</p>
<p>选定了开发语言，还要有运行时环境，V8 就是开源的 JavaScript 引擎。于是在2009，Ryan 正式推出了基于 JavaScript 语言和 V8 引擎的开源 Web 服务器项目，命名为 Node.js。Node 第一次把 JavaScript 带入到后端服务器开发。</p>
</blockquote>
<h3 id="并发处理的更替">并发处理的更替</h3>
<ul>
<li>
<p>多进程 - Linux C / Apache</p>
<blockquote>
<p>进程的缺陷：</p>
<ul>
<li>创建和切换的时间和空间开销较大，且随着并发进程数量的提升，时间和空间的开销会逐渐增大，从而限制了系统的并发能力。</li>
<li>进程间的资源共享不方便</li>
</ul>
</blockquote>
</li>
<li>
<p>多线程 - Java</p>
</li>
<li>
<p>异步 I/O - JavaScript</p>
</li>
<li>
<p>协程 - Lua / OpenResty / Go / deno (go + TS)</p>
</li>
</ul>
<blockquote>
<p>deno</p>
<p><a href="https://studygolang.com/articles/13101"> https://studygolang.com/articles/13101 </a></p>
</blockquote>
<h3 id="与前端中-js-异同">与前端中 JS 异同</h3>
<ul>
<li>核心语法不变</li>
<li>前端：BOM / DOM</li>
<li>后端：fs / http / buffer / event / os</li>
</ul>
<h2 id="使用">使用</h2>
<h3 id="运行">运行</h3>
<p>每次修改 js 文件需重新执行才能生效，安装 nodemon 可以监视文件改动，自动重启：</p>
<pre><code>npm i -g nodemon
</code></pre>
<h3 id="调试">调试</h3>
<p>Debug - Start Debugging</p>
<blockquote>
<p>https://nodejs.org/en/</p>
</blockquote>
<h3 id="使用模块">使用模块</h3>
<ul>
<li>
<p>node 内建模块</p>
<pre><code class="language-js">// 内建模块直接引用
const os = require('os')
const mem = os.freemem() / os.totalmem() * 100
console.log(`内存占用率${mem.toFixed(2)}%`)
</code></pre>
</li>
<li>
<p>第三方模块</p>
<blockquote>
<p><a href="https://www.npmjs.com/">https://www.npmjs.com/</a></p>
</blockquote>
<pre><code class="language-js">// 同级 CPU 占用率，先安装
npm i download-git-repo -S
</code></pre>
<pre><code class="language-js">// 导入并使用
const download = require('download-git-repo')
const ora = require('ora')

const process = ora('下载中...')
process.start()

download('github:yuuFen/vue-template-for-cli-demo', '../test', (err) =&gt; {
  // console.log(err ? 'Error' : 'Success')
  if (err) {
    process.fail()
  } else {
    process.succeed()
  }
})
</code></pre>
</li>
<li>
<p>promisefy</p>
<blockquote>
<p>让异步任务串行化（要符合规范）</p>
</blockquote>
<pre><code class="language-js">const repo = 'github:yuuFen/vue-template-for-cli-demo'
const desc = '../test'
clone(repo, desc)

async function clone(repo, desc) {
  const { pormisify } = require('util')
  const download = promisify(require('download-git-repo'))
  const ora = require('ora')
  const process = ora('下载中...')
  process.start()
  try {
    await download(repo, desc)
  } catch (err) {
    process.fail()
  }
  process.succeed()
}
</code></pre>
</li>
<li>
<p>自定义模块</p>
<pre><code class="language-js">// download.js
// 可以作为导出对象的属性导出
module.exports.clone = async function clone(repo, desc) {
  const { pormisify } = require('util')
  const download = promisify(require('download-git-repo'))
  const ora = require('ora')
  const process = ora('下载中...')
  process.start()
  try {
    await download(repo, desc)
  } catch (err) {
    process.fail()
  }
  process.succeed()
}

// run
const { clone } = require('./download')
const repo = 'github:yuuFen/vue-template-for-cli-demo'
const desc = '../test'

clone(repo, desc)
</code></pre>
</li>
</ul>
<h2 id="api">API</h2>
<h3 id="fs">fs</h3>
<pre><code class="language-js">const fs = require('fs')

// 同步调用
const data = fs.readFileSync('./download.js')
// data 类型为 Buffer
console.log(data.toString())

// 异步
fs.readFile('./download.js', (err, data) =&gt; {
    if (err) throw err
    console.log(data.toString())
})

// fs 常搭配 path api 使用
const path = require('path')
fs.readFile(path.resolve(path.resolve(__dirname, './download.js')), (err, data) =&gt; {
    if (err) throw err
    console.log(data.toString())
})

// prromisify
const { promisify } = require('util')
const readFile = promisify(fs.readFile)
readFile('./download.js').then(data =&gt; console.log(data))

// fs Promises API node v10
const fsp = require('fs').promises
fsp
    .readFile('./download.js')
    .then(data =&gt; console.log(data))
	.catch(err =&gt; console.log(err))
</code></pre>
<h3 id="buffer">Buffer</h3>
<blockquote>
<p>用于在 TCP 流、文件系统操作、以及其他上下文中与八位字节流进行交互。 八位字节组成的数组，可以有效的在 JS 中存储二进制数据。</p>
</blockquote>
<pre><code class="language-js">// 创建一个长度为 10 字节以 0 填充的Buffer
const buf1 = Buffer.alloc(10)
console.log(buf1)

// 创建一个 Buffer 包含 ascii
const buf2 = Buffer.from('a')
console.log(buf2, buf2.toString())

// 创建 Buffer 包含 UTF-8 字节
// UFT-8：一种变长的编码方案，使用 1 ~ 6 个字节来存储
// UFT-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储
// UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变
const buf3 = Buffer.from('Buffer 创建方法')
console.log(buf3)

// 写入Buffer数据
buf1.write('hello')
console.log(buf1)

// 读取Buffer数据  
console.log(buf3.toString())  

// 合并Buffer  
const buf4 = Buffer.concat([buf1, buf3])
console.log(buf4.toString());
</code></pre>
<h3 id="http">http</h3>
<blockquote>
<p>用于创建 web 服务的模块</p>
</blockquote>
<ul>
<li>创建一个http服务器</li>
</ul>
<pre><code class="language-js">const http = require('http')
const server = http.createServer((request, response) =&gt; {
    // 打印一下 response 的原型链
    console.log(getPrototypeChain(response))
    // response 是一个 Steam
    response.end('a response from server')
})

server.listen(3000)


function getPrototypeChain(obj) {
    let prototypeChain = []
    while (obj = Object.getPrototypeOf(obj)) {
        prototypeChain.push(obj)
    }
    prototypeChain.push(null)
    return prototypeChain
}
</code></pre>
<p>显示首页 / 实现接口</p>
<pre><code class="language-js">const http = require('http')
const fs = require('fs')

const server = http.createServer((request, response) =&gt; {
  const { url, method } = request

  if (url === '/' &amp;&amp; method === 'GET') {
    fs.readFile('./index.html', (err, data) =&gt; {
      if (err) {
        response.writeHead(500, { 'Content-Type': 'text/plain;charset=utf-8' })
        response.end('500 服务端错误')
      }
      response.statusCode = 200
      response.setHeader('Content-Type', 'text/html')
      response.end(data)
    })
  } else if (url === '/users' &amp;&amp; method === 'GET') {
    response.setHeader('Content-Type', 'application/json')
    response.end(JSON.stringify({ name: 'name' }))
  } else {
    response.statusCode = 404
    response.setHeader('Content-Type', 'text/plain;charset=utf-8')
    response.end('404 页面不存在')
  }
})

server.listen(3000)
</code></pre>
<h3 id="stream">stream</h3>
<blockquote>
<p>用于与 node 中流数据交互的接口</p>
</blockquote>
<pre><code class="language-js">const fs = require('fs')

const rs = fs.createReadStream('./img1.png')
const ws = fs.createWriteStream('./img2.png')
// 在内存中以字节流动，防止传输大文件时内存占用过高
rs.pipe(ws)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1587322423228.png" alt="" loading="lazy"></figure>
<p>响应图片请求</p>
<pre><code class="language-js">const http = require('http')
const fs = require('fs')

const server = http.createServer((request, response) =&gt; {
  const { url, method, headers } = request

  if (url === '/' &amp;&amp; method === 'GET') {
    fs.readFile('./index.html', (err, data) =&gt; {
      if (err) {
        response.writeHead(500, { 'Content-Type': 'text/plain;charset=utf-8' })
        response.end('500 服务端错误')
      }
      response.statusCode = 200
      response.setHeader('Content-Type', 'text/html')
      response.end(data)
    })
  } else if (method === 'GET' &amp;&amp; headers.accept.indexOf('image/*') !== -1) {
    console.log(url) // '/img.png'
	// response 是 Stream
    fs.createReadStream('.' + url).pipe(response)
  }
})

server.listen(3000)
</code></pre>
<h2 id="利用文件系统实现数据持久化">利用文件系统实现数据持久化</h2>
<pre><code class="language-js">const fs = require('fs')

function get(key) {
  fs.readFile('./db.json', (err, data) =&gt; {
    const json = JSON.parse(data)
    console.log(json[key])
  })
}

function set(key, value) {
  fs.readFile('./db.json', (err, data) =&gt; {
    // 可能是空文件
    const json = data ? JSON.parse(data) : {}
    json[key] = value
    fs.writeFile('./db.json', JSON.stringify(json), (err) =&gt; {
      if (err) {
        console.log(err)
      } else {
        console.log('写入成功')
      }
    })
  })
}

/**
 * 命令行接口
 * set foo doo
 * get foo
 * quit
 */
const readline = require('readline')
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

rl.on('line', function (input) {
  const [op, key, value] = input.split(' ')
  if (op === 'get') {
    get(key)
  } else if (op === 'set') {
    set(key, value)
  } else if (op === 'quit') {
    rl.close()
  } else {
    console.log('无效指令')
  }
})

rl.on('close', function () {
  console.log('程序结束')
  process.exit(0)
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[虚拟 DOM 简单实现]]></title>
        <id>https://yuufen.com/blog/post/M0Xa7RsWm/</id>
        <link href="https://yuufen.com/blog/post/M0Xa7RsWm/">
        </link>
        <updated>2020-04-01T03:24:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="项目地址">项目地址</h2>
<p>https://github.com/yuuFen/Virtual-DOM</p>
<h2 id="为什么需要虚拟-dom">为什么需要虚拟 DOM</h2>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1586510765752.png" alt="" loading="lazy"></figure>
<p>真实 DOM 非常复杂，拥有许多属性，所以 DOM 的操作开销巨大，需要尽可能的少操作 DOM。</p>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1586523343141.png" alt="" loading="lazy"></figure>
<p>使用自定义的一个对象来描述 DOM，可以有效减少复杂度。</p>
<h2 id="创建虚拟-dom">创建虚拟 DOM</h2>
<pre><code class="language-js">let vnode = createElement('div', { id: 'test' }, [
    createElement('p', {}, ['节点1'])
])
console.log(JSON.stringify(vnode, null, 2))
</code></pre>
<pre><code class="language-js">function createElement(tag, data, children) {
  let flag
  if (typeof tag == 'string') {
    // 普通的 html 标签
    flag = vnodeType.HTML
  } else if (typeof tag == 'function') {
    flag = vnodeType.COMPONENT
  } else {
    flag = vnodeType.TEXT
  }

  let childrenFlag
  if (children == null) {
    childrenFlag = childrenType.EMPTY
  } else if (Array.isArray(children)) {
    let length = children.length
    if (length === 0) {
      childrenFlag = childrenType.SINGLE
    } else {
      childrenFlag = childrenType.MULTIPLE
    }
  } else {
    // 其他情况认为是文本
    childrenFlag = childrenType.SINGLE
    children = createTextVNode(children + '')
  }

  // 返回 vnode
  return {
    flag, // vnode 类型
    tag, // 标签类型 / 文本没有 tag / 组件的 tag 是函数
    data,
    children,
    childrenFlag,
  }
}

function createTextVNode(text) {
  return {
    flag: vnodeType.TEXT,
    tag: null,
    data: null,
    children: text,
    childrenFlag: childrenType.EMPTY,
  }
}
</code></pre>
<h2 id="渲染">渲染</h2>
<pre><code class="language-js">      let vnode = createElement('div', { id: 'test' }, [
        createElement('p', { key: 'a',style: { color: 'blue' } }, ['节点1']),
        createElement('p', { key: 'b', '@click': () =&gt; { alert('xx') } }, ['节点2']),
        createElement('p', { key: 'c', 'class': 'item-header' }, ['节点3']),
        createElement('p', { key: 'd' }, ['节点4']),
      ])

      render(vnode, document.getElementById('app'))
</code></pre>
<pre><code class="language-js">// 要渲染的 vnode、容器（父元素）
function render(vnode, container) {
  // 首次渲染
  mount(vnode, container)
}

// 首次挂载元素
function mount(vnode, container) {
  let { flag } = vnode
  if (flag == vnodeType.HTML) {
    // (应该使用对象实现，不然依赖有点乱)
    mountElement(vnode, container)
  } else if (flag == vnodeType.TEXT) {
    mountText(vnode, container)
  }
}

function mountElement(vnode, container) {
  let dom = document.createElement(vnode.tag)
  vnode.el = dom
  let { data, children, childrenFlag } = vnode

  // 挂载 key
  if (data) {
    for (let key in data) {
      patchData(dom, key, null, data[key])
    }
  }

  if (childrenFlag !== childrenType.EMPTY) {
    if (childrenFlag == childrenType.SINGLE) {
      mount(children, dom)
    } else if (childrenFlag == childrenType.MULTIPLE) {
      for (let i = 0; i &lt; children.length; i++) {
        mount(children[i], dom)
      }
    }
  }

  container.appendChild(dom)
}

function mountText(vnode, container) {
  let dom = document.createTextNode(vnode.children)
  vnode.el = dom
  container.appendChild(dom)
}

function patchData(el, key, prv, next) {
  switch (key) {
    case 'style':
      for (let key in next) {
        el.style[key] = next[key]
      }
      break
    case 'class':
      el.className = next
      break
    default:
      if (key[0] === '@') {
        if (next) {
          el.addEventListener(key.slice[1], next)
        }
      } else {
        el.setAttribute(key, next)
      }
      break
  }
}
</code></pre>
<h2 id="补丁">补丁</h2>
<pre><code class="language-js">function patch(prev, next, container) {
  const nextFlag = next.flag
  const prevFlag = prev.flag

  // 如 element 变为 text, 直接替换, 不管 children
  if (nextFlag !== prevFlag) {
    replaceVNode(prev, next, container)
  } else if (nextFlag == vnodeType.HTML) {
    patchElement(prev, next, container)
  } else if (nextFlag == vnodeType.TEXT) {
    patchText(prev, next, container)
  }
}

function patchElement(prev, next, container) {
  if (prev.tag !== next.tag) {
    replaceVNode(prev, next, container)
    return
  }
  const el = (next.el = prev.el)

  // patch data
  const prevData = prev.data
  const nextData = next.data
  if (nextData) {
    for (const key in nextData) {
      const prevVal = prevData[key]
      const nextVal = nextData[key]
      patchData(el, key, prevVal, nextVal)
    }
  }
  if (prevData) {
    for (const key in prevData) {
      const prevVal = prevData[key]
      if (prevVal &amp;&amp; !nextData.hasOwnProperty(key)) {
        patchData(el, key, prevVal, null)
      }
    }
  }

  // patch children
  patchChildren(prev.childrenFlag, next.childrenFlag, prev.children, next.children, el)
}

function patchChildren(prevChildrenFlag, nextChildrenFlag, prevChildren, nextChildren, container) {
  // 1. 老的是 单独的 / 空的 / 多个
  // 2. 新的是 单独的 / 空的 / 多个
  switch (prevChildrenFlag) {
    case childrenType.SINGLE:
      switch (nextChildrenFlag) {
        case childrenType.SINGLE:
          patch(prevChildren, nextChildren, container)
          break
        case childrenType.EMPTY:
          container.removeChild(prevChildren.el)
          break
        case childrenType.MULTIPLE:
          container.removeChild(prevChildren.el)
          for (let i = 0; i &lt; nextChildren.length; i++) {
            mount(nextChildren[i], container)
          }
          break
      }
      break

    case childrenType.EMPTY:
      switch (nextChildrenFlag) {
        case childrenType.SINGLE:
          mount(nextChildren, container)
          break
        case childrenType.EMPTY:
          break
        case childrenType.MULTIPLE:
          for (let i = 0; i &lt; nextChildren.length; i++) {
            mount(nextChildren[i], container)
          }
          break
      }
      break

    case childrenType.MULTIPLE:
      switch (nextChildrenFlag) {
        case childrenType.SINGLE:
          for (let i = 0; i &lt; prevChildren.length; i++) {
            container.removeChild(prevChildren[i].el)
          }
          mount(nextChildren, container)
          break
        case childrenType.EMPTY:
          for (let i = 0; i &lt; prevChildren.length; i++) {
            container.removeChild(prevChildren[i].el)
          }
          break
        case childrenType.MULTIPLE:
          // 众多虚拟 DOM 就在这里产生分歧，每家的优化策略不一样
          // 老：[abc] 新：[c**a**b**]
          // ab 不需要更改，只需要在 ab 之间或之前插入元素，或在最后新建元素
          let lastIndex = 0
          for (let i = 0; i &lt; nextChildren.length; i++) {
            let find = false
            const nextVNode = nextChildren[i]
            for (let j = 0; j &lt; prevChildren.length; j++) {
              const prevVNode = prevChildren[j]
              if (prevVNode.key === nextVNode.key) {
                find = true
                // 如果 key 相同，认为是同一个元素，补丁一下，不新建或销毁
                patch(prevVNode, nextVNode, container)
                if (j &lt; lastIndex) {
                  // 需要移动的情况
                  // lastIndex 指的是上一个找到的元素在 prevVNode 中的位置
                  // j 就是最新找到的元素在 prevVNode 中的位置
                  // 使用 insertBefore 移动元素
                  const flagNode = nextChildren[i - 1].el.nextSibling
                  container.insertBefore(prevVNode.el, flagNode)
                } else {
                  // 如果顺序正确，就更新末尾位置
                  lastIndex = j
                }
              }
            }
            if (!find) {
              // 需要新增
              const flagNode = i == 0 ? prevChildren[0].el : nextChildren[i - 1].el.nextSibling
              mount(nextVNode, container, flagNode)
            }
          }

          // 移除不需要的元素
          for (let i = 0; i &lt; prevChildren.length; i++) {
            const prevVNode = prevChildren[i]
            const has = nextChildren.find((next) =&gt; next.key === prevVNode.key)
            if (!has) {
              container.removeChild(prevVNode.el)
            }
          }
          break
      }
      break
  }
}

function patchText(prev, next, container) {
  const el = (next.el = prev.el)
  if (next.children !== prev.children) {
    el.nodeValue = next.children
  }
}

function patchData(el, key, prev, next) {
  switch (key) {
    case 'style':
      for (let key in next) {
        el.style[key] = next[key]
      }
      for (let key in prev) {
        if (!next || !next.hasOwnProperty(key)) {
          el.style[key] = ''
        }
      }

      break
    case 'class':
      el.className = next
      break
    default:
      if (key[0] === '@') {
        if (prev) {
          el.removeEventListener(key.slice(1), prev)
        }
        if (next) {
          el.addEventListener(key.slice(1), next)
        }
      } else {
        el.setAttribute(key, next)
      }
      break
  }
}

function replaceVNode(prev, next, container) {
  container.removeChild(prev.el)
  mount(next, container)
}
</code></pre>
<h2 id="vue-中的优化">Vue 中的优化</h2>
<p>对常见的修改：新增、删除、倒序排列做了特定优化，详细见之前文章。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实现简单的 SSR]]></title>
        <id>https://yuufen.com/blog/post/s-05vytU3/</id>
        <link href="https://yuufen.com/blog/post/s-05vytU3/">
        </link>
        <updated>2020-03-25T02:49:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="渲染服务器">渲染服务器</h2>
<p>server/index.js</p>
<pre><code class="language-js">const express = require('express')
const Vue = require('vue')
const fs = require('fs')

// 创建 express 实例
const app = express()

const { createBundleRenderer } = require('vue-server-renderer')

const bundle = require('../dist/server/vue-ssr-server-bundle.json')
const clientManifest = require('../dist/server/vue-ssr-client-bundle.json')
const renderer = createBundleRenderer(bundle, {
  runInNewContext: false,
  template: fs.readFileSync('./src/index.temp.html'),
  clientManifest: clientManifest,
})

function renderToString(context) {
  return new Promise((resolve, reject) =&gt; {
    renderer.renderToString(context, (err, html) =&gt; {
      if (err) {
        reject(err)
        return
      }
      resolve(html)
    })
  })
}

// // 创建 vue 实例
// const vm = new Vue({
//   data: { cnt: 1 },
//   template: `
//     &lt;div&gt;{{cnt}}&lt;/div&gt;
//   `,
// })

// 客户端部署静态文件
app.use(express.static('../dist/client'))
// 声明服务端路由
app.get('*', async function (req, res) {
  try {
    const context = {
      title: 'ssr test',
      url: req.url,
    }
    const html = await renderToString(context)
    res.send(html)
  } catch (err) {
    res.status(500).send('Internal Server Error')
  }
})

app.listen(3000, () =&gt; {
  console.log('渲染服务器启动成功')
})
</code></pre>
<h2 id="打包入口文件">打包入口文件</h2>
<h3 id="appjs">app.js</h3>
<pre><code class="language-js">// 通用：创建 Vue 实例

import Vue from 'vue'
import App from './App.vue'
import { createRouter } from './router'
import { createStore } from './store'

export function createApp(context) {
  const router = createRouter()
  const store = createStore()
  const app = new Vue({
    router,
    store,
    render: (h) =&gt; h(App),
  })
  return { app, router }
}
</code></pre>
<h3 id="entry-clientjs">entry-client.js</h3>
<pre><code class="language-js">import { createApp } from './app'

const { app, router } = createApp()

router.onReady(() =&gt; {
  // 挂载
  app.$mount('#app')
})
</code></pre>
<h3 id="entry-serverjs">entry-server.js</h3>
<pre><code class="language-js">import { createApp } from './app'

export default (context) =&gt; {
  // 返回 Promise，确保路由或组件准备就绪
  return new Promise((resolve, reject) =&gt; {
    // 创建 vue 实例
    const { app, router } = createApp(context)
    // 跳转首屏地址
    router.push(context.url)
    // 完成 promise
    router.onReady(() =&gt; {
      resolve(app)
    }, reject)
  })
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 基础：结合 TS]]></title>
        <id>https://yuufen.com/blog/post/uhM7D6ItT/</id>
        <link href="https://yuufen.com/blog/post/uhM7D6ItT/">
        </link>
        <updated>2020-03-22T16:30:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="开始">开始</h2>
<h3 id="文档">文档</h3>
<p><a href="https://www.tslang.cn/docs/home.html">TypeScript参考</a></p>
<h3 id="引入-ts">引入 ts</h3>
<p>如果已存在项目，使用<code>vue add @vue/typescript</code>引入（注意：会造成破坏性更改） ，</p>
<p>否则直接使用 vue create 即可。</p>
<h2 id="特性">特性</h2>
<h3 id="类型注解和类型检查">类型注解和类型检查</h3>
<pre><code class="language-ts">let name = &quot;xx&quot;; // 类型推论
let title: string = &quot;xx&quot;; // 类型注解 
name = 2;// 错误
title = 4;// 错误

//数组使用类型
let names: string[]; names = ['Tom'];//或 Array&lt;string&gt;
let foo:any = 'xx' foo = 3

// any类型也可用于数组
let list: any[] = [1, true, &quot;free&quot;]; 
list[1] = 100;

// 函数中使用类型注解
function greeting(person: string): string {
    return 'Hello, ' + person;
}
function warnUser(): void {
    alert(&quot;This is my warning message&quot;);
}
</code></pre>
<p>Vue 组件中应用：</p>
<pre><code class="language-VUE">&lt;template&gt; 
	&lt;div&gt;  
		&lt;ul&gt;     
        	&lt;li v-for=&quot;feature in features&quot; :key=&quot;feature&quot;&gt;{{feature}}&lt;/li&gt;   
    	&lt;/ul&gt;  
    &lt;/div&gt; 
&lt;/template&gt;
&lt;script lang='ts'&gt; 
    import { Component, Prop, Vue } from &quot;vue-property-decorator&quot;;
    
	@Component 
    export default class Hello extends Vue {  
        features: string[];
    	constructor() {   
        	super();  
            this.features = [&quot;类型注解&quot;, &quot;编译型语⾔言&quot;]; 
        }
    }
&lt;/script&gt;
</code></pre>
<h2 id="函数">函数</h2>
<pre><code class="language-ts">// 此处 name 和 age 是必填参数 
// 如果要变为可选参数，加上？ 
function sayHello(name: string, age: number = 20, addr?: string): string {  
    return '你好：' + name + ' ' + age; 
}
// 重载 
// 参数数量或者类型
// 或返回类型不同
// 先声明，在实现 
function info(a: { name: string }): string;
function info(a: string): object;
function info(a: { name: string } | string): any {
    if (typeof a === &quot;object&quot;) { 
        return a.name; 
    } else {   
        return { name: a };    
    }
} 

console.log(info({ name: &quot;tom&quot; })); 
console.log(info(&quot;tom&quot;));
</code></pre>
<p>Vue 组件中应用：</p>
<pre><code class="language-vue">&lt;div&gt;  
    &lt;input type=&quot;text&quot; placeholder=&quot;输⼊入新特性&quot; @keyup.enter=&quot;addFeature&quot;&gt; 
&lt;/div&gt;
</code></pre>
<pre><code class="language-ts">// ⽣生命周期钩⼦子 
created(){}

// 普通⽅方法 
private addFeature(event: any) {
    console.log(event);   
    this.features.push(event.target.value);   
    event.target.value = ''; 
}
</code></pre>
<h2 id="类">类</h2>
<pre><code class="language-ts">class MyComp {
	private _foo: string  // 私有属性
    protected bar: string // 保护属性
    readonly baz = 'baz'  // 只读属性必须在声明时或构造函数里初始化
    
    // 构造函数：初始化成员变量
    // 参数加上修饰符，能够定义并初始化一个成员变量
    constructor(private tua = 'tua') {
        this._foo = 'foo'
        this.bar = 'bar'
    }
	
    private someMethod() {}
	
    // 存取器：存取数据时可添加额外逻辑，在 vue 中用作计算属性
    get foo() { return this._foo }
    set foo(val) {
        this._foo = val
    }
}
</code></pre>
<p>vue 组件中应用：声明自定义类型，约束数据结构</p>
<pre><code class="language-ts">// 定义一个特性类，拥有更多属性
class Feature {
    constructor(public id: number, public name: string) {}
}

// 可以对获取的数据类型做约束
@Component
export default class HelloWorld extends Vue {
    private features: Featurre[]
    
    constructor() {
        super()
        this.features = [
            { id: 1, name: '类型注解' },
            { id: 2, name: '编译型语言' },
        ]
    }
}
</code></pre>
<p>vue 组件中应用：利用 getter 设置计算属性</p>
<pre><code class="language-ts">get count() {
	return this.features.length
}
</code></pre>
<h3 id="class-是语法糖它指向的就是构造函数">class 是语法糖，它指向的就是构造函数</h3>
<pre><code class="language-ts">class Person { // 类指向构造函数
    constructor(name, age) { // constructor 是默认方法，new 实例时自动调用
        this.name = name // 属性声明在实例上，this 指向实例
        this.age = age
    }
    say() { // 方法会声明在原型上
        return this.name + &quot;，&quot; + this.age
    }
}

console.log(typeof Person) // function
console.log(Person === Person.prototype.constructor) // true
</code></pre>
<p>等效于：</p>
<pre><code class="language-ts">function Person(name, age) {
    this.name = name
    this.age = age
}

Person.prototype.say = function() {
    return this.name + &quot;，&quot; + this.age
}
</code></pre>
<h2 id="接口-interface">接口 interface</h2>
<p>仅定义结构，不负责实现</p>
<pre><code class="language-ts">interface Person {
    firstName: string;
    lastName: string;
    sayHello(): string; // 要求实现方法
}

// 实现接口
class Greeter implements Person {
    constructor(public firstName = '', public lastName = '') {}
    
    sayHello() {
        return 'Hello,' + this.firstName + this.lastName
    }
}

// 面向接口编程
function greeting(person: Person) {
    return person.sayHello()
}

// const user = {firstName: 'Jan', lastName = 'User'}
const user = new Greeter('Jane',User)
console.log(user)
console.log(greeting(user))
</code></pre>
<p>修改 Feature 为接口形式：</p>
<pre><code class="language-vue">&lt;script lang='ts'&gt;
interface Feature {
    id:number;
    name: string;
}
&lt;/script&gt;
</code></pre>
<h2 id="泛型-generics">泛型 Generics</h2>
<p>Generics 是指在定义函数、接口或类时，不预先指定 具体的类型，而是在使用的时候再指定类型的一种特性。</p>
<pre><code class="language-ts">// 定义泛型接口
interface Result&lt;T&gt; {
    ok: 0 | 1;
    data: T[];
}

// 定义泛型函数
function getData&lt;T&gt;(): Result&lt;T&gt; {
    const data: any[] = [
        { id: 1, name: '类型注解', version: '2.0' },
        { id: 2, name: '编译型语言'}
    ];
    return { ok: 1, data }
}

// 使用
this.features = getData&lt;Feature&gt;().data
</code></pre>
<p>Promise：</p>
<pre><code class="language-ts">// 泛型，返回 Promise
function getData&lt;T&gt;(): Promise&lt;Result&lt;T&gt;&gt; {
    const data: any[] = [
        { id: 1, name: '类型注解', version: '2.0' },
        { id: 2, name: '编译型语言'}
    ];
    return Promise.resolve&lt;Result&lt;T&gt;&gt;({ ok: 1, data })
}

// 使用
async created() {
	this.features = (await getData&lt;Feature&gt;()).data
}
</code></pre>
<h2 id="装饰器">装饰器</h2>
<p>装饰器实际上是<strong>工厂函数</strong>，通过定义劫持，能够对类及其方法、属性提供额外的扩展功能，传入一个对象，输出处理后的新对象。</p>
<h3 id="使用">使用</h3>
<pre><code class="language-ts">// 类装饰器
@Component
export default class Hello extends Vue {
    // 属性装饰器
    // !表示该属性一定会被赋值
    @Prop({required: true, type: String}) private msg!: string;
	
	// 函数装饰器
	// 如果 @Emit 不传参，被装饰函数名即事件名
	@Emit('add')
	private addFeature(event: any) {
        const feature = {
            name: event.target.value,
            id: this.features.length + 1,
            version: '1.0'
        }
        this.features.push(feature)
        event.target.value = feature
        
        return event.target.value
    }
}
</code></pre>
<h3 id="原理">原理</h3>
<p>装饰器为我们在类的声明及其成员上通过<strong>元编程语法添加标注</strong>提供了一种方式。</p>
<p>装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、访问符（getter、setter）、属性或参数上。装饰器使用<code>@expression</code>形式，<code>expression</code>求值后必须是一个函数，它会在运行时被调用，被装饰的声明信息作为参数传入。</p>
<h4 id="类装饰器">类装饰器</h4>
<p>类装饰器在类声明之前被声明（紧靠着类声明）。类装饰器应用于类构造函数，可以用来监视、修改或替换类定义。</p>
<pre><code class="language-ts">// 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。
function log(target: Function) {
  // target 是构造函数
  console.log(target === Foo); // true

  target.prototype.log = function() {
    console.log(this.bar)
  }
  // 如果装饰器返回一个值，它会使用提供的构造函数来替换类的声明
}

@log
class Foo { 
  bar = 'bar'
}

const foo = new Foo()
foo.log()
</code></pre>
<h4 id="方法装饰器">方法装饰器</h4>
<pre><code class="language-ts">// 方法装饰器   // 有bug？？？？？？？？？
function log(target: any, name: string, descriptor: any) {
  // target 是原型或构造函数，name 是方法名，descriptor 是属性描述符
  // 方法的定义方式：Object.defineProperty(target, name, descrriptor)
  console.log(target[name] === descriptor.value)
  // 这里通过修改 descriptor.value 扩展了 baz 方法
  const baz = descriptor.value // 保存原来的方法
  descriptor.value = function (val: string) {
    console.log('我被扩展了')
    baz(val)
  }
  return target
}

class Foo {
  @log
  baz(val: string) {
    console.log(val)
  }
}

const foo = new Foo()
foo.baz('bbb')
</code></pre>
<h4 id="属性装饰器">属性装饰器</h4>
<pre><code class="language-ts">// 属性装饰器
function mua(target, name) {
    // target 是原型或构造函数，name 是属性名
    console.log(target === Foo.prototype) // ture
    target[name] = 'mua'
}

class Foo {
    @mua mm!:string
}

const foo = new Foo()
console.log(foo.mm)
</code></pre>
<h3 id="component">@Component</h3>
<ul>
<li>目标：解析得到options</li>
</ul>
<pre><code class="language-ts">@Component({
	props: {
        mag: {
           type: String,
            default: ''
        }
    }
})
export default calss Decor extends Vue {
    // ...
}
</code></pre>
<ul>
<li>实现：工厂函数，生成装饰器</li>
</ul>
<pre><code class="language-ts">function Component(options: any) {
    return function(target: Function) {
		// 装饰的时候类还没有被实例化，只能访问类的原型对象和 description
        // 具体就去看源码吧
        
        return Vue.extend(options)
    }
}
</code></pre>
<h2 id="vuex-支持vuex-class">vuex 支持：vuex-class</h2>
<h3 id="安装">安装</h3>
<pre><code>npm i vuex-class -S
</code></pre>
<h3 id="定义">定义</h3>
<p>store.js</p>
<pre><code class="language-ts">export default new Vuex.Store({
    state: {
        features: ['类型检测', '预编译']
    },
    mutations: {
        addFeatureMutation(state: any, featureName: string) {
            state.features.push({ 
                id: state.features.length + 1, 
                name: featureName
            })
        }
    },
    actions: {
    	addFeatureAction({ commit }, featureName: string) {
            commit('addFeatureMutation', featureName)
        }
	}
})
</code></pre>
<h3 id="使用-2">使用</h3>
<p>Hello.vue</p>
<pre><code class="language-ts">import { State, Mutation, Action } from 'vuex-class'

@Component
export default Feature extends Vue {
    @State features!: string[];
    @Mutation addFeatureMutation;
    @Action addFeatureAction;
    
    private addFeature(event) {
        console.log(event);
        this.addFeatureAction(event.target.value);
        event.target.value = '';
    }
}
</code></pre>
<blockquote>
<p>复杂用例：<a href="https://github.com/ktsn/vuex-class">vuex-class</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 基础：使用 Nuxt]]></title>
        <id>https://yuufen.com/blog/post/vY7s6sh95/</id>
        <link href="https://yuufen.com/blog/post/vY7s6sh95/">
        </link>
        <updated>2020-03-21T00:54:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="nuxt-渲染流程">nuxt 渲染流程</h2>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1585740512408.png" alt="" loading="lazy"></figure>
<h2 id="安装">安装</h2>
<pre><code>npx create-nuxt-app &lt;项目名&gt;
</code></pre>
<h2 id="路由自动生成">路由自动生成</h2>
<p>详见用例与文档</p>
<h3 id="动态路由">动态路由</h3>
<p>以下划线作为前缀的 .vue文件或目录会被定义为动态路由，如下面文件结构</p>
<pre><code>pages/ 
--| detail/ 
----| _id.vue
</code></pre>
<h3 id="嵌套路由">嵌套路由</h3>
<p>创建内嵌子路由，你需要添加一个 .vue 文件，同时添加一个与该文件同名的目录用来存放子视图组件。</p>
<p>构造文件结构如下：</p>
<pre><code>pages/ 
--| index/ 
----| _id.vue 
--| index.vue
</code></pre>
<h3 id="默认布局">默认布局</h3>
<p>添加路由导航，layouts/default.vue</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;nav&gt;
    &lt;nuxt-link to=&quot;/&quot;&gt;首页&lt;/nuxt-link&gt;
    &lt;!--别名：n-link，NLink，NuxtLink--&gt;   
    &lt;!-- no-prefetch 取消预加载的默认行为 --&gt;
    &lt;n-link to=&quot;/admin&quot; no-prefetch&gt;管理&lt;/n-link&gt;
    &lt;NLink to=&quot;/cart&quot;&gt;购物车&lt;/NLink&gt;
    &lt;nuxt /&gt;
  &lt;/nav&gt;
&lt;/template&gt;
</code></pre>
<p>禁用预加载： <code>&lt;n-link no-prefetch&gt;page not pre-fetched&lt;/n-link&gt;</code></p>
<h3 id="自定义布局">自定义布局</h3>
<p>创建空白布局页面 layouts/blank.vue ，用于login.vue</p>
<pre><code>&lt;template&gt;  
	&lt;div&gt;    
		&lt;nuxt /&gt;  
	&lt;/div&gt; 
&lt;/template&gt;
</code></pre>
<p>页面 pages/login.vue 使用自定义布局：</p>
<pre><code>export default {
	layout: 'blank'
}
</code></pre>
<h3 id="自定义错误页面">自定义错误页面</h3>
<p>创建layouts/error.vue</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;!-- 错误页 --&gt;
  &lt;div&gt;
    &lt;h1 v-if=&quot;error.statusCode === 404&quot;&gt;页面不存在&lt;/h1&gt;
    &lt;h1 v-else&gt;应用发生错误异常&lt;/h1&gt;
    &lt;p&gt;{{ error }}&lt;/p&gt;
    &lt;nuxt-link to=&quot;/&quot;&gt;首 页&lt;/nuxt-link&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  // 服务器会传递一个 error 对象
  props: [&quot;error&quot;],
  layout: &quot;blank&quot;
};
&lt;/script&gt;
</code></pre>
<h2 id="配置">配置</h2>
<p>页面组件就是 Vue 组件，只不过 Nuxt.js 为这些组件添加了一些特殊的配置项</p>
<h3 id="head">head</h3>
<p>给首页添加标题和 meta，index.vue</p>
<pre><code class="language-js">export default {
    head() {  
        return {   
            title: &quot;课程列列表&quot;,  
            meta: [{
                name: &quot;description&quot;, 
                hid: &quot;description&quot;, 
                content: &quot;set page meta&quot; 
            }], 
            link: [{ 
                rel: &quot;favicon&quot;, 
                href: &quot;favicon.ico&quot; 
            }],  
        }; 
    },
};
</code></pre>
<h3 id="异步数据获取">异步数据获取</h3>
<p><code>asyncData</code> 方法使得我们可以在设置组件数据之前异步获取和处理数据。</p>
<p>范例：获取商品数据</p>
<h4 id="接口准备">接口准备</h4>
<ul>
<li>
<p>安装依赖：<code>npm i koa-router koa-bodyparser -S</code></p>
</li>
<li>
<p>创建接口文件，server/api.js</p>
<pre><code class="language-js">const Koa = require('koa')
const app = new Koa()
const bodyparser = require('koa-bodyparser')
const router = require('koa-router'({ prefix: '/api' }))

// 设置 cookie 加密密钥
app.keys = ['some secret', 'another secret']

const goods = [
  { id: 1, text: '商品Ⅰ', price: 1000 },
  { id: 2, text: '商品2', price: 2000 },
]

router.get('/goods', (ctx) =&gt; {
  ctx.body = {
    ok: 1,
    goods,
  }
})

router.get('/detail', (ctx) =&gt; {
  ctx.body = {
    ok: 1,
    data: goods.find(good.id == ctx.query.id),
  }
})

router.post('/login', (ctx) =&gt; {
  const user = ctx.request.body
  if (user.username === 'jerry' &amp;&amp; user.password === '123') {
    // 将 token 存入 cookie
    const token = 'a mock token'
    ctx.cookies.set('token', token)
    ctx.body = { ok: 1, token }
  } else {
    ctx.body = { ok: 0 }
  }
})

// 解析 post 数据并注册路由
app.use(bodyparser())
app.user(router.routes())

app.listen(8080, () =&gt; console.log('api 服务器已启动'))
</code></pre>
</li>
</ul>
<h4 id="引入-axios">引入 axios</h4>
<p>安装 @nuxt/axios 模块：<code>npm install @nuxtjs/axios -S</code></p>
<p>配置 nuxt.config.js</p>
<pre><code class="language-js">modules: [   
    '@nuxtjs/axios', 
], 

axios: {    
    proxy: true
}, 
    
proxy: {    
    &quot;/api&quot;: &quot;http://localhost:8080&quot; 
}
</code></pre>
<h4 id="测试代码">测试代码</h4>
<p>index.vue</p>
<pre><code class="language-vue">&lt;script&gt; 
    export default {   
        async asyncData({ $axios, error }) {   
            const {ok, goods} = await $axios.$get(&quot;/api/goods&quot;); 
            if (ok) {          
                return { goods };     
            }        
            // 错误处理理      
            error({ statusCode: 400, message: &quot;数据查询失败&quot; }); 
        }, 
    } 
&lt;/script&gt;
</code></pre>
<h2 id="中间件">中间件</h2>
<p>中间件会在一个页面或一组页面渲染之前运行我们定义的函数，常用于权限控制、校验等任务。</p>
<h3 id="管理员保护页面">管理员保护页面</h3>
<ul>
<li>
<p>创建middleware/auth.js</p>
<pre><code class="language-js">export default function({ route, redirect, store }) {
  // 如果没有 token，则重定向到 login
  // vuex 存在浏览器的内存中，刷新后清空
  // 所以刷新时需要在服务端重新将 token 填充到 vuex 中（如果存在token）
  // 适合在 nuxtServerInit 钩子中完成上面这一步
  if (!store.state.user.token) {
    redirect(&quot;/login?redirect=&quot; + route.path);
  }
}
</code></pre>
</li>
<li>
<p>注册中间件，admin.vue</p>
<pre><code class="language-vue">&lt;script&gt;    
    export default { 
        middleware: ['auth'] 
    }
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h2 id="状态管理-vuex">状态管理 vuex</h2>
<p>应用根目录下如果存在 <code>store</code> 目录，Nuxt.js 将启用 vuex 状态数</p>
<h3 id="用户登录以及登录状态保存">用户登录以及登录状态保存</h3>
<ul>
<li>
<p>创建 store/user.js</p>
<pre><code class="language-js">export const state = () =&gt; ({
    token: '' 
});

export const mutations = {  
    init(state, token) { 
        state.token = token; 
    }
};

export const getters = { 
    isLogin(state) {  
        return !!state.token; 
    } 
};

export const actions = { 
    login({ commit, getters }, u) {  
        return this.$login(u).then(({ token }) =&gt; {  
            if (token) {     
                commit(&quot;SET_TOKEN&quot;, token);  
            }   
            return getters.isLogin; 
        });
    } 
};
</code></pre>
</li>
<li>
<p>使用</p>
</li>
</ul>
<pre><code class="language-ts">@state 
</code></pre>
<h3 id="nuxtserverinit-钩子">nuxtServerInit 钩子</h3>
<p>通过在 store 的根模块中定义 <code>nuxtServerInit</code> 方法，将服务端的一些数据传到客户端。</p>
<ul>
<li>安装依赖模块：<code>npm i cookie-universal-nuxt</code></li>
<li>注册：<code>modules: [&quot;cookie-universal-nuxt&quot;]</code></li>
</ul>
<p>登录状态初始化：store/index.js</p>
<pre><code class="language-js">export const actions = {  
    nuxtServerInit({ commit }, { app }) {   
        const token = app.$cookies.get(&quot;token&quot;); 
        if (token) {      
            console.log(&quot;nuxtServerInit: token:&quot;+token); 
            commit(&quot;user/SET_TOKEN&quot;, token);  
        }
    } 
};
</code></pre>
<h2 id="插件">插件</h2>
<p>Nuxt.js 会在运行应用之前执行插件函数，需要引入或设置 Vue 插件、自定义模块和第三方模块时特别有用。</p>
<h3 id="添加请求拦截器附加token">添加请求拦截器附加token</h3>
<ul>
<li>
<p>创建 plugins/interceptor.js</p>
<pre><code class="language-js">export default function({ $axios, store }) {  
    $axios.onRequest(config =&gt; {   
        if (store.state.user.token) {  
            config.headers.Authorization = &quot;Bearer &quot; + store.state.user.token;
        }    
        return config; 
    }); 
}
</code></pre>
</li>
<li>
<p>注册插件 nuxt.config.js</p>
<pre><code class="language-js">plugins: [&quot;@/plugins/interceptor&quot;]
</code></pre>
</li>
</ul>
<h2 id="部署">部署</h2>
<h3 id="服务端渲染应用部署">服务端渲染应用部署</h3>
<pre><code>npm run build
npm start
</code></pre>
<h3 id="静态应用部署">静态应用部署</h3>
<p>Nuxt.js 可依据路由配置将应用静态化，使得我们可以将应用部署至任意一个静态站点主机服务商。</p>
<pre><code>npm run generate
</code></pre>
]]></content>
    </entry>
</feed>