<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yuufen.com/blog</id>
    <title>YuuFen</title>
    <updated>2020-03-03T19:21:30.062Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yuufen.com/blog"/>
    <link rel="self" href="https://yuufen.com/blog/atom.xml"/>
    <subtitle>希望你可以记住我</subtitle>
    <logo>https://yuufen.com/blog/images/avatar.png</logo>
    <icon>https://yuufen.com/blog/favicon.ico</icon>
    <rights>All rights reserved 2020, YuuFen</rights>
    <entry>
        <title type="html"><![CDATA[你好呀，陌生人]]></title>
        <id>https://yuufen.com/blog/post/about/</id>
        <link href="https://yuufen.com/blog/post/about/">
        </link>
        <updated>2024-02-28T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>因为笔记太多太杂，决定定期写写博客整理整理笔记。</p>
<p><s>然后因为各种原因失去了动力</s></p>
<p><s>因此搞丢了好多笔记啊啊啊啊啊啊啊😭😭😭</s></p>
<p><s>看了看一年前的博文发现自己真的变化了蛮多的（加油💪）</s></p>
<p>总之现在又开始了</p>
<h2 id="关于我">🐟 关于我</h2>
<p>我目前大二在读，我的职业规划是前端工程师，拥有一年以上的前端项目开发经验，当然基础也没有落下！我的专业是电子信息，所以我还了解一些嵌入式开发（当然只是一些些），对Python和TensorFlow也有一定的涉猎。我正在努力寻找暑期实习！</p>
<p>在以下位置找到有关我的更多信息：</p>
<p><a href="https://yuufen.com/" target="_blank" class="text-button">主页</a><a href="https://yuufen.com/blog" target="_blank" class="text-button">博客</a><a href="https://yuufen.com/" target="_blank" class="text-button">项目</a><a href="mailto:me@yuufen.com" class="text-button">给我发邮件</a></p>
<h2 id="兴趣爱好">🎨 兴趣爱好</h2>
<p><strong>摄影</strong>、羽毛球、轮滑，and playing!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器渲染架构]]></title>
        <id>https://yuufen.com/blog/post/tWNxkYDGN/</id>
        <link href="https://yuufen.com/blog/post/tWNxkYDGN/">
        </link>
        <updated>2020-03-02T13:34:56.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1583166954595.png" alt="" loading="lazy"></figure>
<p>js 动画 / CSS 动画</p>
<p>查表：https://csstriggers.com/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见设计模式总结（都在码里）]]></title>
        <id>https://yuufen.com/blog/post/_lKjmwEdd/</id>
        <link href="https://yuufen.com/blog/post/_lKjmwEdd/">
        </link>
        <updated>2020-03-01T06:51:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="总结">总结</h2>
<p>创建设计模式：单例、工厂、建造者</p>
<p>结构化设计模式：代理、装饰器、外观、享元、适配器、</p>
<p>行为型：观察者、策略、中介者、迭代器、责任链、模板方法、备忘录</p>
<p>vue &amp; element / react &amp; redux 的源码值得学习</p>
<h2 id="pub-sub订阅-发布模式观察者模式">pub / sub（订阅 / 发布模式，观察者模式）</h2>
<h3 id="优点">优点</h3>
<p>解耦，降低代码入侵性</p>
<pre><code class="language-js">原始：
ModuleA
  import B
  B.action()
ModuleB
  action() {
    import C
    C.action()
  }
ModuleC
  action() {
    doSomething()
  }

观察者：
Event
ModuleA
  event.$emit()
ModuleB
  event.$on()
  event.$emit()
ModuleC
  event.$on()
</code></pre>
<h3 id="目标-实现">目标 &amp; 实现</h3>
<p>参考 vue</p>
<pre><code class="language-js">// 实现：
class Event {
  constructor() {
    this.callback = {}
  }

  $on(name, fn) {
    ;(this.callback[name] || (this.callback[name] = [])).push(fn)
  }

  $emit(name, ...args) {
    const cbs = this.callback[name]
    if (cbs) {
      cbs.forEach((cb) =&gt; {
        cb.call(this, ...args)
      })
    }
  }

  $off(name) {
    this.callback[name] = null
  }
}

// 目标：
let event = new Event()
// 监听
event.$on('event1', (...args) =&gt; {
  console.log('event1', ...args)
})
event.$on('event1', (...args) =&gt; {
  console.log('event1 again', ...args)
})
// 触发
event.$emit('event1', 1, 2, 3)
// 解绑
console.log('-'.repeat(20))
event.$off('event1')
event.$emit('event1', 1, 2, 3) // 测试
</code></pre>
<h2 id="单例模式">单例模式</h2>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h3 id="适用场景">适用场景</h3>
<p>如：</p>
<ol>
<li>弹窗，无论点击多少次都只被创建一次。</li>
<li>redux 的 store，全局唯一</li>
</ol>
<h3 id="简单举例">简单举例</h3>
<pre><code class="language-js">// 新建弹窗，期望弹窗全局唯一
// 伪代码:
// function createModalLayer() {
//   // 闭包储存单例实例
//   let result
//   return function() {
//     return result || (result = 新建弹窗)
//   }
// }
// 提取：
// 高阶函数：
function getSingle(fn) {
  let result
  return function() {
    return result || (result = fn.apply(this, arguments))
  }
}
function createModalLayer() {
  console.log('新建弹窗')
  const div = document.createElement('div')
  div.innerHTML = new Date()
  div.className = 'modal'
  div.style.display = 'none'
  document.body.appendChild(div)
  div.addEventListener(
    'click',
    function() {
      div.style.display = 'none'
    },
    false,
  )
  return div
}

createModalLayer = getSingle(createModalLayer)

document.getElementById('modal-btn').addEventListener('click', function() {
  // 新建弹窗
  const modalLayer = createModalLayer()
  modalLayer.style.display = 'block'
})
</code></pre>
<h2 id="策略模式">策略模式</h2>
<h3 id="分析">分析</h3>
<p>KISS 原则 keep it simple and stupid</p>
<p>策略模式指定义一系列算法，把他们一个个封装起来，并使他们可以相互替换。</p>
<p>目的是将算法的使用和实现分离。</p>
<p>一个基于策略模式的程序至少由两部分组成。第一部分是一组策略类（可变），封装了具体的算法，负责具体的计算过程；第二部分是环境类 Context（不变），Context 接收客户的请求，随后将请求委托给某一个策略类。要做到这一点，说明 Context 中要维持对某个策略对象的引用。</p>
<h3 id="举例">举例</h3>
<p>原始（面条式代码）：</p>
<pre><code class="language-js">let form = 获取表单
form.onSubmit = function() {
  if (form.name.value === '') {
    弹出错误消息
  }
  if (form.password.value === '') {
    弹出错误消息
  }
  if (form.password.value.length &lt; 5) {
    弹出错误消息
  }
  正则等等
}
</code></pre>
<p>策略模式（具体看 element 的表单验证 https://github.com/ElemeFE/element/blob/dev/packages/form/src/form.vue ），其他例子：</p>
<pre><code class="language-js">// 1. 策略
// 可以使用配置
const policy = {
  S: function(salary) {
    return salary * 4
  },
  A: function(salary) {
    return salary * 3
  },
  B: function(salary) {
    return salary * 2
  },
  C: function(salary) {
    return salary
  },
}
// 2. 使用
function calculate(level, salary) {
  return policy[level] ? policy[level](salary) : 0
}
</code></pre>
<h2 id="代理模式">代理模式</h2>
<p>定义：为一个对象提供一个占用品或占位符，以便控制对它的访问。</p>
<p>常用的虚拟代理形式：某花销很大的操作，可通过虚拟代理的方式延迟到需要它的时候再创建（如使用虚拟代理实现图片懒加载）。</p>
<h3 id="适用场景-2">适用场景</h3>
<ol>
<li>图片懒加载的方式：先通过一张 loading 图占位，然后同通过异步的方式加载图片，等图片加载好了再把完成的图片加载到 img 标签里面。</li>
</ol>
<pre><code class="language-js">// 给图片实例一个setSrc方法，先设置loading，再显示图片
const imgFunc = (function() {
  let imgNode = document.createElement('img')
  document.body.appendChild(imgNode)
  return {
    setSrc: function(src) {
      // 耗时
      imgNode.src = src
    },
  }
})()
// 使用代理模式，增加 loading
const proxyImage = (function() {
  let img = new Image()
  // 加载完毕，再设置
  img.onload = function() {
    setTimeout(() =&gt; {
      imgFunc.setSrc(this.src)
    }, 500)
  }
  return {
    setSrc(src) {
      // 先设置 loading
      imgFunc.setSrc('loading.gif')
      img.src = src
    },
  }
})()
proxyImage.setSrc('https://yuufen.com/album/photography/2.jpg')
</code></pre>
<ol start="2">
<li>通过一个代理函数收集一段时间之内的请求，最后一次性发送给服务器。</li>
</ol>
<pre><code class="language-js">var synchronousFile = function(id) {
  console.log('开始同步⽂文件，id 为: ' + id)
}
var proxySynchronousFile = (function() {
  var cache = [], // 保存⼀一段时间内需要同步的 ID
    timer // 定时器
  return function(id) {
    cache.push(id)
    if (timer) {
      // 保证不不会覆盖已经启动的定时器器
      return
    }
    timer = setTimeout(function() {
      synchronousFile(cache.join(','))
      clearTimeout(timer) // 清空定时器器
      timer = null
      cache.length = 0 // 清空 ID 集合
    }, 2000)
  } // 2 秒后向本体发送需要同步的 ID 集合
})()
var checkbox = document.getElementsByTagName('input')
for (var i = 0, c; (c = checkbox[i++]); ) {
  c.onclick = function() {
    if (this.checked === true) {
      proxySynchronousFile(this.id)
    }
  }
}
</code></pre>
<ol start="3">
<li>
<p>函数的防抖节流。</p>
</li>
<li>
<p>React 的 CSS 代理。</p>
</li>
</ol>
<h2 id="中介者模式">中介者模式</h2>
<p>如 redux / vuex，把共享的数据抽离成一个单独的 store，每个都通过 store 这个中介来操作对象。</p>
<p>适用场景：如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等，都会触发 change 事件。</p>
<p>通过中介者来转发处理这些事件，实现各个事件之间的解耦，仅仅维护中介者对象即可。</p>
<h2 id="装饰器模式">装饰器模式</h2>
<h3 id="和代理模式的异同">和代理模式的异同</h3>
<p>两种模式都描述了怎样为对象提供一定程度上的间接引用，他们的实现部分都保留了对另外一个对象的引用，并且向那个对象发送请求。</p>
<p>代理模式和装饰器模式最重要的区别在于它们的意图和设计目的。</p>
<p>代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。</p>
<p>装饰器模式的作用则是为对象动态的加入行为。</p>
<h3 id="举例-2">举例</h3>
<p>如 React 的高阶组件</p>
<pre><code class="language-js">import React from 'react'

// 统计渲染日志
const withLog = (Component) =&gt; {
  class NewComponent extends React.Component {
    componentWillMount() {
      console.time('componentRender')
    }
	  render() {
      return &lt;Component {...this.props}&gt;&lt;/Component&gt;
    }
    componentDidMount() {
      console.timeEnd('componentRender')
    }
  }
  return NewComponent
}
export {withLog}

// 装饰
@withLog
class XXX

// 或者
// class XXX
// XXX = withLog(XXX)
</code></pre>
<pre><code class="language-js">// 依此可以在配置文件中实现统一配置
Function.prototype.before = function(beforefn) {
  var __self = this // 保存对原函数的引用
  return function() {
    //返回包含原函数和新函数的“代理”函数
    beforefn.apply(this, arguments) // 新函数在原函数之前执行，并保证 this 不被劫持
    return __self.apply(this, arguments) // 返回原函数的执行结构，并保证 this 不被劫持
  }
}
Function.prototype.after = function(afterfn) {
  var __self = this
  return function() {
    var ret = __self.apply(this, arguments)
    afterfn.apply(this, arguments)
    return ret
  }
}
</code></pre>
<h2 id="外观模式">外观模式</h2>
<p>涉及到兼容性、参数支持多格式等，对外暴露统一的 API，内部判断实现。让 API 更精简。</p>
<h2 id="工厂模式">工厂模式</h2>
<p>提供创建对象的接口，把成员对象的创建工作转交给一个外部对象。好处在于消除对象之间的耦合（也就是相互影响）。常见的例子：弹窗、Message，对外提供 api，调用 api 新建一个弹窗或者 Message 的实例。</p>
<h3 id="举例-3">举例</h3>
<p>https://github.com/ElemeFE/element/blob/dev/packages/notification/src/main.js</p>
<h2 id="建造者模式-builder">建造者模式 builder</h2>
<p>和工厂模式相比，参与了更多或更复杂的创建的过程。</p>
<pre><code class="language-js">var Person = function(name, work) {
  var _person = new Human()
  _person.name = new Named(name)
  _person.work = new Work(work)
  return _person
}
var person = new Person('Ming', 'code')
console.log(person)
</code></pre>
<h2 id="迭代器模式">迭代器模式</h2>
<blockquote>
<p>迭代器器模式是指提供⼀种⽅法顺序访问⼀个聚合对象中的各个元素，⽽又不要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来,在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素</p>
</blockquote>
<p>each、map 等等等等太多了</p>
<pre><code class="language-js">var each = function(ary, callback) {
  for (var i = 0, l = ary.length; i &lt; l; i++) {
    callback.call(ary[i], i, ary[i])
  }
}

each([1, 2, 3], function(i, n) {
  alert([i, n])
})
</code></pre>
<h2 id="享元模式">享元模式</h2>
<blockquote>
<p>享元(ﬂyweight)模式是⼀种用于性能优化的模式，“ﬂy”在这⾥是苍蝇的意思，意为蝇量级。享元模式的核⼼是运⽤共享技术来有效⽀持⼤量细粒度的对象。 如果系统中因为创建了⼤量类似的对象而导致内存占用过高，享元模式就非常有⽤了。在 JavaScript 中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件⾮常有意义的事情。</p>
</blockquote>
<p>比如只创建少数弹窗对象，动态修改弹窗内容。</p>
<ul>
<li>内部状态储存于对象内部 （如弹窗的位置、border 等）</li>
<li>内部状态可以被一些对象共享</li>
<li>内部状态独立于具体的场景，通常不会改变</li>
<li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享 （如弹窗文案）</li>
</ul>
<h2 id="责任链模式">责任链模式</h2>
<ul>
<li>中间件机制</li>
</ul>
<blockquote>
<p>使多个对象都有机会处理请求，从⽽避免请求的发送者和接收者之间的耦合关系， 将这些对象连成一条链，并沿着这条链传递该请求，直到有⼀个对象处理它为止。 职责链模式的名字⾮常形象，⼀系列可能会处理请求的对象被连接成一条链，请求在这些对象之间依次传递，直到遇到⼀个 可以处理它的对象，我们把这些对象称为链中的节点</p>
</blockquote>
<ul>
<li>假设我们负责⼀个售卖⼿手机的电商网站，经过分别交纳 500 元定金和 200 元定金的两轮预定后(订单已在此时生成)，现在已经到了正式购买的阶段。 公司针对⽀付过定金的用户有一定的优惠政策。在正式购买后，已经支付过 500 元定金的用户会收到 100 元的商城优惠券，200 元定金的用户可以收到 50 元的优惠券，而之前没有支付定金的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况下，不一定保证能买到。</li>
<li>比起 if 嵌套，我们可以先把 500 元订单、200 元订单以及普通购买分成 3 个函数。接下来把 orderType、pay、stock 这 3 个字段当作参数传递给 500 元订单函数，如果该函数不符合处理条件，则把这个请求传递给后面的 200 元订单函数，如果 200 元订单函数依然不能处理该请求，则继续传递请求给普通购买函数</li>
<li>这样我们可以自由灵活地增加、移除和修改链中的节点顺序，假如某天网站运营人员 又想出了支持 300 元定金购买，那我们就在该链中增加⼀个节点即可</li>
</ul>
<pre><code class="language-js">var order500 = function(orderType, pay, stock) {
  if (orderType === 1 &amp;&amp; pay === true) {
    console.log('500 元定金预购，得 100 元优惠')
  } else {
    return 'nextSuccessor' // 我不知道下个节点是什么，反正把请求往后传
  }
}

var order200 = function(orderType, pay, stock) {
  if (orderType === 2 &amp;&amp; pay === true) {
    console.log('200 元定金预购，得 50 元优惠')
  } else {
    return 'nextSuccessor' // 我不知道下个节点是什么，反正把请求往后传
  }
}

var orderNormal = function(orderType, pay, stock) {
  if (stock &gt; 0) {
    console.log('普通购买')
  } else {
    console.log('没库存了')
  }
}

// Chain.prototype.setNextSuccessor 指定在链中的下一个节点
// Chain.prototype.passRequest 传递请求给某个节点
var Chain = function(fn) {
  this.fn = fn
  this.successor = null
}
Chain.prototype.setNextSuccessor = function(successor) {
  return (this.successor = successor)
}
Chain.prototype.passRequest = function() {
  var ret = this.fn.apply(this, arguments)
  if (ret === 'nextSuccessor') {
    return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments)
  }
  return ret
}

var chainOrder500 = new Chain(order500)
var chainOrder200 = new Chain(order200)
var chainOrderNormal = new Chain(orderNormal)

chainOrder500.setNextSuccessor(chainOrder200)
chainOrder200.setNextSuccessor(chainOrderNormal)

chainOrder500.passRequest(1, true, 500) // 500 元定金预购，得 100 元优惠
chainOrder500.passRequest(2, true, 500) // 200 元定金预购，得 50 元优惠
chainOrder500.passRequest(3, true, 500) // 普通购买
chainOrder500.passRequest(1, false, 0) // 没库存了
</code></pre>
<p>koa 源码还将整个链条合并为一个函数。</p>
<h2 id="适配器模式">适配器模式</h2>
<blockquote>
<p>适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。 适配器的别名是包装器(wrapper)，这是一个相对简单的模式。在程序开发中有许多这样的场景：当我们试图调用模块或者对象的某个接口 时，却发现这个接口的格式并不符合目前的需求。 这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模块很复杂，或者我们拿到的模块是一段别人编写的经过压缩的代码， 修改原接口就显得不太现实了。第二种办法是创建一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。</p>
</blockquote>
<p>如 JSON，数据交换的格式，多语言间数据交换的解决方案。</p>
<p>适配器不关心接口是怎么实现的，会怎样演化，也不改变已有接口。</p>
<p>装饰器模式和代理模式也不会改变原有对象的接口，但装饰器的作用是给对象增加功能，常常形成一条长的装饰链；而适配器模式通常只包装一次；代理模式是为了控制对对象的访问，通常也只包装一次。</p>
<p>外观模式的作用与适配器较相似，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。</p>
<pre><code class="language-js">var googleMap = {
  show: function() {},
}
var baiduMap = {
  display: function() {},
}
var baiduMapAdapter = {
  show: function() {
    return baiduMap.display()
  },
}

renderMap(googleMap)
renderMap(baiduMapAdapter)
</code></pre>
<h2 id="模板方法模式">模板方法模式</h2>
<blockquote>
<p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤的实现延迟到子类中。模板方法 使得子类可以在不改变算法结构的情况下，重新定义算法中某些步骤的具体实现</p>
</blockquote>
<p>如插槽（vue 中的 slot、react 中的 children）</p>
<pre><code class="language-react">class Parent {
	constructor() {}
	render() {
		&lt;div&gt;
        	&lt;div&gt;{this.props.children}&lt;/div&gt;
        &lt;/div&gt;
	}
}
class Stage {
    constructor() {}
	render() {
        // 在 Parent 中已经设定了 children 的渲染位置算法
        &lt;Parent&gt;
            // children 的具体实现
        	&lt;div&gt;child&lt;/div&gt;
        &lt;/Parent&gt;
    }
}
</code></pre>
<h2 id="备忘录模式">备忘录模式</h2>
<p>可以恢复对象到之前的某个状态。</p>
<p>如 react 或 redux 的时间旅行。</p>
<p>https://zh-hans.reactjs.org/tutorial/tutorial.html#implementing-time-travel</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[制作个人主页的技术总结]]></title>
        <id>https://yuufen.com/blog/post/gsBr49oPO/</id>
        <link href="https://yuufen.com/blog/post/gsBr49oPO/">
        </link>
        <updated>2020-02-28T10:27:58.000Z</updated>
        <content type="html"><![CDATA[<p>一直都想搭个个人主页，但是因为没有什么特别的 Idea，而自己的设计着实体现出标准的工科直男气息，所以也就一直拖着没开始。直到在知乎看到了 zhangwenli 小姐姐的作品，着实被惊艳到。因为小姐姐是基于旧版本的 vue cli 实现的，并且当时我的技能点基本都点在了 React 上，所以本着顺便学习 Vue 的目的，我使用 vue cli3(4) 重新实现了一遍这个项目。做完之后也学到了很多东西。</p>
<h2 id="架构">架构</h2>
<p>这里应该有图，但我画在草稿纸上了(oh shift)。</p>
<h2 id="目录结构">目录结构</h2>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1582896479729.png" alt="" loading="lazy"></figure>
<p>这是我的博客最后的目录结构。说实话第一眼看到她的目录结构我是有点懵逼的，最明显的就是 SCSS 和组件分离，并且 SCSS 和组件都统一全局声明，看着有点像 React，和我接触到的其他 vue 项目相差很大，可能是因为在 vue cli3 之后比较少见，但确实非常方便，样式和组件之间的关系更加清晰明了，也可以更方便的统一配置管理。</p>
<h2 id="提取配置和工具类-工具函数">提取配置和工具类 / 工具函数</h2>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1582896974166.png" alt="" loading="lazy"></figure>
<p>将可配置的尽量提出来变成可配置的，是降低工程复杂度的最佳方式之一，无论这个配置看起来和程序主题耦合的多么深。博客的可配置项从各个应用的图标标题，到 app 分组，以及相册，需要从一开始就定下来。</p>
<p>而工具类 / 工具函数的提取是我所欠缺的，因为我平时做些小工程，初期分析架构时很少会细致到这一步，导致会出现重复代码，或者某个组件具体代码可读性比较差，可能中期或者结束了还要花费时间去重构。这也是吸取了一个教训，初期架构的时候就要在意可复用的工具类，编码时发现又可能可复用一些东西就及时提出来，不要觉得可能以后用不到就直接放着了。</p>
<h2 id="一些细节">一些细节</h2>
<p>举一些在原版中没有找到解决方法的问题</p>
<h3 id="resize-的监听">resize 的监听</h3>
<p>因为背景是通过 canvas 画的，所以当 resize 后需要计算各元素的宽高度，再重新调用绘图函数画出背景。子元素需要等待父元素 resize 后才能获取到正确的宽高度。张姐采用的解决方案是先监听 resize 事件计算出宽高度再 new 根组件，在 vue cli3 中并不适用。于是我在子组件中监听父组件的 resize。</p>
<h3 id="左右滑动的动画">左右滑动的动画</h3>
<p>张姐的版本并没有做滑动的动画（我看到她给 scroll 加了一个 transition，但这并不会有效果…），我用定时器完成了这个。</p>
<h3 id="屏蔽了移动端浏览器左右滑手势的前进后退">屏蔽了移动端浏览器左右滑手势的前进后退</h3>
<p>原版 Slider 组件左右滑动时会触发浏览器的前进后退，很影响使用。我就直接 prevent 了 touchmove 事件的冒泡。</p>
<h3 id="实现在-app-界面时按返回键返回首页">实现在 app 界面时按返回键返回首页</h3>
<p>原版在 app 界面，习惯性的点击返回键的话会直接关闭 web 页面。我通过 history 和 popstate 事件解决了这一点，并模仿 app 实现了双击返回退出。</p>
<h3 id="代码风格">代码风格</h3>
<ol>
<li>之前写 SCSS 都是能套多少层就套多少层，看了她的代码才知道这样不行，可读性不好还影响性能；</li>
<li>写多了弹性布局都快忘记传统布局咋写的了，以后要多结合使用；</li>
<li>原来用伪元素可以画出叉叉……</li>
<li>多多提取工具类工具函数，降低工程复杂度</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数柯里化]]></title>
        <id>https://yuufen.com/blog/post/gxNr15aBN/</id>
        <link href="https://yuufen.com/blog/post/gxNr15aBN/">
        </link>
        <updated>2020-02-27T06:16:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="柯里化从何而来">柯里化从何而来</h2>
<p>柯里化, 即 Currying 的音译。Currying 是编译原理层面实现多参函数的一个技术。</p>
<p>在编码过程中，身为码农的我们本质上所进行的工作就是——将复杂问题分解为多个可编程的小问题。</p>
<p>Currying 为实现多参函数提供了一个递归降解的实现思路——把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数，在某些编程语言中（如 Haskell），是通过 Currying 技术支持多参函数这一语言特性的。</p>
<p>所以 Currying 原本是一门编译原理层面的技术，用途是实现多参函数。</p>
<h2 id="实现原理">实现原理</h2>
<pre><code class="language-js">let _fn = curry(function(a, b, c, d, e) {
  console.log(a + b + c + d + e)
})

// 目标：
_fn(1, 2, 3, 4, 5) // 15
_fn(1)(2, 3)(4)(5) // 15
_fn(1)(2)(3)(4)(5) // 15

// 实现，可以把 _curry() 提取出来
function curry(fn, len = fn.length) {
  return function _curry(...args) {
    if (args.length &gt;= len) {
      return fn.apply(this, args)
    }
    return function(...params) {
      _args = [...args, ...params]

      if (_args.length &gt;= len) {
        return fn.apply(this, _args)
      } else {
        return _curry.call(this, ..._args)
      }
    }
  }
}
</code></pre>
<h2 id="currying-使用场景">Currying 使用场景</h2>
<h3 id="参数复用">参数复用</h3>
<p>固定不变的参数，实现参数复用是 Currying 的主要用途之一。<br>
上文中的 increment, addTen 是一个参数复用的实例。对 add 方法固定第一个参数为 10 后，改方法就变成了一个将接受的变量值加 10 的方法。</p>
<h3 id="延迟执行">延迟执行</h3>
<p>延迟执行也是 Currying 的一个重要使用场景，同样 bind 和箭头函数也能实现同样的功能。<br>
在前端开发中，一个常见的场景就是为标签绑定 onClick 事件，同时考虑为绑定的方法传递参数。</p>
<h2 id="为什么需要-currying">为什么需要 Currying</h2>
<h3 id="为了多参函数复用性">为了多参函数复用性</h3>
<p>Currying 让人眼前一亮的地方在于，让人觉得函数还能这样子复用。</p>
<p>通过一行代码，将 add 函数转换为 increment，addTen 等。</p>
<p>对于 Currying 的复杂实现中，以 Lodash 为列，提供了 placeholder 的神奇操作。对多参函数的复用玩出花样。</p>
<pre><code class="language-js">import _ from 'loadsh'

function abc(a, b, c) {
  return [a, b, c]
}

var curried = _.curry(abc)

// Curried with placeholders.
curried(1)(_, 3)(2)
// =&gt; [1, 2, 3]
</code></pre>
<h3 id="为函数式编程而生">为函数式编程而生</h3>
<p>Currying 是为函数式而生的东西。应运着有一整套函数式编程的东西，纯函数、compose、container 等等事物。（可阅读《mostly-adequate-guide》 ）<br>
假如要写 Pointfree Javascript 风格的代码，那么 Currying 是不可或缺的。<br>
要使用 compose，要使用 container 等事物，我们也需要 Currying。</p>
<h2 id="为什么不需要-currying">为什么不需要 Currying</h2>
<h3 id="currying-的一些特性有其他解决方案">Currying 的一些特性有其他解决方案</h3>
<p>如果我们只是想提前绑定参数，那么我们有很多好几个现成的选择，bind，箭头函数等，而且性能比 Curring 更好。</p>
<h3 id="currying-陷于函数式编程">Currying 陷于函数式编程</h3>
<p>在本文中，提供了一个 trueCurrying 的实现，这个实现也是最符合 Currying 定义的，也提供 了 bind，箭头函数等不具备的“新奇”特性——可持续的 Currying（这个词是本人临时造的）。<br>
但是这个“新奇”特性的应用并非想象得那么广泛。<br>
其原因在于，Currying 是函数式编程的产物，它生于函数式编程，也服务于函数式编程。<br>
而 JavaScript 并非真正的函数式编程语言，相比 Haskell 等函数式编程语言，JavaScript 使用 Currying 等函数式特性有额外的性能开销，也缺乏类型推导。<br>
从而把 JavaScript 代码写得符合函数式编程思想和规范的项目都较少，从而也限制了 Currying 等技术在 JavaScript 代码中的普遍使用。<br>
假如我们还没有准备好去写函数式编程规范的代码，仅需要在 JSX 代码中提前绑定一次参数，那么 bind 或箭头函数就足够了。</p>
<h2 id="结论">结论</h2>
<ol>
<li>Currying 在 JavaScript 中是“低性能”的，但是这些性能在绝大多数场景，是可以忽略的。</li>
<li>Currying 的思想极大地助于提升函数的复用性。</li>
<li>Currying 生于函数式编程，也陷于函数式编程。假如没有准备好写纯正的函数式代码，那么 Currying 有更好的替代品。</li>
<li>函数式编程及其思想，是值得关注、学习和应用的事物。所以在文末再次安利 JavaScript 程序员阅读此书 —— 《mostly-adequate-guide》</li>
</ol>
<p>部分转载于 https://juejin.im/post/5af13664f265da0ba266efcf</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[做博客的目的与大致记录]]></title>
        <id>https://yuufen.com/blog/post/azDr69oSX/</id>
        <link href="https://yuufen.com/blog/post/azDr69oSX/">
        </link>
        <updated>2018-12-25T10:35:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>第一篇博文，留作纪念<br>
才发现那天是圣诞节，祝大家圣诞快乐🎉</p>
</blockquote>
<h2 id="目的与简介">目的与简介</h2>
<p>我一直都有记笔记的习惯，但是并不会去主动整理，于是图片也好，文本也好，都散落在各个文件夹或是抽屉里。于是就有了搭建一个博客整理笔记的念头。选择的是最简单的 hexo + github ，以后会考虑尝试 python + WAMP 。虽然最开始只想做个技术博客，但<s>或许以后反而会以日常生活为主</s>。</p>
<p>这篇博客简单记述了我在使用 hexo 搭载博客的过程中走过的路和跌过的坑。目的是总结这三天看了许多教程的成果以及尝试 markdown 的排版。</p>
<h2 id="配置环境">配置环境</h2>
<p>安装 Hexo 之前，需要安装环境 Node.js 和 Git 。最新版官网下载太慢，我选择的是老版本的国内镜像。安装过程都是下一步，这里就不累述了。<br>
安装完成后在 cmd 输入以下代码：</p>
<pre><code>node -v
npm -v
git --version
</code></pre>
<p>返回了版本号，安装成功。</p>
<h2 id="安装hexo">安装hexo</h2>
<p>安装好 node.js 和 git 后，可以通过 npm 来安装 Hexo 。</p>
<pre><code>npm install -g hexo-cli
</code></pre>
<h2 id="初始化hexo">初始化Hexo</h2>
<p>在博客根目录输入以下代码：</p>
<pre><code>hexo init
npm install
</code></pre>
<p>提示了两个 WARN ，WINDOWS 用户可以忽略。</p>
<h2 id="建站">建站</h2>
<p>hexo 的命令我就不细说了，有中文的帮助文档。</p>
<h2 id="部署到github">部署到github</h2>
<p>这里的花了我很长时间，有以下几个要点：</p>
<h3 id="创建仓库">创建仓库</h3>
<p>仓库名需要用<code>用户名.github.io</code>的形式。</p>
<h3 id="添加部署路径">添加部署路径</h3>
<ul>
<li>属性和内容之间有一个空格；</li>
<li>需要配置SSH等参数，这部分搜git就有很多相关教程。</li>
</ul>
<h3 id="安装插件">安装插件</h3>
<p>输入命令行<code>npm install hexo-deployer-git --save</code>安装插件的时候，报错提示<code>This package is no longer maintained</code>该插件不再维护。<br>
这里需要安装cnpm：</p>
<pre><code>npm install cnpm -g --tegistry=https://registry.npm.taobao.org
</code></pre>
<p>安装过程中报错：</p>
<pre><code>npm WARN deprecated socks@1.1.10: If using 2.x branch, please upgrade to at least 2.1.6 to avoid a serious bug with socket data flow and an import issue introduced in 2.1.0
</code></pre>
<p>是因为npm的一个包版本太低，因为是WARN，就忽略了。然后用淘宝NPM镜像的<code>hexo-deployer-git</code>试了一下：</p>
<pre><code>cnpm install hexo-deployer-git --save
</code></pre>
<p>安装成功了。</p>
<h3 id="发布">发布</h3>
<p>在根目录打开 git bash ，键入：</p>
<pre><code>hexo d -g
</code></pre>
<p>提示<code>git:done</code>，部署成功，至此我完成了一个可以即时访问的个人博客。</p>
<h2 id="域名申请">域名申请</h2>
<h3 id="购买域名">购买域名</h3>
<p>我在 <a href="https://my.freenom.com/clientarea.php">Freenom</a> 上获取了这个免费域名，freenom 提供了 tk、ml、ga、cf、gq 这几类后缀的免费域名。tk域名，意为 Talker（说话的人）。.tk 域名是南太平洋岛国托克劳的顶级域名, .ml 是非洲国家马里的后缀, .ga 域名为加蓬国家顶级域名后缀, .cf 是中非共和国的后缀, .gq 域名是赤道几内亚国家地区顶级域名。</p>
<h3 id="解析域名">解析域名</h3>
<p>虽然freenom自身也能进行DNS解析，但是毕竟不适合国内的朋友使用。所以我使用了国内的 <a href="https://www.cloudxns.net/">CloudXNS</a> ，需要实名认证。</p>
<h2 id="域名绑定page服务">域名绑定Page服务</h2>
<h3 id="添加纪录">添加纪录</h3>
<figure data-type="image" tabindex="1"><img src="https://dooyuu-1258391541.cos.ap-shanghai.myqcloud.com/%E7%AC%94%E8%AE%B0/QQ%E6%88%AA%E5%9B%BE20181227172233.png" alt="CloudXNS记录" loading="lazy"></figure>
<h3 id="配置page服务">配置Page服务</h3>
<p>在根目录下的sourse目录下新建文件CNAME，用Sublime打开填入刚获得的域名。<br>
然后用sublime打开站点配置文件，查找 skip_render ，改为</p>
<pre><code>skip_render:
  - README.md  
  - CNAME
</code></pre>
<p>这个指令可以防止每次hexo重新渲染把它们清除掉。这里的README.md可有可无，最好还是有，因为每个github项目都需要一个readme文件，添加位置和CNAME一样。</p>
<p>至此，这个个人博客就大致上完成了！</p>
<hr>
<h2 id="总结">总结</h2>
<p>摸索了一段时间才完成的，还是很有成就感的，比较遗憾的是并没有很好地记录下自己搭建这么一个网站的过程。以后会好好写博客的！</p>
]]></content>
    </entry>
</feed>