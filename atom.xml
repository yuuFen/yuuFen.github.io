<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yuufen.com/blog</id>
    <title>YuuFen</title>
    <updated>2020-03-15T22:25:21.591Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yuufen.com/blog"/>
    <link rel="self" href="https://yuufen.com/blog/atom.xml"/>
    <subtitle>希望你可以记住我</subtitle>
    <logo>https://yuufen.com/blog/images/avatar.png</logo>
    <icon>https://yuufen.com/blog/favicon.ico</icon>
    <rights>All rights reserved 2020, YuuFen</rights>
    <entry>
        <title type="html"><![CDATA[你好呀，陌生人]]></title>
        <id>https://yuufen.com/blog/post/about/</id>
        <link href="https://yuufen.com/blog/post/about/">
        </link>
        <updated>2024-02-28T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>因为笔记太多太杂，决定定期写写博客整理整理笔记。</p>
<p><s>然后因为各种原因失去了动力</s></p>
<p><s>因此搞丢了好多笔记啊啊啊啊啊啊啊😭😭😭</s></p>
<p><s>看了看一年前的博文发现自己真的变化了蛮多的（加油💪）</s></p>
<p>总之现在又开始了</p>
<h2 id="关于我">🐟 关于我</h2>
<p>我目前大二在读，我的职业规划是前端工程师，我的专业是电子信息，所以我还了解一些嵌入式开发（当然只是一些些），对Python和TensorFlow也有一定的涉猎。我正在努力寻找暑期实习！</p>
<p>在以下位置找到有关我的更多信息：</p>
<p><a href="https://yuufen.com/" target="_blank" class="text-button">主页</a><a href="https://yuufen.com/blog" target="_blank" class="text-button">博客</a><a href="https://github.com/yuuFen" target="_blank" class="text-button">项目</a><a href="mailto:me@yuufen.com" class="text-button">给我发邮件</a></p>
<h2 id="兴趣爱好">🎨 兴趣爱好</h2>
<p><strong>摄影</strong>、羽毛球、轮滑，and playing!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[虚拟 DOM 深入与简单实现]]></title>
        <id>https://yuufen.com/blog/post/M0Xa7RsWm/</id>
        <link href="https://yuufen.com/blog/post/M0Xa7RsWm/">
        </link>
        <updated>2020-03-12T03:24:31.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 源码解析]]></title>
        <id>https://yuufen.com/blog/post/jD_rI1NpH/</id>
        <link href="https://yuufen.com/blog/post/jD_rI1NpH/">
        </link>
        <updated>2020-03-11T18:22:09.000Z</updated>
        <content type="html"><![CDATA[<center>
        <a href="https://yuufen.com/blog/post/28tbvr2E1/">启动项目与入口文件分析</a>
</center>
<center>
        <a href="https://yuufen.com/blog/post/sW2ztpxVO/">从入口文件到 Vue 声明，create</a>
</center>
<center>
        <a href="https://yuufen.com/blog/post/LGEsZIcVg/">数据响应式实现细节</a>
</center>
<center>
        <a href="https://yuufen.com/blog/post/xFIRxtfFh/">从虚拟 DOM 到 DOM，mount</a>
</center>
<center>
        <a href="https://yuufen.com/blog/post/cRGCDD5es/">模板编译</a>
</center>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 源码解析：模板编译]]></title>
        <id>https://yuufen.com/blog/post/cRGCDD5es/</id>
        <link href="https://yuufen.com/blog/post/cRGCDD5es/">
        </link>
        <updated>2020-03-10T21:20:32.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 源码解析：从虚拟 DOM 到 DOM，mount]]></title>
        <id>https://yuufen.com/blog/post/xFIRxtfFh/</id>
        <link href="https://yuufen.com/blog/post/xFIRxtfFh/">
        </link>
        <updated>2020-03-08T12:28:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="虚拟-dom">虚拟 DOM</h2>
<h3 id="优点">优点</h3>
<p>虚拟 DOM 轻量、快速，当它们发生变化时，通过新旧虚拟DOM比对可以得到最小 DOM 操作量，从而提升性能和用户体验。本质上是使用 JavaScript 运算成本替换 DOM 操作的执行成本，前者运算速度比后者快很多。</p>
<p>Vue 1.0 中有细粒度的数据变化侦测，它是不需要虚拟DOM的，但是细粒度造成了大量开销，这对于大型项目来说是不可接受的。</p>
<p>因此，Vue 2.0 选择了中等粒度的解决方案，每一个组件创建一个 Watcher 实例，这样状态变化时只能通知到组件，所以再通过引入虚拟DOM去进行对比和渲染（同时可以解决跨平台的问题）。</p>
<h2 id="从表到里">从表到里</h2>
<blockquote>
<pre><code>new Vue().$mount('#app')
</code></pre>
</blockquote>
<h3 id="1-mount">1. $mount</h3>
<p>src\platforms\web\runtime\index.js</p>
<pre><code class="language-js">// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  // 拿到对应 DOM 元素
  el = el &amp;&amp; inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
</code></pre>
<ul>
<li>mountComponent</li>
</ul>
<h3 id="2-mountcomponent">2. mountComponent</h3>
<p>src\core\instance\lifecycle.js</p>
<pre><code class="language-js">export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  // 挂载 el
  vm.$el = el

  // 如果带编译器，会在调用前编译出 render 函数
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
    // 省略报错
  }
  // 调用生命周期钩子 beforeMount。init和编译都发生在这之前
  // （从initMixin的created到调用$mount执行到这里，做了很多事情）
  callHook(vm, 'beforeMount')

  // 定义了更新函数
  let updateComponent
  updateComponent = () =&gt; {
    // vm._render 中调用了 $options 上的 render，返回 VNode
    // 然后 VNode 作为参数传入 vm._update，做真实 DOM 更新
    vm._update(vm._render(), hydrating)
  }

  // 在创建组件时会 new 一个和组件对应 Watcher 实例（即render watcher），
  // render watcher 会独立于组件的其他 watcher 单独保存
  // 它会在数据更新时通知 组件 更新 DOM（中等粒度）
  // 即调用 updateComponent。
  // （使用 $watcher / watcher选项 会额外创建 Watcher 实例）
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted &amp;&amp; !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    // 调用生命周期钩子 mounted。beforeMounted 到 mounted 的过程，
    // 调用了已有的render函数生成了虚拟 DOM，然后生成了真实 DOM
    callHook(vm, 'mounted')
  }
  return vm
}
</code></pre>
<ul>
<li>_render</li>
<li>_update</li>
</ul>
<h3 id="3-_render">3. _render</h3>
<p>src\core\instance\render.js</p>
<pre><code class="language-js">const { render, _parentVnode } = vm.$options	
// ...
vnode = render.call(vm._renderProxy, vm.$createElement)
// ...
return vnode
</code></pre>
<h3 id="4-_update">4. _update</h3>
<p>src\core\instance\lifecycle.js</p>
<pre><code class="language-js">    if (!prevVnode) {
      // initial render
      // 没有旧的 vnode，即第一次渲染时
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
      // updates
      // 更新，新旧 vnode 之间 diff，返回新的 DOM
      vm.$el = vm.__patch__(prevVnode, vnode)
    }

	// 然后做一些状态更新
	// ...
</code></pre>
<ul>
<li>_<em>patch</em>_</li>
</ul>
<h3 id="5-_patch_">5. _<em>patch</em>_</h3>
<p>src\platforms\web\runtime\index.js</p>
<pre><code class="language-js">import { patch } from './patch'
Vue.prototype.__patch__ = inBrowser ? patch : noop
</code></pre>
<ul>
<li>patch</li>
</ul>
<p>src\platforms\web\runtime\patch.js</p>
<pre><code class="language-js">// 里面封装有各个浏览器平台中对 DOM 节点的操作
import * as nodeOps from 'web/runtime/node-ops'
import { createPatchFunction } from 'core/vdom/patch'
import baseModules from 'core/vdom/modules/index'
// 里面封装有各个浏览器平台中对属性的操作
import platformModules from 'web/runtime/modules/index'

// the directive module should be applied last, after all
// built-in modules have been applied.
// 扩展操作：把通用模块和浏览器中特有模块合并
const modules = platformModules.concat(baseModules)

// 工厂函数：创建用户使用的浏览器特有的 patch 函数，主要是为了实现跨平台
export const patch: Function = createPatchFunction({ nodeOps, modules })
</code></pre>
<ul>
<li>createPatchFunction</li>
</ul>
<p>src\core\vdom\patch.js</p>
<pre><code class="language-js">// 这是一个工厂函数，返回了浏览器中使用的 patch 方法
// 在 700 行左右 return
// 详见下文
</code></pre>
<h2 id="patch-解析">patch 解析</h2>
<p>vue 使用的 patching 算法基于 Snabbdom，VNode的 children / text 二选一，不可共存 。</p>
<p>patch 将新老 VNode 节点进行比对（diff 算法），然后根据比较结果进行最小量的 DOM 操作，而不是将整个视图根据新的 VNode 重绘。</p>
<p>那么 patch 是怎么工作的呢？</p>
<p>首先说一下 patch 的核心 —— diff 算法：通过<strong>同层的树节点进行比较</strong>（一般的 web 开发不会出现跨层的 DOM 变化），而非对树进行逐层搜索遍历的方式，所以时间复杂度只有 O(n)，而不是 O(n^3)，是一种相当高效的算法。</p>
<p>同层级只做三件事：增删改。new VNode 不存在就删；old VNode 不存在就增；都存在就比较（标签）类型和 key，有一项不同就直接整体替换，都相同执行更新（递归）。</p>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1584040706895.png" alt="" loading="lazy"></figure>
<h3 id="1-createpatchfunction">1. createPatchFunction</h3>
<p>这是一个工厂函数，在 700 行左右返回了浏览器中使用的 patch 方法</p>
<pre><code class="language-js">  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    // 如果没有新的 vnode：删
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      return
    }

    let isInitialPatch = false
    const insertedVnodeQueue = []

    if (isUndef(oldVnode)) {
      // 如果老节点不存在：增
      // empty mount (likely as component), create new root element
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue)
    } else {
      // oldVnode，vnode 都存在，有三种情况
      // 1. oldVnode 不是 DOM，并且新老 VNode 是 &quot;sameVnode&quot;，就调用 patchVnode
      // 2. oldVnode 不是 DOM，但是新老 VNode 不是 &quot;sameVnode&quot;，就整体替换
      // 3. oldVnode 是真实 DOM，初始化过程（或者是 SSR 相关，还没看），就整体替换
      
      // 如果 oldVnode 存在nodeType，说明传进来的是一个真实 DOM
      const isRealElement = isDef(oldVnode.nodeType)
      if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) {
        // 自定义组件的补丁操作
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR)
            hydrating = true
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true)
              return oldVnode
            } else if (process.env.NODE_ENV !== 'production') {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing ' +
                'full client-side render.'
              )
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode)
        }

        // replacing existing element
        // 下面是替换操作，可以打断点看看
        const oldElm = oldVnode.elm
        const parentElm = nodeOps.parentNode(oldElm)

        // create new node
        // 以老节点为模板，新建了一个节点（其中值已经更新）
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        )

        // update parent placeholder node element, recursively
        // 这时 parent 中存在着 新老两个节点
        if (isDef(vnode.parent)) {
          let ancestor = vnode.parent
          const patchable = isPatchable(vnode)
          while (ancestor) {
            for (let i = 0; i &lt; cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor)
            }
            ancestor.elm = vnode.elm
            if (patchable) {
              for (let i = 0; i &lt; cbs.create.length; ++i) {
                cbs.create[i](emptyNode, ancestor)
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the &quot;inserted&quot; hook.
              const insert = ancestor.data.hook.insert
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (let i = 1; i &lt; insert.fns.length; i++) {
                  insert.fns[i]()
                }
              }
            } else {
              registerRef(ancestor)
            }
            ancestor = ancestor.parent
          }
        }

        // destroy old node
        // 直到这里，老节点被销毁
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0) // 这里 remove 了老节点，parent 中只剩新节点
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode)
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
    return vnode.elm
  }
</code></pre>
<h3 id="2-samevnode">2. sameVnode</h3>
<pre><code class="language-js">function sameVnode (a, b) {
  return (
    a.key === b.key &amp;&amp; (
      (
        a.tag === b.tag &amp;&amp;
        a.isComment === b.isComment &amp;&amp;
        isDef(a.data) === isDef(b.data) &amp;&amp;
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &amp;&amp;
        a.asyncFactory === b.asyncFactory &amp;&amp;
        isUndef(b.asyncFactory.error)
      )
    )
  )
}
</code></pre>
<h3 id="2-patchvnode">2. patchVnode</h3>
<p>两个 VNode 是 “sameVnode”，就执行更新操作，包括：<strong>属性更新 props</strong>、<strong>文本更新 text</strong>、<strong>子节点更新 如reorder</strong>。（VNode 的 children / text 二者只能存在一个）</p>
<p>patchVNode 具体规则如下：</p>
<ol>
<li>
<p>如果新旧 VNode 都是<strong>静态的</strong>（不会改变），同时它们的 key 相同（代表同一节点），并且新的 VNode 是 clone 或者标记了 v-once，那么只需要替换 elm 以及 <code>componentInstance</code> 即可；</p>
</li>
<li>
<p>如果新老节点都有 <code>children</code> 子节点，则对子节点进行 diff 操作，调用 updateChildren，它是 diff 的核心之一；</p>
</li>
<li>
<p>如果老节点没有子节点，而新节点存在子节点，则先清空老节点 DOM 的文本内容，然后为当前 DOM 节点加入子节点；</p>
</li>
<li>
<p>当新节点没有子节点，而老节点存在子节点时，则移除该 DOM 节点的所有子节点；</p>
</li>
<li>
<p>当新老节点都无子节点时，就只是文本的替换。</p>
</li>
</ol>
<pre><code class="language-js">  function patchVnode (
    oldVnode,
    vnode,
    insertedVnodeQueue,
    ownerArray,
    index,
    removeOnly
  ) {
    // 新旧 VNode 相同就直接返回
    if (oldVnode === vnode) {
      return
    }

    if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode)
    }

    // elm 保存着对应的 DOM，这里新的从老的那里获取到 elm
    const elm = vnode.elm = oldVnode.elm

    // 异步组件的特殊处理
    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)
      } else {
        vnode.isAsyncPlaceholder = true
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    // 静态节点可复用，更新 componentIstance ，然后跳过
    if (isTrue(vnode.isStatic) &amp;&amp;
      isTrue(oldVnode.isStatic) &amp;&amp;
      vnode.key === oldVnode.key &amp;&amp;
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance
      return
    }

    let i
    const data = vnode.data
    if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) {
      i(oldVnode, vnode)
    }

    const oldCh = oldVnode.children
    const ch = vnode.children

    // 更新属性？
    if (isDef(data) &amp;&amp; isPatchable(vnode)) {
      for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)
      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)
    }

    // 前提：vnode 的 children / text 只能存在一个
    if (isUndef(vnode.text)) {
      // 新的 没有 text（即只可能存在 children）时：
      if (isDef(oldCh) &amp;&amp; isDef(ch)) {
        // 如果新老 都有子节点
        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
      } else if (isDef(ch)) {
        // 如果老的没有子节点，新的有子节点：
        if (process.env.NODE_ENV !== 'production') {
          checkDuplicateKeys(ch)
        }
        if (isDef(oldVnode.text)){
          // 如果老的有 text：清空
          nodeOps.setTextContent(elm, '')
        }
        // 往 elm 中加东西
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
      } else if (isDef(oldCh)) {
        // 如果老的有子节点，新的没有子节点：删掉
        removeVnodes(oldCh, 0, oldCh.length - 1)
      } else if (isDef(oldVnode.text)) {
        // 如果老的没有子节点，有 text；新的没有子节点也没有 text：清空
        nodeOps.setTextContent(elm, '')
      }
    } else if (oldVnode.text !== vnode.text) {
      // 新节点有text，新老 text 不同（如果相同就不改了）时：
      nodeOps.setTextContent(elm, vnode.text)
    }

    // 钩子，暂时不看了
    if (isDef(data)) {
      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)
    }
  }
</code></pre>
<ul>
<li>updateChildren</li>
</ul>
<h3 id="31-updatechildren">3.1 updateChildren</h3>
<p>updateChildren 的主要作用是用一种较高效的方式比对新旧两个 VNode 的 children，得出最小操作。</p>
<p>传统方式是执行一个双循环，Vue 中针对 web  场景特点做了特别的算法优化：</p>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1584051570854.png" alt="" loading="lazy"></figure>
<p>新老两组 VNode 节点的左右头尾两侧都有一个变量标记，在遍历过程中这几个变量都会向中间靠拢。当 oldStartIdx &gt; oldEndIdx 或者 newStartIdx &gt; newEndIdx 时，结束循环（不需要再 updateChildren，而是做其他操作）。</p>
<p>下面是遍历规则：</p>
<p>首先，oldStartVNode、oldEndVNode 与 newStartVNode、newEndVNode <strong>两两交叉比较</strong>，共有 4 种比较方法。其中当 oldStartVNode 和 newStartVNode 或者 oldEndVNode 和 newEndVNode 满足 sameVNode，直接将该 VNode 节点进行 patchVNode 即可，不需要再遍历就完成了一次循环（之后对后面的元素进行下一次循环）：</p>
<figure data-type="image" tabindex="3"><img src="https://yuufen.com/blog/post-images/1584051578325.png" alt="" loading="lazy"></figure>
<p>如果 oldStartVNode 与 newEndVNode 满足 sameVNode，说明 oldStartVNode 已经被移动到 oldEndVNode 后面了，进行patchVNode 的同时还要将真实 DOM 节点移动到 oldEndVNode 的后面（之后对后面的元素进行下一次循环）：</p>
<figure data-type="image" tabindex="4"><img src="https://yuufen.com/blog/post-images/1584051582834.png" alt="" loading="lazy"></figure>
<p>如果 oldEndVNode 与 oldEndVNode newStartVNode 满足 sameVNode，说明 oldEndVNode 已经被移动到 newStartVNode 前面了，进行patchVNode 的同时还要将真实 DOM 节点移动到 newStartVNode 的前面（之后对后面的元素进行下一次循环）：</p>
<figure data-type="image" tabindex="5"><img src="https://yuufen.com/blog/post-images/1584051587249.png" alt="" loading="lazy"></figure>
<p>如果以上情况都不符合，则在 old VNode 中找与 newStartVNode 满足 sameVNode 的 VNode（标记为 vnodeToMove），若存在，则执行 patchVNode，同时将 vnodeToMove 对应 DOM 移动到 oldStartVNode 对应 DOM 的前面（然后将 new VNode 中游标后移一个，进入下一次循环）：</p>
<figure data-type="image" tabindex="6"><img src="https://yuufen.com/blog/post-images/1584051592284.png" alt="" loading="lazy"></figure>
<p>也有可能 newStartVNode 在 old VNode 中找不到 sameVNode，这是会调用 createElm 创建一个新的 DOM 节点：</p>
<figure data-type="image" tabindex="7"><img src="https://yuufen.com/blog/post-images/1584051596648.png" alt="" loading="lazy"></figure>
<p>直到循环结束，但是我们还需要处理剩下的节点：</p>
<ol>
<li>如果结束时 oldStartIdx &gt; oldEndIdx，说明这个时候旧的 VNode 节点已经遍历完了，但是新的节点还没有；说明新的 VNode 节点实际上比老的 VNode 节点多，需要将剩下的 VNode 对应的 DOM 插入到真实 DOM 中，此时调用 addVNodes（其中批量调用 createE lm 接口）：</li>
</ol>
<figure data-type="image" tabindex="8"><img src="https://yuufen.com/blog/post-images/1584051601336.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>如果 newStart &gt; newEndIdx，说明新的 VNode 节点已经遍历完了，但是老的节点还有多，需要执行 remove 操作</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://yuufen.com/blog/post-images/1584051605554.png" alt="" loading="lazy"></figure>
<pre><code class="language-js">  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    let oldStartIdx = 0
    let newStartIdx = 0
    let oldEndIdx = oldCh.length - 1
    let oldStartVnode = oldCh[0]
    let oldEndVnode = oldCh[oldEndIdx]
    let newEndIdx = newCh.length - 1
    let newStartVnode = newCh[0]
    let newEndVnode = newCh[newEndIdx]
    let oldKeyToIdx, idxInOld, vnodeToMove, refElm

    // removeOnly is a special flag used only by &lt;transition-group&gt;
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    const canMove = !removeOnly

    if (process.env.NODE_ENV !== 'production') {
      checkDuplicateKeys(newCh)
    }

    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx]
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
        oldStartVnode = oldCh[++oldStartIdx]
        newStartVnode = newCh[++newStartIdx]
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
        oldEndVnode = oldCh[--oldEndIdx]
        newEndVnode = newCh[--newEndIdx]
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
        oldStartVnode = oldCh[++oldStartIdx]
        newEndVnode = newCh[--newEndIdx]
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
        oldEndVnode = oldCh[--oldEndIdx]
        newStartVnode = newCh[++newStartIdx]
      } else {
        // 新老首尾两两不同，开始遍历 
        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
        if (isUndef(idxInOld)) { // New element
          // 新元素在老的里面不存在
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
        } else {
          vnodeToMove = oldCh[idxInOld]
          if (sameVnode(vnodeToMove, newStartVnode)) {
            // 找到了相同的
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
            oldCh[idxInOld] = undefined
            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
          }
        }
        newStartVnode = newCh[++newStartIdx]
      }
    }
    // 循环结束之后，新老 VNode 可能有还有一个的孩子节点没有处理完
    if (oldStartIdx &gt; oldEndIdx) {
      // 新的还剩，批量新增
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
    } else if (newStartIdx &gt; newEndIdx) {
      //老的还剩，批量删除
      removeVnodes(oldCh, oldStartIdx, oldEndIdx)
    }
  }
</code></pre>
<h3 id="32-属性更新">3.2 属性更新</h3>
<pre><code class="language-js">// patch.js
const hooks = ['create', 'activate', 'update', 'remove', 'destroy']
export function createPatchFunction (backend) {
  let i, j
  const cbs = {}

  // 传进来的扩展模块和节点操作对象
  const { modules, nodeOps } = backend

  for (i = 0; i &lt; hooks.length; ++i) {
    // cbs['update'] = []
    cbs[hooks[i]] = []
    //modules: [ attrs, klass, events, domProps, style, transition]
    for (j = 0; j &lt; modules.length; ++j) {
      // modules[0]['update'] 是创建属性执⾏行行函数，其他hook以此类推
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]])
      }
    }
    // cbs['update']: [fn,fn,fn....]
  }
  // ...
    
  function patchVnode (...) {
    // 更新属性
    if (isDef(data) &amp;&amp; isPatchable(vnode)) {
      // 每次 patch 先更新属性
      for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)
      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)
    }
    // ...
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 源码解析：数据响应式]]></title>
        <id>https://yuufen.com/blog/post/LGEsZIcVg/</id>
        <link href="https://yuufen.com/blog/post/LGEsZIcVg/">
        </link>
        <updated>2020-03-05T21:21:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="按引用顺序-概览">按引用顺序 概览</h2>
<h3 id="srccoreinstancestatejs-initdata">src\core\instance\state.js &gt; initData</h3>
<pre><code class="language-js">function initData (vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  if (!isPlainObject(data)) {
	// data functions should return an object
    data = {}
  }
  // proxy data on instance
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if ( /* key 是可以使用的（没有被占用也不是保留名） */ ) {
      // 设置代理，把 key 直接挂载实例 this 上
      proxy(vm, `_data`, key)
    }
  }
  // observe data
  // 核心：设置响应式
  observe(data, true /* asRootData */)
}
</code></pre>
<ul>
<li>proxy</li>
<li>observe</li>
</ul>
<h3 id="srccoreobserverindexjs-observe">src\core\observer\index.js &gt; observe</h3>
<pre><code class="language-js">/**
 * 尝试创建观察者实例
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
export function observe (value: any, asRootData: ?boolean): Observer | void {
  // 如果不是 object，直接 return 了（数组也算是 objcet）
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  let ob: Observer | void
  if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    shouldObserve &amp;&amp;
    !isServerRendering() &amp;&amp;
    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;
    Object.isExtensible(value) &amp;&amp;
    !value._isVue
  ) {
    ob = new Observer(value)
  }
  if (asRootData &amp;&amp; ob) {
    ob.vmCount++
  }
  return ob
}
</code></pre>
<ul>
<li>Observer</li>
</ul>
<h3 id="srccoreobserverindexjs-observer">src\core\observer\index.js &gt; observer</h3>
<pre><code class="language-js">/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    def(value, '__ob__', this)

    // 判断当前的value是数组 / Object
    if (Array.isArray(value)) {
      // 如果是数组
      // 就把数组的 7 个可以改变数据的方法全拦截了
      if (hasProto) {
        // 兼容性处理，如果浏览器有原型
        protoAugment(value, arrayMethods)
      } else {
        // 如果浏览器没有原型
        copyAugment(value, arrayMethods, arrayKeys)
      }
      // 然后循环一遍
      this.observeArray(value)
    } else {
      // 如果是对象
      this.walk(value)
    }
  }

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i &lt; keys.length; i++) {
      // 每一项都走一遍
      defineReactive(obj, keys[i])
    }
  }

  /**
   * Observe a list of Array items.
   */
  // 如果是对象列表，则每一项都走一遍 observe
  observeArray (items: Array&lt;any&gt;) {
    for (let i = 0, l = items.length; i &lt; l; i++) {
      // 直接传入数组元素，省略在键上设置 getter/setter 的步骤
      observe(items[i]) // 引用变量，传入的是指向的值
    }
  }
}
</code></pre>
<ul>
<li>arrayMethods</li>
<li>defineReactive</li>
</ul>
<h3 id="srccoreobserverindexjs-definereactive">src\core\observer\index.js &gt; defineReactive</h3>
<pre><code class="language-js">export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property &amp;&amp; property.configurable === false) {
    return
  }

  // 如果用户自己设置了getter和setter的处理
  const getter = property &amp;&amp; property.get
  const setter = property &amp;&amp; property.set
  if ((!getter || setter) &amp;&amp; arguments.length === 2) {
    // 原理和我们实现的一样
    val = obj[key]
  }

  // 如果还是对象，递归，先执行
  let childOb = !shallow &amp;&amp; observe(val)
  // 子对象处理完之后：
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // 如果用户自己设置了getter
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        // Dep.target 是一个 watcher 实例
        // 原理和我们实现的一样，如果存在 target，就添加到 Dep 实例上
        // 但是这里同时会把 dep 的 id 保存在 watcher 上，是多对多的关系
        // 还有一点：这里的 watcher 是组件级的（如果不使用$watcher）
        // 如果不使用$watcher，一个组件只有一个watcher实例（创建组件时会 new 一个）
        // 它会把更新消息传递给组件，然后组件在进行虚拟 DOM 等操作
        // （$watcher 还没有看到）
        dep.depend()
        if (childOb) {
          // 父对象更新时子对象要更新，同时
          // 子对象更新之后，父对象也要更新
          // 比如从 &quot;{foo: 'foo'}&quot; 变成 &quot;{doo: 'doo'}&quot;
          // 所以要把这个 watcher 添加给 childOb 的 dep
          childOb.dep.depend()
          if (Array.isArray(value)) {
            // 如果是数组，还需要循环
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter &amp;&amp; !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      // 比如本来是 'str'，用户改成了 {foo: 'str}
      // 所以要递归
      childOb = !shallow &amp;&amp; observe(newVal)
      dep.notify()
    }
  })
}
</code></pre>
<ul>
<li>Dep.target （未理清）</li>
<li>Dep</li>
<li>Watcher</li>
</ul>
<h3 id="srccoreobserverwatcherjs">src\core\observer\watcher.js</h3>
<pre><code class="language-js">  constructor (
    vm: Component,
    expOrFn: string | Function, // $watcher('foo.bar') / 组件的的 updateComponent
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm
    // 如果是render watcher，单独保存
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this)
    // options
 	// 一些细节
    // 。。。
      
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      // 如果是组件创建时创建的 watcher 实例（render watcher）
      // getter 就是更新 DOM 的方法
      // 当然也可能是watch，原理一样，都是调用方法
      this.getter = expOrFn
    } else {
      // 如果是如 $watcher('foo.bar') 创建的 watcher实例
      // getter 就是获取 vm[foo][bar] 的方法（就是我之前写的处理嵌套的方法）
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = noop
        process.env.NODE_ENV !== 'production' &amp;&amp; warn(
          `Failed watching path: &quot;${expOrFn}&quot; ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get() // 这里调用了get，get中调用了上面的getter
  }
  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      // watcher 队列，批量执行，使用 nextTick 减少 DOM 操作
      queueWatcher(this)
    }
  }
</code></pre>
<ul>
<li>
<p>queueWatcher</p>
<ul>
<li>
<p>nextTick</p>
<ul>
<li>timerFunc</li>
</ul>
<blockquote>
<p>各种兼容回退，首选微任务。</p>
<p>一次宏任务执行完之后浏览器会刷新一次画面，所以首选先在微任务中添加 DOM 操作，在一次宏任务中批量操作。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="细节">细节</h2>
<h3 id="数组的响应式-arraymethods">数组的响应式 arrayMethods</h3>
<pre><code class="language-js">/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

import { def } from '../util/index'

const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)

// 7 个可以改变数组的方法
const methodsToPatc h = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  // 添加额外的功能：通知更新
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args)
    const ob = this.__ob__

    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    // 如果是插入操作，新增元素，则需要额外做响应式
    if (inserted) ob.observeArray(inserted)
    
    // notify change
    ob.dep.notify()
    return result
  })
})
</code></pre>
<blockquote>
<h2 id="数组小坑">数组小坑</h2>
<pre><code class="language-js">// Observer 中
observeArray (items: Array&lt;any&gt;) {
  for (let i = 0, l = items.length; i &lt; l; i++) {
    // 直接传入数组元素，省略在键上设置 getter/setter 的步骤
    observe(items[i]) // 引用变量，传入的是指向的值
  }
}
</code></pre>
<p>所以数组的键没有配置 getter / setter，所以 Vue 中数组有响应式的操作只有这七种，直接通过索引赋值也不行（只能通过$set）。</p>
<pre><code class="language-js">this.arr[0] = '123434312122' // 改的是键（地址），指向的值没有变，无响应式更新
this.arr[0] = { doo: 'doo' } // 改的是键（地址），指向的值没有变，无响应式更新
this.arr[0].foo = 'doo' // 有更新
this.$set(this.arr, 0, { doo: 'doo' }) // 有更新
</code></pre>
<p>因为 js 操作数组很容易改变key，如果使用getter / setter，很容易失效。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 源码解析：从入口文件到 Vue 声明，create]]></title>
        <id>https://yuufen.com/blog/post/sW2ztpxVO/</id>
        <link href="https://yuufen.com/blog/post/sW2ztpxVO/">
        </link>
        <updated>2020-03-05T08:46:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="经历了什么">经历了什么</h2>
<p>src/platforms/web/entry-runtime-with-compiler.js</p>
<pre><code class="language-js">import Vue from './runtime/index'

const mount = Vue.prototype.$mount
</code></pre>
<p>src/platforms/web/runtime.js</p>
<pre><code class="language-js">import Vue from 'core/index'

// ...

// 补丁算法，VNode diff -&gt; DOM
Vue.prototype.__patch__ = inBrowser ? patch : noop

// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el &amp;&amp; inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
</code></pre>
<ul>
<li>mountComponent
<ul>
<li>虚拟 DOM</li>
<li>diff</li>
<li>patch</li>
<li>......</li>
</ul>
</li>
<li>_<em>patch</em>_</li>
</ul>
<p>src/core/index.js</p>
<pre><code class="language-js">import Vue from './instance/index'

initGlobalAPI(Vue)
</code></pre>
<ul>
<li>initGlobalAPI
<ul>
<li>set</li>
<li>delete</li>
<li>nextTick</li>
<li>......</li>
</ul>
</li>
</ul>
<p>src/core/instance/index.js 总算到站了</p>
<pre><code class="language-js">function Vue (options) {
  this._init(options)
}

// 合并参数、初始化 $parent 等属性、初始化事件中心、挂载 h 函数（$createElement）
// 调用生命周期钩子 beforeCreate
// 获取注入的数据、初始化 props、methods、data、computed、watch
// 注入数据处理
// 调用生命周期钩子 created
initMixin(Vue) 
// 实现 $set、$delete、$watch
stateMixin(Vue)
// 实现 $on、$once、$off、$emit
eventsMixin(Vue)
// 实现 _update（调用补丁算法）、$forceUpdate、$destroy
lifecycleMixin(Vue)
// installRenderHelpers
// 实现了 $nextTick、_render(这里调用 $options 上的渲染函数)
renderMixin(Vue)
</code></pre>
<ul>
<li>initMixin
<ul>
<li>initLifecycle</li>
<li>initEvents</li>
<li>initRender</li>
<li>callHook(vm, 'beforeCreate')</li>
<li>initInjections</li>
<li>initState (<a href="https://yuufen.com/blog/post/LGEsZIcVg/">数据响应式细节</a>)</li>
<li>initProvide</li>
<li>callHook(vm, 'created')</li>
</ul>
</li>
<li>stateMixin
<ul>
<li>$set</li>
<li>$delete</li>
<li>$watch</li>
</ul>
</li>
<li>eventsMixin
<ul>
<li>$on</li>
<li>$once</li>
<li>$off</li>
<li>$emit</li>
</ul>
</li>
<li>lifecycleMixin
<ul>
<li>_update（调用补丁算法）</li>
<li>$forceUpdate</li>
<li>$destroy</li>
</ul>
</li>
<li>renderMixin
<ul>
<li>installRenderHelpers</li>
<li>$nextTick</li>
<li>_render(这里调用init挂载的渲染函数)</li>
</ul>
</li>
</ul>
<h2 id="initmixin">initMixin</h2>
<pre><code class="language-js">export function initMixin (Vue: Class&lt;Component&gt;) {
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++

    let startTag, endTag
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // a flag to avoid this being observed
    vm._isVue = true
    // 合并参数
    if (options &amp;&amp; options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') { 
      initProxy(vm) // 设置上下文
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    initLifecycle(vm) // 初始化与当前组件相关的属性（$parent等等）（这时parent已经存在了）
    initEvents(vm) // 初始化事件中心
    initRender(vm) // 定义了 vm.$createElement （render 函数里的 h 函数）
    callHook(vm, 'beforeCreate') // 调用生命周期钩子 beforeCreate
    initInjections(vm) // 获取注入的数据（是响应式的），在 initState 之前
    initState(vm) // 初始化 props、methods、data、computed、watch
    initProvide(vm) // 注入数据处理，在 initState 之后
    callHook(vm, 'created') // 调用生命周期钩子 created

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
</code></pre>
<h3 id="initevents">initEvents</h3>
<pre><code class="language-js">
export function initEvents (vm: Component) {
  vm._events = Object.create(null)
  vm._hasHookEvent = false
  // init parent attached events
  const listeners = vm.$options._parentListeners
  if (listeners) {
    updateComponentListeners(vm, listeners)
  }
}
</code></pre>
<ul>
<li>updateComponentListeners</li>
</ul>
<h3 id="initstate">initState</h3>
<pre><code class="language-js">export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
</code></pre>
<ul>
<li>initProps</li>
<li>initMethods</li>
<li>initData</li>
<li>initComputed</li>
<li>watch</li>
</ul>
<h2 id="statemixin">stateMixin</h2>
<pre><code class="language-js">export function stateMixin (Vue: Class&lt;Component&gt;) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  const dataDef = {}
  dataDef.get = function () { return this._data }
  const propsDef = {}
  propsDef.get = function () { return this._props }
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function () {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      )
    }
    propsDef.set = function () {
      warn(`$props is readonly.`, this)
    }
  }
  // 挂载只读属性
  Object.defineProperty(Vue.prototype, '$data', dataDef)
  Object.defineProperty(Vue.prototype, '$props', propsDef)
  // 挂载了 $set、$delete、$watch
  Vue.prototype.$set = set
  Vue.prototype.$delete = del

  Vue.prototype.$watch = function (...
  }
}
</code></pre>
<h2 id="eventsmixin未完成">eventsMixin（未完成）</h2>
<pre><code class="language-js">export function eventsMixin (Vue: Class&lt;Component&gt;) {
  const hookRE = /^hook:/
  Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component {
    const vm: Component = this
    if (Array.isArray(event)) {
      for (let i = 0, l = event.length; i &lt; l; i++) {
        vm.$on(event[i], fn)
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn)
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true
      }
    }
    return vm
  }

  Vue.prototype.$once = function (event: string, fn: Function): Component {
    const vm: Component = this
    function on () {
      vm.$off(event, on)
      fn.apply(vm, arguments)
    }
    on.fn = fn
    vm.$on(event, on)
    return vm
  }

  Vue.prototype.$off = function (event?: string | Array&lt;string&gt;, fn?: Function): Component {
    const vm: Component = this
    // all
    if (!arguments.length) {
      vm._events = Object.create(null)
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (let i = 0, l = event.length; i &lt; l; i++) {
        vm.$off(event[i], fn)
      }
      return vm
    }
    // specific event
    const cbs = vm._events[event]
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null
      return vm
    }
    // specific handler
    let cb
    let i = cbs.length
    while (i--) {
      cb = cbs[i]
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1)
        break
      }
    }
    return vm
  }

  Vue.prototype.$emit = function (event: string): Component {
    const vm: Component = this
    if (process.env.NODE_ENV !== 'production') {
      const lowerCaseEvent = event.toLowerCase()
      if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) {
        tip(
          `Event &quot;${lowerCaseEvent}&quot; is emitted in component ` +
          `${formatComponentName(vm)} but the handler is registered for &quot;${event}&quot;. ` +
          `Note that HTML attributes are case-insensitive and you cannot use ` +
          `v-on to listen to camelCase events when using in-DOM templates. ` +
          `You should probably use &quot;${hyphenate(event)}&quot; instead of &quot;${event}&quot;.`
        )
      }
    }
    let cbs = vm._events[event]
    if (cbs) {
      cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs
      const args = toArray(arguments, 1)
      const info = `event handler for &quot;${event}&quot;`
      for (let i = 0, l = cbs.length; i &lt; l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info)
      }
    }
    return vm
  }
}
</code></pre>
<h2 id="lifecyclemixin未完成">lifecycleMixin（未完成）</h2>
<pre><code class="language-js">export function lifecycleMixin (Vue: Class&lt;Component&gt;) {
  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this
    const prevEl = vm.$el
    const prevVnode = vm._vnode
    const restoreActiveInstance = setActiveInstance(vm)
    vm._vnode = vnode
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode)
    }
    restoreActiveInstance()
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  }

  Vue.prototype.$forceUpdate = function () {
    const vm: Component = this
    if (vm._watcher) {
      vm._watcher.update()
    }
  }

  Vue.prototype.$destroy = function () {
    const vm: Component = this
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy')
    vm._isBeingDestroyed = true
    // remove self from parent
    const parent = vm.$parent
    if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) {
      remove(parent.$children, vm)
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown()
    }
    let i = vm._watchers.length
    while (i--) {
      vm._watchers[i].teardown()
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--
    }
    // call the last hook...
    vm._isDestroyed = true
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null)
    // fire destroyed hook
    callHook(vm, 'destroyed')
    // turn off all instance listeners.
    vm.$off()
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null
    }
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 源码解析：启动项目与入口文件分析]]></title>
        <id>https://yuufen.com/blog/post/28tbvr2E1/</id>
        <link href="https://yuufen.com/blog/post/28tbvr2E1/">
        </link>
        <updated>2020-03-04T10:40:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="启动项目">启动项目</h2>
<h3 id="获取-vue-项目">获取 Vue 项目</h3>
<p>项目地址：https://github.com/vuejs/vue</p>
<p>当前版本：2.6.11</p>
<h3 id="调试方式">调试方式</h3>
<ol>
<li>浏览器调试（我们选择这一项）</li>
<li>使用拦截器或其他工具</li>
</ol>
<h3 id="调试环境搭建">调试环境搭建</h3>
<ul>
<li>
<p>安装依赖：<code>npm i</code></p>
</li>
<li>
<p>安装 rollup：<code>npm i -g rollup</code></p>
</li>
</ul>
<blockquote>
<p>rollup 是打包工具，用于打包纯代码项目，vue 使用了 rollup 打包</p>
</blockquote>
<ul>
<li>package.json 中修改 dev 脚本，添加 sourcemap，方便调试</li>
</ul>
<pre><code>&quot;dev&quot;: &quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev&quot;,
</code></pre>
<ul>
<li>运行开发版本打包命令：<code>npm run dev</code></li>
<li>在测试用例中引入打包生成的新的 vue.js</li>
</ul>
<blockquote>
<p>然后就可以愉快的打断点调试了</p>
</blockquote>
<h2 id="入口文件分析">入口文件分析</h2>
<h3 id="目录结构">目录结构</h3>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1583685102033.png" alt="" loading="lazy"></figure>
<blockquote>
<p>Vue 源码使用 flow 编写，所以还要额外维护 TypeScript 类型定义，加上 flow 目前已停止维护，所以 vue 3 使用 TypeScript 重写。</p>
</blockquote>
<h3 id="找到入口">找到入口</h3>
<p>package.json 中，main 是 require 的入口，module 是 import 的入口</p>
<pre><code>&quot;main&quot;: &quot;dist/vue.runtime.common.js&quot;,
&quot;module&quot;: &quot;dist/vue.runtime.esm.js&quot;,
</code></pre>
<p>dist 是执行构建脚本<code>&quot;build&quot;: &quot;node scripts/build.js&quot;</code>创建的，所以<code>npm run build</code>执行的是 scripts/build.js。</p>
<pre><code class="language-js">// 获取所有打包配置
let builds = require('./config').getAllBuilds()

// 根据参数过滤掉不需要的
if (process.argv[2]) {
  const filters = process.argv[2].split(',')
  builds = builds.filter(b =&gt; {
    return filters.some(f =&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1)
  })
} else {
  // 过滤掉包含 weex 的配置
  builds = builds.filter(b =&gt; {
    return b.output.file.indexOf('weex') === -1
  })
}

build(builds)
</code></pre>
<p>build.js 中引入了 script/config.js，在里面可以找到各个版本的打包配置。</p>
<blockquote>
<h3 id="术语解释">术语解释</h3>
<p>runtime：仅包含运行时的版本，包含 vue 运行的核心代码，但没有模板编译器，如 vue.runtime.js</p>
<p>umd：Universal Module Definition 规范，用于浏览器的 script 标签，默认包含运行时和编译器，如 vue.js</p>
<p>commonjs：cjs 规范，用于旧版打包器，如 browserify、webpack 1，如 vue.runtime.common.js</p>
<p>esm：ES module 规范，用于现代打包器，如 webpack 2 及以上版本，如 vue.runtime.esm.js</p>
<h3 id="compile-vs-runtime">Compile vs Runtime</h3>
<p>带 compiler 版本支持 template 选项，可以实时编译模板</p>
<p>仅 runtime 版不支持 template，体积小，需要借助 webpack 把 template 解析成 render 函数</p>
</blockquote>
<p>因为我们希望在浏览器中调试，所以查看umd格式的版本。</p>
<pre><code class="language-js">  // Runtime+compiler development build (Browser)
  'web-full-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },
</code></pre>
<p>结合script/alias.js中的别名可以找到入口文件 src/platforms/web/entry-runtime-with-compiler.js</p>
<pre><code class="language-js">// 核心代码在这里
// 扩展默认的 $mount 方法，能够编译 template 或 el 指定的模板
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el &amp;&amp; query(el)

  // 不能挂载到 body 或者 html 上
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`
    )
    return this
  }
  
  // 获取选项
  const options = this.$options
  // 如果 options 上不存在 render 选项，则将 template/el 转化为 render 函数，挂载到 options 上
  // 如果 options 上存在 render，直接渲染
  if (!options.render) {
    let template = options.template
    if (template) {
      // 如果有 template，解析 template 选项
      if (typeof template === 'string') {
        // 如果是字符串 / 模板字符串
        if (template.charAt(0) === '#') {
          // 如果是 '#app' 等 id 选择器，转化为模板字符串
          template = idToTemplate(template)
        }
      } else if (template.nodeType) {
        // 如果是 DOM 元素
        template = template.innerHTML
      }
    } else if (el) {
      //否则解析 el
      template = getOuterHTML(el)
    }
    if (template) {
      // 如果有模板字符串，需要用编译器编译，得到 render 函数
      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns
    }
  }
  // 渲染
  return mount.call(this, el, hydrating)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端性能优化总结]]></title>
        <id>https://yuufen.com/blog/post/xYd9Z_Vfp/</id>
        <link href="https://yuufen.com/blog/post/xYd9Z_Vfp/">
        </link>
        <updated>2020-03-02T06:21:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h2 id="新玩意prepack">新玩意：Prepack</h2>
<p>在编译阶段做预计算<br>
<a href="prepack.io">prepack.io</a></p>
</blockquote>
<h2 id="从输入-url-到显示页面发生了什么">从输入 url 到显示页面，发生了什么？</h2>
<p><strong>从输入 url 到显示页面，发生了什么？</strong></p>
<ol>
<li>用户输入 yuufen.com</li>
<li>浏览器通过 DNS，把 url 解析为 IP</li>
<li>和 IP 地址建立 TCP 连接，发送 HTTP 请求</li>
<li>服务器接收请求，查库，读文件等，拼接好返回的 HTTP 响应</li>
<li>浏览器收到首屏 html，开始渲染</li>
<li>解析 html 为 dom（同时加载额外的 css 和 js）</li>
<li>解析 css 为 css-tree（CSS 选择器从<strong>右</strong>向左过滤查找）</li>
<li>dom + css 生成 render-tree，绘图</li>
</ol>
<p>这是一个万能的面试题，这个题的答案包含着整个互联网运行的过程，我们性能优化的策略就是基于它的答案，针对每一步依次解析，让整体的时间变短。所以有两个大方向：</p>
<ol>
<li>少加载文件</li>
<li>少执行代码</li>
</ol>
<h2 id="雅虎军规">雅虎军规</h2>
<blockquote>
<p>虽然随着 Vue、React、Angular 这些框架的流行，雅虎军规当中一些优化的方法已不在适用，但是，更多的时候，我们是学习这些方法背后的思想，而不是去死记硬背某个方法，技术总是在更迭，只有握方法背后的思想，才能够立于不败之地。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://yuufen.com/blog/post-images/1583615829278.jpg" alt="" loading="lazy"></figure>
<p>https://developer.yahoo.com/performance/rules.html</p>
<p>https://juejin.im/post/5b73ef38f265da281e048e51</p>
<h2 id="性能指标">性能指标</h2>
<blockquote>
<p>抛开场景谈性能优化，都是耍流氓</p>
</blockquote>
<h3 id="performance-api">Performance API</h3>
<p>提到性能优化指标就不得不说 Performance API，首先来看 MDN 上关于这个 API 的 介绍：Performance 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API。该类型的对象可以通过调⽤用只读属性 Window.performance 来获得。</p>
<figure data-type="image" tabindex="2"><img src="https://yuufen.com/blog/post-images/1583740522448.png" alt="" loading="lazy"></figure>
<pre><code class="language-js">const timingInfo = window.performance.timing
console.log({
  TCP连接耗时: timingInfo.connectEnd - timingInfo.connectStart,
  DNS查询耗时: timingInfo.domainLookupEnd - timingInfo.domainLookupStart,
  '获得首字节耗费时间，也叫TTFB': timingInfo.responseStart - timingInfo.navigationStart,
  domReady时间: timingInfo.domContentLoadedEventStart - timingInfo.navigationStart,
  DOM资源下载: timingInfo.responseEnd - timingInfo.responseStart,
})
</code></pre>
<ol>
<li>First Paint(简称 FP)：表示文档中任一元素首次渲染时间。</li>
<li>First Contentful Paint(简称 FCP)：当浏览器首次渲染任何文本，图像（包括背景图像），非白色画布或 SVG 时。这个指标就是我们日常说的白屏时间。</li>
<li>First Meaningful Paint(简称 FMP)：首次有意义的绘制，这个指标反映的是主要内容出现在页面上所需要的时间，如果 FMP 时间过长的话，这里就要考虑是不是静态文件阻塞了主线程。</li>
<li>Time To Interactive(TTI)：可交互时间，等到服务器通过 HTTP 协议将响应全部返回之后，便开始 DOM Tree 的构建，完成之后，网页变成可交互状态，到此为止便是网页的可交互时间。用户可以进行正常的事件输入交互操作，这个指标是最重要的用户体验指标，用户最关心的就是什么时候可以进行交互，所以通常这个指标是我们优化的重点。</li>
</ol>
<h3 id="浏览器-performance-工具">浏览器 Performance 工具</h3>
<h3 id="lighthouse">Lighthouse</h3>
<ul>
<li>安装 chrome 插件 （或者）</li>
<li><code>npm install -g lighthouse</code></li>
</ul>
<pre><code>lighthouse https://yuufen.com/
</code></pre>
<h2 id="网络">网络</h2>
<h3 id="dns">DNS</h3>
<p>prefetch</p>
<figure data-type="image" tabindex="3"><img src="https://yuufen.com/blog/post-images/1583617452917.png" alt="" loading="lazy"></figure>
<h3 id="tcp">TCP</h3>
<h4 id="ip-tcp-http-的关系">IP、TCP、HTTP 的关系</h4>
<ol>
<li>
<p>IP-门牌号，通过 IP 协议找到对应机器</p>
</li>
<li>
<p>TCP 负责数据完整性和有序性，通过三次握手、粘包、滑动窗口等非常庞大的网络协议机制</p>
</li>
<li>
<p>HTTP 负责应用层数据，文件编码、cookie、缓存、数据终止时机等</p>
</li>
</ol>
<h4 id="优化tcp策略">优化（TCP）策略</h4>
<ol>
<li>长连接</li>
<li>减少文件体积
<ol>
<li>js 打包压缩</li>
<li>图片压缩</li>
<li>gzip</li>
</ol>
</li>
<li>减少文件请求次数
<ol>
<li>雪碧图</li>
<li>js、css 打包</li>
<li>缓存控制</li>
<li>懒加载</li>
</ol>
</li>
<li>减少用户和服务器的举例
<ol>
<li>cdn</li>
</ol>
</li>
<li>本地储存</li>
</ol>
<h2 id="图片">图片</h2>
<h3 id="选择合适格式">选择合适格式</h3>
<ol>
<li>PNG</li>
</ol>
<p>png-8 png-24 png-32</p>
<p>logo，颜色简单但对图片质量要求高、精灵图</p>
<ol start="2">
<li>
<p>JPG/JPEG</p>
</li>
<li>
<p>GIF</p>
</li>
<li>
<p>SVG</p>
</li>
</ol>
<p>SVG 图像中的文本时可选取可搜索的。</p>
<p>常用来绘制地图、股票 k 线图</p>
<p>会损耗性能</p>
<ol start="5">
<li>WebP</li>
</ol>
<p>全能的解决方案，但是兼容性不好，需要根据浏览器判断加载格式</p>
<ol start="6">
<li>Base64</li>
</ol>
<p>图片 base64 之后会变大，适合小的矢量图标</p>
<h3 id="其他">其他</h3>
<ol>
<li>图片渐进显示</li>
<li>懒加载</li>
<li>骨架图</li>
</ol>
<h2 id="缓存">缓存</h2>
<p>可以少加载文件</p>
<ol>
<li>cdn 缓存</li>
<li>本地缓存
<ol>
<li>localstorage</li>
<li>indexdb</li>
<li>cookie</li>
</ol>
</li>
<li>浏览器缓存</li>
</ol>
<h3 id="cdn">CDN</h3>
<p>缓存+回源</p>
<p>地理位置更近，新的域名规避 cookie</p>
<h3 id="浏览器缓存">浏览器缓存</h3>
<figure data-type="image" tabindex="4"><img src="https://yuufen.com/blog/post-images/1583741167549.png" alt="" loading="lazy"></figure>
<h4 id="流程">流程</h4>
<ol>
<li>获取文件</li>
<li>文件返回 express 或者 cache-control 设置过期时间，并且带上 etag 或者 lastModfied 字段</li>
<li>再次请求，浏览器先查询 expres 或者 cache-control 是否过期，若没过期，强缓存生效，不发出网络请求，直接使用缓存</li>
<li>若强缓存失效，浏览器会带上 etag 或者 lastModfied 数据，使用 if-none-match 或者 if-Modified-Since 字段，咨询后端是否过期</li>
<li>若没过期，返回 304 状态码，直接用缓存</li>
<li>若过期，状态码 200，返回新资源</li>
</ol>
<h4 id="强缓存">强缓存</h4>
<h5 id="expires">expires</h5>
<p>http 1.0 中</p>
<h5 id="cache-control">Cache-Control</h5>
<p>http 1.1 中</p>
<h4 id="协商缓存">协商缓存</h4>
<h5 id="last-modified-if-modified-since">Last-Modified / If-Modified-Since</h5>
<p>标注时间（只能精确到秒）</p>
<h5 id="etag-if-none-match">Etag / If-None-Match</h5>
<p>根据文件内容计算 hash</p>
<h3 id="webpack-打包和缓存的关系">webpack 打包和缓存的关系</h3>
<p>通过 hash 来判断是否有更新：</p>
<ol>
<li>hash：整个项目相关的 hash</li>
<li>chunkhash：入口文件依赖的 chunkhash</li>
<li>contenthash：文件内容的 hash</li>
</ol>
<h3 id="其他-2">其他</h3>
<ol>
<li>memory cache 内存缓存，比如储存在变量里，关闭 tab 就没了</li>
<li>Disk cache 硬盘上的缓存</li>
<li>Push cache 推送缓存 http2</li>
<li>service worker 浏览器背后的独立进程</li>
</ol>
<h2 id="渲染">渲染</h2>
<h3 id="浏览器渲染原理">浏览器渲染原理</h3>
<p>经典文章 how browser works</p>
<p>https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</p>
<figure data-type="image" tabindex="5"><img src="https://yuufen.com/blog/post-images/1583741367851.png" alt="" loading="lazy"></figure>
<p>首先是解析 HTML。这个过程主要是把 HTML 文档解析为 DOM 树的过程，如果遇到&lt;script&gt;标签，则会停止解析，先执行标签当中的 JavaScript；如果是外联方式，也需要等待下载并执行完对应的 JavaScript 代码，然后才能继续执行解析 HTML 的工作。HTML 解析完成后触发 DOMContentLoaded 事件，这里我们就可以操作 DOM 了。</p>
<p>生成对应的 DOM 树结构：</p>
<figure data-type="image" tabindex="6"><img src="https://yuufen.com/blog/post-images/1583741376936.png" alt="" loading="lazy"></figure>
<p>同时会解析 CSS。解析 HTML 和解析 CSS 是并行处理的，不然会造成渲染的内容没有对应的样式。解析 CSS 遇到&lt;script&gt;标签和上面解析 HTML 的处理方式是一样的。CSS 解析器将 CSS 解析成 CSSStyleSheet（也被叫做 CSSOM 树），和 DOM 树结构类似。</p>
<p>CSSOM 树：</p>
<figure data-type="image" tabindex="7"><img src="https://yuufen.com/blog/post-images/1583741498395.png" alt="" loading="lazy"></figure>
<p>DOM 树和 CSSOM 树一起附着合成渲染树（Render Tree）：</p>
<figure data-type="image" tabindex="8"><img src="https://yuufen.com/blog/post-images/1583741581016.png" alt="" loading="lazy"></figure>
<p>图中左侧为 DOM 树，右侧是 Render 树，可以看到 Render 树结构与 DOM 树是非常相似的，但不是一一对应的。每一个节点是一个 Render Object，包含了我们在样式表中设置的样式，样式的宽高和具体位置是通过 Layout (重排)计算得出。</p>
<blockquote>
<h4 id="tips">Tips</h4>
<p>元素如果被设置为 <code>display:none</code>，在 DOM 树中依然会显示，但是在 Render 树中不会显示；元素如果被设置为 <code>visibility:none</code>，那么 DOM 树和 Render 树中都会显示；我们经常说的脱离⽂文档流，其实就是脱离 Render Tree。</p>
</blockquote>
<h3 id="白屏应对">白屏应对</h3>
<h4 id="骨架屏">骨架屏</h4>
<h5 id="自动化方案">自动化方案</h5>
<ul>
<li>page-skeleton-webpack-plugin</li>
<li>antd 的 skeleton 组件</li>
</ul>
<h3 id="dom-性能优化">DOM 性能优化</h3>
<p>少操作 dom，使用 fragment, 虚拟 dom</p>
<h3 id="回流重绘">回流重绘</h3>
<figure data-type="image" tabindex="9"><img src="https://yuufen.com/blog/post-images/1583741388259.png" alt="" loading="lazy"></figure>
<h3 id="event-loop">event-loop</h3>
<h4 id="流程-2">流程</h4>
<figure data-type="image" tabindex="10"><img src="https://yuufen.com/blog/post-images/1583742431195.png" alt="" loading="lazy"></figure>
<h4 id="macrotask宏任务-microtask微任务">Macrotask（宏任务） / Microtask（微任务）</h4>
<p>上面我们提到了任务队列，那么任务队列有两种，一种是 Macrotask，另外一种是 Microtask。从最开始我给出的 Event Loop 总的流程图，大家可以看出 Microtask 优先级是高于 Macrotask 的。Microtask 当中的任务也是在执行栈当中的任务执行完成后再进行执行，执行的时候和 Macrotask 有一些区别，Microtask 当中任务不会一个⼀一个压入执⾏行行栈，而是所有任务直接压入栈中， 当 Microtask 当中的任务执行完毕后，然后我们再从 Macrotask 中取栈顶的第一个任务进行执行。</p>
<p>那么哪些任务属于 Microtask，哪些任务属于 Macrotask 呢，这里有一个大概的总结：</p>
<ul>
<li><strong>Macrotask</strong>：</li>
</ul>
<p>setTimeout、setInterval、I/O、UI Rendering、script 当中的所有代码、 setImmediate(Node)</p>
<ul>
<li><strong>Microtask</strong>：</li>
</ul>
<p>process.nextTick(node) 、Promise 、MutationObserver</p>
<blockquote>
<p>Microtask 当中各种任务的优先级如下： process.nextTick &gt; Promise &gt; MutationOberse</p>
</blockquote>
<blockquote>
<p>批量更新，可以利用 event-loop，在当前数据修改之后，汇总数据，统一修改，如 React 的<code>setState</code></p>
</blockquote>
<h2 id="防抖节流">防抖节流</h2>
<h3 id="节流">节流</h3>
<pre><code class="language-js">function throttle(fn, wait = 500) {
  let lastTime = 0
  return function(...args) {
    let now = new Date()
    if (now - lastTime &gt; wait) {
      lastTime = now
      fn(...args)
    }
  }
}
window.onscroll = throttle(function() {
  console.log('懒加载判定、显示回到顶部判定……')
})
</code></pre>
<h3 id="防抖">防抖</h3>
<pre><code class="language-js">function debounce(fn, wait = 500) {
  let timer = 0
  return function(...arg) {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() =&gt; {
      fn(...arg)
    }, wait)
  }
}

window.onscroll = debounce(function() {
  console.log('懒加载判定、显示回到顶部判定……')
})
</code></pre>
<h2 id="懒加载">懒加载</h2>
<h3 id="图片懒加载">图片懒加载</h3>
<pre><code class="language-html">&lt;body&gt;
  &lt;div id=&quot;container&quot;&gt;
    &lt;div class=&quot;img-container&quot;&gt;
      &lt;img
        data-src=&quot;https://i0.hdslb.com/bfs/album/8e10328d8a35d3acb957bb521170711d02fdece8.jpg@518w_1e_1c.jpg&quot;
        alt=&quot;&quot;
      /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;img-container&quot;&gt;
      &lt;img data-src=&quot;https://i0.hdslb.com/bfs/album/3f9b4b9f8a91806c1daf2ab187f2faec8174d7ae.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;img-container&quot;&gt;
      &lt;img
        data-src=&quot;https://i0.hdslb.com/bfs/album/f14aec7ef14f0c95d359914e0927f9e1f1c3625b.png@518w_1e_1c.png&quot;
        alt=&quot;&quot;
      /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script&gt;
    const imgs = document.querySelectorAll('img')
    // 获取可视区域高度
    const viewHeight = window.innerHeight || window.documentElement.clientHeight
    console.log(viewHeight, imgs)
    num = 0
    function loadImg() {
      for (let i = 0; i &lt; imgs.length; i++) {
        console.log(imgs[i].getBoundingClientRect().top)
        let dis = viewHeight - imgs[i].getBoundingClientRect().top
        if (dis &gt; 0) {
          imgs[i].src = imgs[i].getAttribute('data-src')
          num = i + 1
        }
      }
    }
    loadImg()
    // 节流
    window.addEventListener(
      'scroll',
      (function(fn, wait = 500) {
        let lastTime = 0
        return function(...args) {
          let now = new Date()
          if (now - lastTime &gt; wait) {
            lastTime = now
            fn(...args)
          }
        }
      })(loadImg),
    )
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="组件路由懒加载">组件（路由）懒加载</h3>
<p>webpack</p>
<h2 id="服务端渲染-同构">服务端渲染 &amp;&amp; 同构</h2>
<ol>
<li>服务端渲染，就是在服务端解析首屏的组件，产出 HTML，直接返回</li>
<li>如果用户跳转页面，同构。整个应用有两个入口：
<ol>
<li>server-entry 首次进入的入口，使用 ssr</li>
<li>用户点击跳转，如果是单页应用，点击不刷新，走 js 单页入口，或者客户端渲染入口</li>
</ol>
</li>
</ol>
<h2 id="移动端优化">移动端优化</h2>
<p>svg、虚拟列表、300ms 延迟（禁用缩放解决）</p>
<p>https://bvaughn.github.io/react-virtualized/#/components/List</p>
<h3 id="vue">Vue</h3>
<p>async-component、v-if / v-show</p>
<h3 id="react">React</h3>
<p>purecomponent、suspense</p>
<h2 id="webpack">webpack</h2>
<ul>
<li>可视化优化</li>
</ul>
<pre><code class="language-js">const BundleAnalyzerPlugin = require('webpack-bundleanalyzer').BundleAnalyzerPlugin

module.exports = {
  plugins: [new BundleAnalyzerPlugin()],
}
</code></pre>
<ul>
<li>tree-shaking 删除冗余代码</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见设计模式总结]]></title>
        <id>https://yuufen.com/blog/post/_lKjmwEdd/</id>
        <link href="https://yuufen.com/blog/post/_lKjmwEdd/">
        </link>
        <updated>2020-02-27T06:51:31.000Z</updated>
        <content type="html"><![CDATA[<p>创建设计模式：单例、工厂、建造者</p>
<p>结构化设计模式：代理、装饰器、外观、享元、适配器、</p>
<p>行为型：观察者、策略、中介者、迭代器、责任链、模板方法、备忘录</p>
<p>vue &amp; element / react &amp; redux 的源码值得学习</p>
<h2 id="pub-sub订阅-发布模式观察者模式">pub / sub（订阅 / 发布模式，观察者模式）</h2>
<h3 id="优点">优点</h3>
<p>解耦，降低代码入侵性</p>
<pre><code class="language-js">原始：
ModuleA
  import B
  B.action()
ModuleB
  action() {
    import C
    C.action()
  }
ModuleC
  action() {
    doSomething()
  }
观察者：
Event
ModuleA
event.emit()
ModuleB
  event.emit()ModuleBevent.on()
event.emit()
ModuleC
  event.emit()ModuleCevent.on()
</code></pre>
<h3 id="目标-实现">目标 &amp; 实现</h3>
<p>参考 vue</p>
<pre><code class="language-js">// 实现：
class Event {
  constructor() {
    this.callback = {}
  }
  $on(name, fn) {
    ;(this.callback[name] || (this.callback[name] = [])).push(fn)
  }
  $emit(name, ...args) {
    const cbs = this.callback[name]
    if (cbs) {
      cbs.forEach((cb) =&gt; {
        cb.call(this, ...args)
      })
    }
  }
  $off(name) {
    this.callback[name] = null
  }
}
// 目标：
let event = new Event()
// 监听
event.on('event1', (...args) =&amp;gt; {
  console.log('event1', ...args)
})
event.on('event1', (...args) =&gt; {
console.log('event1 again', ...args)
})
// 触发
event.emit('event1', 1, 2, 3)
// 解绑
console.log('-'.repeat(20))
event.emit(′event1′,1,2,3)//解绑console.log(′−′.repeat(20))event.off('event1')
event.$emit('event1', 1, 2, 3) // 测试
</code></pre>
<h2 id="单例模式">单例模式</h2>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h3 id="适用场景">适用场景</h3>
<p>如：</p>
<ol>
<li>弹窗，无论点击多少次都只被创建一次。</li>
<li>redux 的 store，全局唯一</li>
</ol>
<h3 id="简单举例">简单举例</h3>
<pre><code class="language-js">// 新建弹窗，期望弹窗全局唯一
// 伪代码:
// function createModalLayer() {
//   // 闭包储存单例实例
//   let result
//   return function() {
//     return result || (result = 新建弹窗)
//   }
// }
// 提取：
// 高阶函数：
function getSingle(fn) {
  let result
  return function() {
    return result || (result = fn.apply(this, arguments))
  }
}
function createModalLayer() {
  console.log('新建弹窗')
  const div = document.createElement('div')
  div.innerHTML = new Date()
  div.className = 'modal'
  div.style.display = 'none'
  document.body.appendChild(div)
  div.addEventListener(
    'click',
    function() {
      div.style.display = 'none'
    },
    false,
  )
  return div
}
createModalLayer = getSingle(createModalLayer)
document.getElementById('modal-btn').addEventListener('click', function() {
  // 新建弹窗
  const modalLayer = createModalLayer()
  modalLayer.style.display = 'block'
})
</code></pre>
<h2 id="策略模式">策略模式</h2>
<h3 id="分析">分析</h3>
<p>KISS 原则 keep it simple and stupid</p>
<p>策略模式指定义一系列算法，把他们一个个封装起来，并使他们可以相互替换。</p>
<p>目的是将算法的使用和实现分离。</p>
<p>一个基于策略模式的程序至少由两部分组成。第一部分是一组策略类（可变），封装了具体的算法，负责具体的计算过程；第二部分是环境类 Context（不变），Context 接收客户的请求，随后将请求委托给某一个策略类。要做到这一点，说明 Context 中要维持对某个策略对象的引用。</p>
<h3 id="举例">举例</h3>
<p>原始（面条式代码）：</p>
<pre><code class="language-js">let form = 获取表单
form.onSubmit = function() {
  if (form.name.value === '') {
    弹出错误消息
  }
  if (form.password.value === '') {
    弹出错误消息
  }
  if (form.password.value.length &lt; 5) {
    弹出错误消息
  }
  正则等等
}
</code></pre>
<p>策略模式（具体看 element 的表单验证 https://github.com/ElemeFE/element/blob/dev/packages/form/src/form.vue ），其他例子：</p>
<pre><code class="language-js">// 1. 策略
// 可以使用配置
const policy = {
  S: function(salary) {
    return salary * 4
  },
  A: function(salary) {
    return salary * 3
  },
  B: function(salary) {
    return salary * 2
  },
  C: function(salary) {
    return salary
  },
}
// 2. 使用
function calculate(level, salary) {
  return policy[level] ? policy[level](salary) : 0
}
</code></pre>
<h2 id="代理模式">代理模式</h2>
<p>定义：为一个对象提供一个占用品或占位符，以便控制对它的访问。</p>
<p>常用的虚拟代理形式：某花销很大的操作，可通过虚拟代理的方式延迟到需要它的时候再创建（如使用虚拟代理实现图片懒加载）。</p>
<h3 id="适用场景-2">适用场景</h3>
<ol>
<li>图片懒加载的方式：先通过一张 loading 图占位，然后同通过异步的方式加载图片，等图片加载好了再把完成的图片加载到 img 标签里面。</li>
</ol>
<pre><code class="language-js">// 给图片实例一个setSrc方法，先设置loading，再显示图片
const imgFunc = (function() {
  let imgNode = document.createElement('img')
  document.body.appendChild(imgNode)
  return {
    setSrc: function(src) {
      // 耗时
      imgNode.src = src
    },
  }
})()
// 使用代理模式，增加 loading
const proxyImage = (function() {
  let img = new Image()
  // 加载完毕，再设置
  img.onload = function() {
    setTimeout(() =&gt; {
      imgFunc.setSrc(this.src)
    }, 500)
  }
  return {
    setSrc(src) {
      // 先设置 loading
      imgFunc.setSrc('loading.gif')
      img.src = src
    },
  }
})()
proxyImage.setSrc('https://yuufen.com/album/photography/2.jpg')
</code></pre>
<ol>
<li>通过一个代理函数收集一段时间之内的请求，最后一次性发送给服务器。</li>
</ol>
<pre><code class="language-js">var synchronousFile = function(id) {
  console.log('开始同步⽂文件，id 为: ' + id)
}
var proxySynchronousFile = (function() {
  var cache = [], // 保存⼀一段时间内需要同步的 ID
    timer // 定时器
  return function(id) {
    cache.push(id)
    if (timer) {
      // 保证不不会覆盖已经启动的定时器器
      return
    }
    timer = setTimeout(function() {
      synchronousFile(cache.join(','))
      clearTimeout(timer) // 清空定时器器
      timer = null
      cache.length = 0 // 清空 ID 集合
    }, 2000)
  } // 2 秒后向本体发送需要同步的 ID 集合
})()
var checkbox = document.getElementsByTagName('input')
for (var i = 0, c; (c = checkbox[i++]); ) {
  c.onclick = function() {
    if (this.checked === true) {
      proxySynchronousFile(this.id)
    }
  }
}
</code></pre>
<ol>
<li>函数的防抖节流。</li>
<li>React 的 CSS 代理。</li>
</ol>
<h2 id="中介者模式">中介者模式</h2>
<p>如 redux / vuex，把共享的数据抽离成一个单独的 store，每个都通过 store 这个中介来操作对象。</p>
<p>适用场景：如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等，都会触发 change 事件。</p>
<p>通过中介者来转发处理这些事件，实现各个事件之间的解耦，仅仅维护中介者对象即可。</p>
<h2 id="装饰器模式">装饰器模式</h2>
<h3 id="和代理模式的异同">和代理模式的异同</h3>
<p>两种模式都描述了怎样为对象提供一定程度上的间接引用，他们的实现部分都保留了对另外一个对象的引用，并且向那个对象发送请求。</p>
<p>代理模式和装饰器模式最重要的区别在于它们的意图和设计目的。</p>
<p>代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。</p>
<p>装饰器模式的作用则是为对象动态的加入行为。</p>
<h3 id="举例-2">举例</h3>
<p>如 React 的高阶组件</p>
<pre><code class="language-js">import React from 'react'
// 统计渲染日志
const withLog = (Component) =&gt; {
  class NewComponent extends React.Component {
    componentWillMount() {
      console.time('componentRender')
    }
    render() {
      return &lt;Component {...this.props}&gt;&lt;/Component&gt;
    }
    componentDidMount() {
      console.timeEnd('componentRender')
    }
  }
  return NewComponent
}
export {withLog}
// 装饰
@withLog
class XXX
// 或者
// class XXX
// XXX = withLog(XXX)
</code></pre>
<pre><code class="language-js">// 依此可以在配置文件中实现统一配置
Function.prototype.before = function(beforefn) {
  var __self = this // 保存对原函数的引用
  return function() {
    //返回包含原函数和新函数的“代理”函数
    beforefn.apply(this, arguments) // 新函数在原函数之前执行，并保证 this 不被劫持
    return __self.apply(this, arguments) // 返回原函数的执行结构，并保证 this 不被劫持
  }
}
Function.prototype.after = function(afterfn) {
  var __self = this
  return function() {
    var ret = __self.apply(this, arguments)
    afterfn.apply(this, arguments)
    return ret
  }
}
</code></pre>
<h2 id="外观模式">外观模式</h2>
<p>涉及到兼容性、参数支持多格式等，对外暴露统一的 API，内部判断实现。让 API 更精简。</p>
<h2 id="工厂模式">工厂模式</h2>
<p>提供创建对象的接口，把成员对象的创建工作转交给一个外部对象。好处在于消除对象之间的耦合（也就是相互影响）。常见的例子：弹窗、Message，对外提供 api，调用 api 新建一个弹窗或者 Message 的实例。</p>
<h3 id="举例-3">举例</h3>
<p>https://github.com/ElemeFE/element/blob/dev/packages/notification/src/main.js</p>
<h2 id="建造者模式-builder">建造者模式 builder</h2>
<p>和工厂模式相比，参与了更多或更复杂的创建的过程。</p>
<pre><code class="language-js">var Person = function(name, work) {
  var _person = new Human()
  _person.name = new Named(name)
  _person.work = new Work(work)
  return _person
}
var person = new Person('Ming', 'code')
console.log(person)
</code></pre>
<h2 id="迭代器模式">迭代器模式</h2>
<blockquote>
<p>迭代器器模式是指提供⼀种⽅法顺序访问⼀个聚合对象中的各个元素，⽽又不要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来,在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素</p>
</blockquote>
<p>each、map 等等等等太多了</p>
<pre><code class="language-js">var each = function(ary, callback) {
  for (var i = 0, l = ary.length; i &lt; l; i++) {
    callback.call(ary[i], i, ary[i])
  }
}
each([1, 2, 3], function(i, n) {
  alert([i, n])
})
</code></pre>
<h2 id="享元模式">享元模式</h2>
<blockquote>
<p>享元(ﬂyweight)模式是⼀种用于性能优化的模式，“ﬂy”在这⾥是苍蝇的意思，意为蝇量级。享元模式的核⼼是运⽤共享技术来有效⽀持⼤量细粒度的对象。 如果系统中因为创建了⼤量类似的对象而导致内存占用过高，享元模式就非常有⽤了。在 JavaScript 中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件⾮常有意义的事情。</p>
</blockquote>
<p>比如只创建少数弹窗对象，动态修改弹窗内容。</p>
<ul>
<li>内部状态储存于对象内部 （如弹窗的位置、border 等）</li>
<li>内部状态可以被一些对象共享</li>
<li>内部状态独立于具体的场景，通常不会改变</li>
<li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享 （如弹窗文案）</li>
</ul>
<h2 id="责任链模式">责任链模式</h2>
<ul>
<li>中间件机制</li>
</ul>
<blockquote>
<p>使多个对象都有机会处理请求，从⽽避免请求的发送者和接收者之间的耦合关系， 将这些对象连成一条链，并沿着这条链传递该请求，直到有⼀个对象处理它为止。 职责链模式的名字⾮常形象，⼀系列可能会处理请求的对象被连接成一条链，请求在这些对象之间依次传递，直到遇到⼀个 可以处理它的对象，我们把这些对象称为链中的节点</p>
</blockquote>
<ul>
<li>假设我们负责⼀个售卖⼿手机的电商网站，经过分别交纳 500 元定金和 200 元定金的两轮预定后(订单已在此时生成)，现在已经到了正式购买的阶段。 公司针对⽀付过定金的用户有一定的优惠政策。在正式购买后，已经支付过 500 元定金的用户会收到 100 元的商城优惠券，200 元定金的用户可以收到 50 元的优惠券，而之前没有支付定金的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况下，不一定保证能买到。</li>
<li>比起 if 嵌套，我们可以先把 500 元订单、200 元订单以及普通购买分成 3 个函数。接下来把 orderType、pay、stock 这 3 个字段当作参数传递给 500 元订单函数，如果该函数不符合处理条件，则把这个请求传递给后面的 200 元订单函数，如果 200 元订单函数依然不能处理该请求，则继续传递请求给普通购买函数</li>
<li>这样我们可以自由灵活地增加、移除和修改链中的节点顺序，假如某天网站运营人员 又想出了支持 300 元定金购买，那我们就在该链中增加⼀个节点即可</li>
</ul>
<pre><code class="language-js">var order500 = function(orderType, pay, stock) {
  if (orderType === 1 &amp;&amp; pay === true) {
    console.log('500 元定金预购，得 100 元优惠')
  } else {
    return 'nextSuccessor' // 我不知道下个节点是什么，反正把请求往后传
  }
}
var order200 = function(orderType, pay, stock) {
  if (orderType === 2 &amp;&amp; pay === true) {
    console.log('200 元定金预购，得 50 元优惠')
  } else {
    return 'nextSuccessor' // 我不知道下个节点是什么，反正把请求往后传
  }
}
var orderNormal = function(orderType, pay, stock) {
  if (stock &gt; 0) {
    console.log('普通购买')
  } else {
    console.log('没库存了')
  }
}
// Chain.prototype.setNextSuccessor 指定在链中的下一个节点
// Chain.prototype.passRequest 传递请求给某个节点
var Chain = function(fn) {
  this.fn = fn
  this.successor = null
}
Chain.prototype.setNextSuccessor = function(successor) {
  return (this.successor = successor)
}
Chain.prototype.passRequest = function() {
  var ret = this.fn.apply(this, arguments)
  if (ret === 'nextSuccessor') {
    return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments)
  }
  return ret
}
var chainOrder500 = new Chain(order500)
var chainOrder200 = new Chain(order200)
var chainOrderNormal = new Chain(orderNormal)
chainOrder500.setNextSuccessor(chainOrder200)
chainOrder200.setNextSuccessor(chainOrderNormal)
chainOrder500.passRequest(1, true, 500) // 500 元定金预购，得 100 元优惠
chainOrder500.passRequest(2, true, 500) // 200 元定金预购，得 50 元优惠
chainOrder500.passRequest(3, true, 500) // 普通购买
chainOrder500.passRequest(1, false, 0) // 没库存了
</code></pre>
<p>koa 源码还将整个链条合并为一个函数。</p>
<h2 id="适配器模式">适配器模式</h2>
<blockquote>
<p>适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。 适配器的别名是包装器(wrapper)，这是一个相对简单的模式。在程序开发中有许多这样的场景：当我们试图调用模块或者对象的某个接口 时，却发现这个接口的格式并不符合目前的需求。 这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模块很复杂，或者我们拿到的模块是一段别人编写的经过压缩的代码， 修改原接口就显得不太现实了。第二种办法是创建一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。</p>
</blockquote>
<p>如 JSON，数据交换的格式，多语言间数据交换的解决方案。</p>
<p>适配器不关心接口是怎么实现的，会怎样演化，也不改变已有接口。</p>
<p>装饰器模式和代理模式也不会改变原有对象的接口，但装饰器的作用是给对象增加功能，常常形成一条长的装饰链；而适配器模式通常只包装一次；代理模式是为了控制对对象的访问，通常也只包装一次。</p>
<p>外观模式的作用与适配器较相似，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。</p>
<pre><code class="language-js">var googleMap = {
  show: function() {},
}
var baiduMap = {
  display: function() {},
}
var baiduMapAdapter = {
  show: function() {
    return baiduMap.display()
  },
}
renderMap(googleMap)
renderMap(baiduMapAdapter)
</code></pre>
<h2 id="模板方法模式">模板方法模式</h2>
<blockquote>
<p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤的实现延迟到子类中。模板方法 使得子类可以在不改变算法结构的情况下，重新定义算法中某些步骤的具体实现</p>
</blockquote>
<p>如插槽（vue 中的 slot、react 中的 children）</p>
<pre><code class="language-js">class Parent {
  constructor() {}
  render() {
    ;&lt;div&gt;
      &lt;div&gt;{this.props.children}&lt;/div&gt;
    &lt;/div&gt;
  }
}
class Stage {
  constructor() {}
  render() {
    // 在 Parent 中已经设定了 children 的渲染位置算法
    ;&lt;Parent&gt;
      // children 的具体实现
      &lt;div&gt;child&lt;/div&gt;
    &lt;/Parent&gt;
  }
}
</code></pre>
<h2 id="备忘录模式">备忘录模式</h2>
<p>可以恢复对象到之前的某个状态。</p>
<p>如 react 或 redux 的时间旅行。</p>
<p>https://zh-hans.reactjs.org/tutorial/tutorial.html#implementing-time-travel</p>
]]></content>
    </entry>
</feed>