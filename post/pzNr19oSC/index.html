<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>JS事件循环、Promise详解 | YuuFen</title>
<link rel="shortcut icon" href="https://yuufen.com/blog/favicon.ico?v=1583135433497">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://yuufen.com/blog/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="JS事件循环、Promise详解 | YuuFen - Atom Feed" href="https://yuufen.com/blog/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="https://juejin.im/post/5b73d7a6518825610072b42b
https://juejin.im/post/5dc028dcf265da4d4b5fe94f
1 5 6 2 3 4 7 8 9
consol..." />
    <meta name="keywords" content="JS" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://yuufen.com/blog">
  <img class="avatar" src="https://yuufen.com/blog/images/avatar.png?v=1583135433497" alt="">
  </a>
  <h1 class="site-title">
    YuuFen
  </h1>
  <p class="site-description">
    希望你可以记住我
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/yuuFen" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
        <a href="https://twitter.com/Dob789" target="_blank">
          <i class="ri-twitter-line"></i>
        </a>
      
    
      
        <a href="https://weibo.com/u/6625495890" target="_blank">
          <i class="ri-weibo-line"></i>
        </a>
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              JS事件循环、Promise详解
            </h2>
            <div class="post-info">
              <span>
                2020-02-27
              </span>
              <span>
                7 min read
              </span>
              
                <a href="https://yuufen.com/blog/tag/clJDbkZpQ/" class="post-tag">
                  # JS
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>https://juejin.im/post/5b73d7a6518825610072b42b<br>
https://juejin.im/post/5dc028dcf265da4d4b5fe94f</p>
<p>1 5 6 2 3 4 7 8 9</p>
<pre><code class="language-js">console.log('1')

setTimeout(() =&gt; {  //  宏任务
    console.log('2')
    new Promise((resolve) =&gt; {  // 同步
        console.log('3')
        resolve()
    }).then(() =&gt; {  // 微任务
        console.log('4')
    })
})

new Promise((resolve) =&gt; {  //同步
    console.log('5')
    resolve()
}).then(() =&gt; {  // 微任务
    console.log('6')
})

setTimeout(() =&gt; {  // 宏任务
    console.log('7')
    new Promise((resolve) =&gt; {  // 同步
        console.log('8')
        resolve()
    }).then(() =&gt; {  // 微任务
        console.log('9')
    })
})
</code></pre>
<hr>
<pre><code class="language-js">new Promise((resolve, reject) =&gt; {
  console.log(&quot;外部promise&quot;);
  resolve();
})
  .then(() =&gt; {
    console.log(&quot;外部第一个then&quot;);
    return new Promise((resolve, reject) =&gt; {
      console.log(&quot;内部promise&quot;);
      resolve();
    })
    .then(() =&gt; {
    console.log(&quot;内部第一个then&quot;);
    })
    .then(() =&gt; {
    console.log(&quot;内部第二个then&quot;);
    });
  })
  .then(() =&gt; {
    console.log(&quot;外部第二个then&quot;);
  });

// 外部promise
// 外部第一个then
// 内部promise
// 内部第一个then
// 内部第二个then
// 外部第二个then
</code></pre>
<pre><code class="language-js">new Promise((resolve, reject) =&gt; {
  console.log(&quot;外部promise&quot;);
  resolve();
})
  .then(() =&gt; {
    console.log(&quot;外部第一个then&quot;);
    new Promise((resolve, reject) =&gt; {
      console.log(&quot;内部promise&quot;);
      resolve();
    })
      .then(() =&gt; {
        console.log(&quot;内部第一个then&quot;);
      })
      .then(() =&gt; {
        console.log(&quot;内部第二个then&quot;);
      });
  })
  .then(() =&gt; {
    console.log(&quot;外部第二个then&quot;);
  });

// 外部promise
// 外部第一个then
// 内部promise
// 内部第一个then
// 外部第二个then
// 内部第二个then
</code></pre>
<pre><code class="language-js">new Promise((resolve, reject) =&gt; {
  console.log(&quot;外部promise&quot;);
  resolve();
})
  .then(() =&gt; {
    console.log(&quot;外部第一个then&quot;);
    let p = new Promise((resolve, reject) =&gt; {
      console.log(&quot;内部promise&quot;);
      resolve();
    })
    p.then(() =&gt; {
        console.log(&quot;内部第一个then&quot;);
      })
    p.then(() =&gt; {
        console.log(&quot;内部第二个then&quot;);
      });
  })
  .then(() =&gt; {
    console.log(&quot;外部第二个then&quot;);
  });

// 外部promise
// 外部第一个then
// 内部promise
// 内部第一个then
// 内部第二个then
// 外部第二个then
</code></pre>
<pre><code class="language-js">let p = new Promise((resolve, reject) =&gt; {
  console.log(&quot;外部promise&quot;);
  resolve();
})
p.then(() =&gt; {
    console.log(&quot;外部第一个then&quot;);
    new Promise((resolve, reject) =&gt; {
      console.log(&quot;内部promise&quot;);
      resolve();
    })
      .then(() =&gt; {
        console.log(&quot;内部第一个then&quot;);
      })
      .then(() =&gt; {
        console.log(&quot;内部第二个then&quot;);
      });
  })
p.then(() =&gt; {
    console.log(&quot;外部第二个then&quot;);
  });
  
// 外部promise
// 外部第一个then
// 内部promise
// 外部第二个then
// 内部第一个then
// 内部第二个then
</code></pre>
<pre><code class="language-js">new Promise((resolve, reject) =&gt; {
  console.log(&quot;外部promise&quot;);
  resolve();
})
  .then(() =&gt; {
    console.log(&quot;外部第一个then&quot;);
    new Promise((resolve, reject) =&gt; {
      console.log(&quot;内部promise&quot;);
      resolve();
    })
      .then(() =&gt; {
        console.log(&quot;内部第一个then&quot;);
      })
      .then(() =&gt; {
        console.log(&quot;内部第二个then&quot;);
      });
    return new Promise((resolve, reject) =&gt; {
      console.log(&quot;内部promise2&quot;);
      resolve();
    })
      .then(() =&gt; {
        console.log(&quot;内部第一个then2&quot;);
      })
      .then(() =&gt; {
        console.log(&quot;内部第二个then2&quot;);
      });
  })
  .then(() =&gt; {
    console.log(&quot;外部第二个then&quot;);
  });

// 外部promise
// 外部第一个then
// 内部promise
// 内部promise2
// 内部第一个then
// 内部第一个then2
// 内部第二个then
// 内部第二个then2
// 外部第二个then
</code></pre>
<h2 id="promisea-和-webkit-的-promise-的实现差异">Promise/A+ 和 webkit 的 Promise 的实现差异</h2>
<pre><code class="language-js">new Promise((resolve, reject) =&gt; {
  console.log('外部promise');
  resolve();
})
  .then(() =&gt; {
    console.log('外部第一个then');
    new Promise((resolve, reject) =&gt; {
      console.log('内部promise');
      resolve();
    })
      .then(() =&gt; {
        console.log('内部第一个then');
        return Promise.resolve();
      })
      .then(() =&gt; {
        console.log('内部第二个then');
      })
  })
  .then(() =&gt; {
    console.log('外部第二个then');
  })
  .then(() =&gt; {
    console.log('外部第三个then');
  })
</code></pre>
<h3 id="promisea-的实现">Promise/A+ 的实现：</h3>
<p>执行 return Promise.resolve() ，创建一个 Promise 实例，将 Promise 实例设置为 resolve 状态，这个 Promise.resolve() 是同步的，且该 Promise 已经完成了，所以他并不会影响到其他 then 的注册。所以上述我们分析是完全正确的。<br>
如下是 Promise.resolve 的实现，我们发现，完全是同步的，所以不影响最终结果。</p>
<pre><code class="language-js">Promise.resolve = function (value) {
  if (value instanceof Promise) return value;
  if (value === null) return NULL;
  if (value === undefined) return UNDEFINED;
  if (value === true) return TRUE;
  if (value === false) return FALSE;
  if (value === 0) return ZERO;
  if (value === '') return EMPTYSTRING;
  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then;
      if (typeof then === 'function') {
        return new Promise(then.bind(value));
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex);
      });
    }
  }
  return valuePromise(value);
};
</code></pre>
<h3 id="promise-的-浏览器webkit的实现">Promise 的 浏览器(webkit)的实现：</h3>
<p>执行 return Promise.resolve() ，创建一个 Promise 实例，执行 resolve ，此时将该 Promise 的 resolve 的 value（这里是undefined） 进入微任务队列，将该 Promise 的状态扭转为 resolve。然后接着执行了之前注册好的 &quot;外部第二个then&quot; ,然后注册 “外部第三个then” ，接着执行 “内部第一个then” 的 return 的 resolve 的这个 undefined value 的 Promise，执行完成之后，然后注册下一个then ,但是没有下一个 then 了，执行完成，整个 return 任务完成，本次同步任务也执行完成，接着执行注册的 “外部第三个then” ，执行完成之后，注册 “外部第四个then”，此时 ”内部第一个then“ 执行完成，注册 ”内部第二个then”，最后执行完“外部第四个then”，再执行 刚刚注册的“内部第二个then”.<br>
源代码如下：</p>
<pre><code class="language-cpp">void Promise::Resolver::Resolve(Handle&lt;Value&gt; value) {
  i::Handle&lt;i::JSObject&gt; promise = Utils::OpenHandle(this);
  i::Isolate* isolate = promise-&gt;GetIsolate();
  LOG_API(isolate, &quot;Promise::Resolver::Resolve&quot;);
  ENTER_V8(isolate);
  EXCEPTION_PREAMBLE(isolate);
  i::Handle&lt;i::Object&gt; argv[] = { promise, Utils::OpenHandle(*value) };
  has_pending_exception = i::Execution::Call(
      isolate,
      isolate-&gt;promise_resolve(),
      isolate-&gt;factory()-&gt;undefined_value(),
      arraysize(argv), argv,
      false).is_null();
  EXCEPTION_BAILOUT_CHECK(isolate, /* void */ ;);
}
</code></pre>
<pre><code class="language-js">PromiseResolve = function PromiseResolve(promise, x) {
    PromiseDone(promise, +1, x, promiseOnResolve)
}
function PromiseDone(promise, status, value, promiseQueue) {
    if (GET_PRIVATE(promise, promiseStatus) === 0) {
        PromiseEnqueue(value, GET_PRIVATE(promise, promiseQueue), status);
        PromiseSet(promise, status, value);
    }
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#promisea-%E5%92%8C-webkit-%E7%9A%84-promise-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%B7%AE%E5%BC%82">Promise/A+ 和 webkit 的 Promise 的实现差异</a>
<ul>
<li><a href="#promisea-%E7%9A%84%E5%AE%9E%E7%8E%B0">Promise/A+ 的实现：</a></li>
<li><a href="#promise-%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8webkit%E7%9A%84%E5%AE%9E%E7%8E%B0">Promise 的 浏览器(webkit)的实现：</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://yuufen.com/blog/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
